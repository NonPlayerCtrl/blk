//----------------------------------------------------------------------------//
//            Copyright 2018 Rieckermann Engineering Operations               //
//----------------------------------------------------------------------------//
// Class:       fbSIC1                                                        //
// Description:                                                               //
// Agitator speed control.                                                    //
//----------------------------------------------------------------------------//
// Revision history:                                                          //
// Rev By               Date        CC        Note                            //
// 2.0 David Paspa      30-Jan-2018 NA        Reboot for S7-1500.             //
// 1.0 Khairul/Steve    15-Oct-2009 CC-09/016 PID loop removed.               //
// 0.9 Gerald Kontriner 09-Oct-2009 CC-09/016 MON_MISMATCH Logic              //
// 0.8 Khairul Basar    02-Oct-2009 CC-09/016 ALARM_L corrected in NW25.      //
// 0.7 Mr. Khoon        01-Oct-2009 CC-09/016 Mode=Initialized,OOS coded.     //
// 0.6 Steve Linehan    29-Sep-2009 CC-09/016 Bypass Input Mode Added.        //
// 0.5 Khairul Basar    16-Sep-2009 CC-09/016 Duplicate Auto/man parameters   //
//                                            deleted auto/manual both now    //
//                                            using same parameters.          //
// 0.4 Khairul Basar    14-Sep-2009 CC-09/016 DataQuality variable&logic      //
//                                            added.                          //
// 0.3 Khairul Basar    11-Sep-2009 CC-09/016 Ref2.                           //
// 0.2 Khairul Basar    03-Sep-2009 CC-09/016 Ref1.                           //
// 0.1 Khairul Basar    03-Aug-2009           Initial design                  //
//                                                                            //
// Ref2:                                                                      //
// Now Setpoint is moved to PID as per selected mode.TAH,THR & FLT Contact are//
// corrected as per Failsafe siganl from field & FLT will result device state //
// 'FAULT=5'.In DB1, Device state changed to 3=Stop, 4=Running instead of     //
// 4=stop,3=Running.                                                          //
//                                                                            //
// Ref1:                                                                      //
// MI1 Measure value assigned to MASS_MI1 parameter,Now the Minimum mass      //
// condition is always overridden in manual mode.Now Device states are        //
// configured for ENABLED, when enabled two sub state STOPPED & RUNNING and   //
// DISABLED. Now Parameters MEASURE_RPM for agitator RPM , MASS_MI1 is for    //
// mass of the  vessel, parameter for set point of manual is SETPOINT_MAN, &  //
// in auto is SETPOINT_AUTO configured.Set point SETPOINT_MAN and             //
// SETPOINT_AUTO initialized to 0.0 and GAIN to 1.0.ALARM_HH, ALARM_H,        //
// ALARM_L, ALARM_LL are added in SIC1 and programmed.Default value added for //
// following parameters.                                                      //
// SL.NO.Parameter NameRange of ValueDefault Value                            //
// 1.MODE=1=Manual                                                            //
// 2.CMND_AUTO=1=disable                                                      //
// 3.CMND_MAN=1=disable                                                       //
// 4.P_SEL=True                                                               //
// 5.I_SEL=True                                                               //
// 6.D_SEL=True                                                               //
// 7.CYCLE=T#1s                                                               //
//----------------------------------------------------------------------------//
FUNCTION_BLOCK "fbSIC1"
TITLE = SIC1 : Agitator speed control
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : REO
NAME : fbSIC1
VERSION : 2.0

//----------------------------------------------------------------------------//
// Declare interface and variables:                                           //
//----------------------------------------------------------------------------//
VAR
    p : "udtSIC1";           // Block data interface
    startTMR {OriginalPartName := 'TON'; LibVersion := '1.0'} : TON;
    dirTMR {OriginalPartName := 'TON'; LibVersion := '1.0'} : TON;
    PID1 {OriginalPartName := 'CONT_C'; LibVersion := '1.0'} : CONT_C;
END_VAR

VAR_TEMP
    ALARM_L : Bool;          // Alarm_L
    ALARM_LL : Bool;         // Alarm_LL
    cmdEnable : Bool;
    cmdDisable : Bool;
    edgeStart : Bool;
    eventStart : Bool;
    eventTMRFwd : Bool;
    eventTMRRev : Bool;
    tDO : Bool;
    tILAnalog : Bool;
    tPV : Real;
    tPV_MASS : Real;
    RET_VAL1 : Word;
    unscaledOUT : Int;
    percentSpeed : Real;
    tSetpoint : Real;
    RANGE_ERROR : Bool;
    BROKEN_WIRE : Bool;
    dirTMRStart : Bool;
    startTMRExpired : Bool;
    dirTMRExpired : Bool;
    tManual_Not_PID : Bool;
    startTMRElapsed : Time;
    dirTMRElapsed : Time;
    permitMass : Bool;
    enable : Bool;
END_VAR

BEGIN
NETWORK
TITLE = Call Mode and Command handling block
    //------------------------------------------------------------------------//
    // COMMAND PROCESSOR   COMMAND PROCESSOR   COMMAND PROCESSOR   COMMAND    //
    //                                                                        //
    // Process the standard block functions for command, mode, interlock and  //
    // state:                                                                 //
    //------------------------------------------------------------------------//
    CALL "fcModeCmd"
    (   mcOrigin             := #p.origin.mc ,
        mcOwner              := #p.owner.mc
    );

NETWORK
TITLE = Enable command
    //------------------------------------------------------------------------//
    // COMMAND   COMMAND   COMMAND   COMMAND   COMMAND   COMMAND   COMMAND    //
    // COMMAND   COMMAND   COMMAND   COMMAND   COMMAND   COMMAND   COMMAND    //
    //                                                                        //
    // CMD is ENABLE:                                                         //
    //------------------------------------------------------------------------//
    A(;
    L #p.owner.mc.CMD;
    L "dbCONST".BLK.SIC1.CMD.ENABLE;
    ==I;
    );
    =#cmdEnable;

NETWORK
TITLE = Disable command
    //------------------------------------------------------------------------//
    // CMD is DISABLE:                                                        //
    //------------------------------------------------------------------------//
    A(;
    L #p.owner.mc.CMD;
    L "dbCONST".BLK.SIC1.CMD.DISABLE;
    ==I;
    );
    = #cmdDisable

NETWORK
TITLE = Cascade the MODE flags to the analog input structure
    //------------------------------------------------------------------------//
    // Set the ai MODE flags based on the mc calculated values:               //
    //------------------------------------------------------------------------//
    A #p.origin.mc.modeAUTO;
    = #p.origin.ai.modeAUTO;
    A #p.origin.mc.modeMANUAL;
    = #p.origin.ai.modeMANUAL;
    A #p.origin.mc.modeOOS;
    = #p.origin.ai.modeOOS;

NETWORK
TITLE = Analog input attributes
    //------------------------------------------------------------------------//
    // Set the analog input attributes:                                       //
    //------------------------------------------------------------------------//
    L #p.origin.RANGE_LOWER;
    T #p.origin.ai.RANGE_LOWER;
    L #p.origin.RANGE_UPPER;
    T #p.origin.ai.RANGE_UPPER;
    L #p.origin.LIMIT_HH;
    T #p.origin.ai.LIMIT_HH;
    L #p.origin.LIMIT_H;
    T #p.origin.ai.LIMIT_H;
    L 0.0;
    T #p.origin.ai.LIMIT_L;
    L 0.0;
    T #p.origin.ai.LIMIT_LL;
    A "alwaysHigh";
    = #p.origin.ai.ENABLE_HH;
    A "alwaysHigh";
    = #p.origin.ai.ENABLE_H;
    A "alwaysLow";
    = #p.origin.ai.ENABLE_L;
    A "alwaysLow";
    = #p.origin.ai.ENABLE_LL;
    L #p.origin.RAW_INPUT;
    T #p.origin.ai.RAW_INPUT;

NETWORK
TITLE = Call Analog Input handling function
    //------------------------------------------------------------------------//
    // INPUTS   INPUTS   INPUTS   INPUTS   INPUTS   INPUTS   INPUTS   INPUTS  //
    // INPUTS   INPUTS   INPUTS   INPUTS   INPUTS   INPUTS   INPUTS   INPUTS  //
    //                                                                        //
    // Scale the analog input value and check it is healty:                   //
    //------------------------------------------------------------------------//
    CALL "fcAnalog"
    (   ai                   := #p.origin.ai
    );

NETWORK
TITLE = Motor faults and three phase relay alarm
    //------------------------------------------------------------------------//
    // MOTOR FAULTS                                                           //
    // Raise alarm if any motor control fault condition is active:            //
    //------------------------------------------------------------------------//
    A #p.origin.PHR;
    = #p.origin.ALM_PHR;

NETWORK
TITLE = Motor breaker fault
    A #p.origin.BRK;
    = #p.origin.ALM_BRK;

NETWORK
TITLE = Pulse counter fault
    A #p.origin.FLP;
    = #p.origin.ALM_FLP;

NETWORK
TITLE = Inverter fault
    A #p.origin.FLT;
    = #p.origin.ALM_FLT;

NETWORK
TITLE = Thermistor module alarm
    A #p.origin.THM;
    = #p.origin.ALM_THM;

NETWORK
TITLE = Aggregate all interlock conditions
    //------------------------------------------------------------------------//
    // Collect all interlock conditions:                                      //
    //------------------------------------------------------------------------//
    O #p.origin.mc.INTERLOCK;
    O tILAnalog;
    O #p.origin.BRK;
    O #p.origin.THM;
    O #p.origin.FLP;
    O #p.origin.FLT;
    ON #p.origin.MI1_DQ;
    = #p.origin.mc.INTERLOCK;

NETWORK
TITLE = Interlock overrides ENABLE command
    //------------------------------------------------------------------------//
    // Don't allow enable command if any interlock:                           //
    //------------------------------------------------------------------------//
    A #cmdEnable;
    AN #p.origin.mc.INTERLOCK;
    = #cmdEnable;

NETWORK
TITLE = If not ENABLE then command must be DISABLE
    //------------------------------------------------------------------------//
    // Don't allow enable command if any interlock:                           //
    //------------------------------------------------------------------------//
    AN #cmdEnable;
    = #cmdDisable;

NETWORK
TITLE = Vessel mass
    //------------------------------------------------------------------------//
    // Get the vessel mass from the MI1 CM:                                   //
    //------------------------------------------------------------------------//
    L #p.origin.MI1_MASS;
    T #tPV_MASS;

NETWORK
TITLE = Permitted to run agitator if mass above minimum value
    //------------------------------------------------------------------------//
    // Permit the agitator to run if mass above minimum start level:          //
    //------------------------------------------------------------------------//
    A(;
    L #tPV_MASS;
    L #p.origin.MASS_RUN;
    >=R;
    );
    JCN _a;
    S #permitMass;
_a:   NOP 0;

NETWORK
TITLE = Low mass condition must stop the agitator from running
    //------------------------------------------------------------------------//
    // Inhibit the agitator from running if mass below minimum stop level:    //
    //------------------------------------------------------------------------//
    A(;
    L #tPV_MASS;
    L #p.origin.MASS_STOP;
    <R;
    );
    JCN _b;
    R #permitMass;
_b:   NOP 0;

NETWORK
TITLE = Setpoint if Enabled
    //------------------------------------------------------------------------//
    // Setpoint if ENABLE:                                                    //
    //------------------------------------------------------------------------//
    A #cmdEnable;
    JCN _c;
    L #p.owner.SETPOINT;
    T #tSetpoint;
_c:   NOP 0;

NETWORK
TITLE = Setpoint if Disabled
    //------------------------------------------------------------------------//
    // Setpoint should be 0 if disabled:                                      //
    //------------------------------------------------------------------------//
    A #cmdDisable;
    JCN _d;
    L 0;
    T #tSetpoint;
_d:   NOP 0;

NETWORK
TITLE = PID in manual if disabled or manual flag set
    //------------------------------------------------------------------------//
    // PID in manual mode if requested:                                       //
    //------------------------------------------------------------------------//
    O #cmdDisable;
    O(;
    A #cmdEnable;
    A #p.origin.mc.modeMANUAL;
    A #p.owner.MAN_PID;
    );
    = #tManual_Not_PID;

NETWORK
TITLE = Disable command
    //------------------------------------------------------------------------//
    // OUTPUTS   OUTPUTS   OUTPUTS   OUTPUTS   OUTPUTS   OUTPUTS   OUTPUTS    //
    // OUTPUTS   OUTPUTS   OUTPUTS   OUTPUTS   OUTPUTS   OUTPUTS   OUTPUTS    //
    //                                                                        //
    // DISABLE command if not enabled or any interlock:                       //
    //------------------------------------------------------------------------//
    A #cmdDisable;
    JCN _e;
    L "dbCONST".BLK.SIC1.CMD.DISABLE;
    T #p.owner.mc.CMD;
_e:   NOP 0;

NETWORK
TITLE = Flag output should be on if command is ENABLE and mass is enough
    //------------------------------------------------------------------------//
    // Flag output to be set on if command is enable and no interlock and     //
    // mass in the vessel is high enough to permit agiator operation and      //
    // no stop request from another interested party (i.e. module, such EMM1)://
    //------------------------------------------------------------------------//
    A #cmdEnable;
    A #permitMass;
    AN #p.origin.mc.modeOOS;
    AN(;
    L #p.owner.CMD_PEER;
    L "dbCONST".BLK.SIC1.STATE.STOPPED;
    ==I;
    );
    = #tDO;

NETWORK
TITLE = Set the peer state running if so
    //------------------------------------------------------------------------//
    // If agitator might run then the peer state is running:                  //
    //------------------------------------------------------------------------//
    A #tDO;
    JCN _peerRunning;
    L "dbCONST".BLK.SIC1.STATE.RUNNING;
    T #p.origin.STATE_PEER;
_peerRunning:   NOP 0;

NETWORK
TITLE = Set the peer state stopped if so
    //------------------------------------------------------------------------//
    // If agitator is stopped then the peer state is stopped:                 //
    //------------------------------------------------------------------------//
    AN #tDO;
    JCN _peerStopped;
    L "dbCONST".BLK.SIC1.STATE.STOPPED;
    T #p.origin.STATE_PEER;
_peerStopped:   NOP 0;

NETWORK
TITLE = Drive the agitator output on if commanded and safe to run
    //------------------------------------------------------------------------//
    // Start the agitator if allowed to run if command is ENABLE and there    //
    // are no interlocks and mass in the vessel is sufficient:                //
    //------------------------------------------------------------------------//
    A #tDO;
    = #p.origin.OUT_Q;

NETWORK
TITLE = Transfer the setpoint to the inverter reference value
    //------------------------------------------------------------------------//
    // Start the agitator if allowed to run if command is ENABLE and there    //
    // are no interlocks and mass in the vessel is sufficient:                //
    //------------------------------------------------------------------------//
    A #tDO;
    JCN _f;
    L #tSetpoint;
    T #p.origin.OUT_LMN;
_f:   NOP 0;

NETWORK
TITLE = Transfer the setpoint to the output setpoint
    //------------------------------------------------------------------------//
    // Transfer setpoint to output setpoint:                                  //
    //------------------------------------------------------------------------//
    L #tSetpoint;
    T #p.origin.OUT_SETPOINT;

NETWORK
TITLE = Unscale Setpoint
    //------------------------------------------------------------------------//
    // Unscale the setpoint to set the inverter percent reference value.      //
    // For POLARITY, 0 = no polarity (0 to +x), 1 = dual polarity (-x to +x): //
    //------------------------------------------------------------------------//
    A #tDO;
    JCN _g;
    CALL UNSCALE
    (   IN                   := #tSetpoint ,
        HI_LIM               := #p.origin.ai.RANGE_UPPER ,
        LO_LIM               := #p.origin.ai.RANGE_LOWER ,
        BIPOLAR              := 1 ,
        RET_VAL              := #RET_VAL1 ,
        OUT                  := #unscaledOUT
    );
_g:   NOP 0;

NETWORK
TITLE = Setpoint reference to inverter in percent
    //------------------------------------------------------------------------//
    // Set the inverter percent reference value if running:                   //
    //------------------------------------------------------------------------//
    A #tDO;
    JCN _h;
    L #unscaledOUT;
    T #p.origin.OUT_LMN_PER;
_h:   NOP 0;

NETWORK
TITLE = PID Controller
    //------------------------------------------------------------------------//
    // PID algorithm if enabled in AUTO mode:                                 //
    //------------------------------------------------------------------------//
    CALL #PID1
    (   COM_RST              := "flagFirstScanRestart" ,
        MAN_ON               := #tManual_Not_PID ,
        P_SEL                := #p.origin.P_SEL ,
        I_SEL                := #p.origin.I_SEL ,
        D_SEL                := #p.origin.D_SEL ,
        CYCLE                := #p.origin.CYCLE ,
        SP_INT               := #tSetpoint ,
        PV_IN                := #p.origin.PV ,
        MAN                  := #tSetpoint ,
        GAIN                 := #p.origin.GAIN ,
        TI                   := #p.origin.TI ,
        TD                   := #p.origin.TD ,
        LMN_HLM              := 100.0 ,
        LMN_LLM              := 0.0 ,
        LMN                  := #p.origin.LMN
    );

NETWORK
TITLE = Output if Disabled
    //------------------------------------------------------------------------//
    // Output should be 0 if disabled:                                        //
    //------------------------------------------------------------------------//
    A #cmdDisable;
    JCN _i;
    L 0.0;
    T #p.origin.LMN;
_i:   NOP 0;

NETWORK
TITLE = Start event if commanded to start
    //------------------------------------------------------------------------//
    // Flag start event if just commanded to start:                           //
    //------------------------------------------------------------------------//
    A #tDO;
    FP #edgeStart;
    = #eventStart;

NETWORK
TITLE = Start timer to check if fail to start or run at low speed
    //------------------------------------------------------------------------//
    // Start timer if commanded to run:                                       //
    //------------------------------------------------------------------------//
    A #eventStart;
    JCN _j;
    CALL #startTMR
    {time_type := 'Time'}
    (   IN                   := #tDO ,
        PT                   := #p.origin.FB_TDELAY ,
        Q                    := #startTMRExpired ,
        ET                   := #startTMRElapsed
    );
_j:   NOP 0;

NETWORK
TITLE = Fault if start timer expired and not running
    //------------------------------------------------------------------------//
    // Fault if start timer expired and still not running:                    //
    //------------------------------------------------------------------------//
    A #startTMR.Q;
    AN #p.origin.RUNNING;
    AN #p.origin.mc.modeOOS;
    = #p.origin.RUN_FAULT;

NETWORK
TITLE = Calculate speed as a fraction of the setpoint
    //------------------------------------------------------------------------//
    // Calculate actual speed as a fraction of setpoint:                      //
    //------------------------------------------------------------------------//
    A #tDO;
    JCN _k;
    L #tPV;
    L #tSetpoint;
    /R;
    T #percentSpeed;
_k:   NOP 0;

NETWORK
TITLE = Calculate speed as a percent of the setpoint
    //------------------------------------------------------------------------//
    // Calculate actual speed as a percent of setpoint:                       //
    //------------------------------------------------------------------------//
    A #tDO;
    JCN _l;
    L #percentSpeed;
    L 100.0;
    *R;
    T #percentSpeed;
_l:   NOP 0;

NETWORK
TITLE = Flag RUNNING if speed above 25% of setpoint
    //------------------------------------------------------------------------//
    // Flag RUNNING if actual speed is above 25% of setpoint:                 //
    //------------------------------------------------------------------------//
    A #tDO;
    L #percentSpeed;
    L 25.0;
    >R;
    = #p.origin.RUNNING;

NETWORK
TITLE = Run Direction Forward if just started
    //------------------------------------------------------------------------//
    // Direction is forward if command to start raised:                       //
    //------------------------------------------------------------------------//
    A #eventStart;
    = #p.origin.OUT_Q_F;

NETWORK
TITLE = Check run command and direction timer expired
    //------------------------------------------------------------------------//
    // Check if run command output is on and direction change timer expired:  //
    //------------------------------------------------------------------------//
    A #tDO;
    AN #dirTMR.Q;
    = #dirTMRStart;

NETWORK
TITLE = Start Forward Reverse Direction Timer
    //------------------------------------------------------------------------//
    // If running and direction changed, start timer to reverse again:        //
    //------------------------------------------------------------------------//
    CALL #dirTMR
    {time_type := 'Time'}
    (   IN                   := #dirTMRStart ,
        PT                   := T#5M ,
        Q                    := #dirTMRExpired ,
        ET                   := #dirTMRElapsed
    );
    NOP 0;

NETWORK
TITLE = Reverse direction if timer expired
    //------------------------------------------------------------------------//
    // Change direction if timer expired:                                     //
    //------------------------------------------------------------------------//
    A #dirTMR.Q;
    A #p.origin.OUT_Q_F;
    = #eventTMRRev;

    A #eventTMRRev;
    JCN _m;
    R #p.origin.OUT_Q_F;
_m:   NOP 0;

    A #eventTMRRev;
    JCN _n;
    S #p.origin.OUT_Q_R;
_n:   NOP 0;

    A #dirTMR.Q;
    A #p.origin.OUT_Q_R;
    = #eventTMRFwd;

    A #eventTMRFwd;
    JCN _o;
    S #p.origin.OUT_Q_F;
_o:   NOP 0;

    A #eventTMRFwd;
    JCN _p;
    R #p.origin.OUT_Q_R;
_p:   NOP 0;
NETWORK

TITLE = Disable state
    //------------------------------------------------------------------------//
    // STATE   STATE   STATE   STATE   STATE   STATE   STATE   STATE   STATE  //
    // STATE   STATE   STATE   STATE   STATE   STATE   STATE   STATE   STATE  //
    //                                                                        //
    // DISABLED if command is disable or any interlock and not motor fault:   //
    //------------------------------------------------------------------------//
    AN #p.origin.BRK;
    AN #p.origin.THM;
    AN #p.origin.FLP;
    AN #p.origin.FLT;
    A #cmdDisable;
    JCN _q;
    L "dbCONST".BLK.SIC1.STATE.DISABLED;
    T #p.origin.mc.STATE;
_q:   NOP 0;

NETWORK
TITLE = FAULT if any fault condition active
    //------------------------------------------------------------------------//
    // FAULT if any motor fault condition is active:                          //
    //------------------------------------------------------------------------//
    O #p.origin.BRK;
    O #p.origin.THM;
    O #p.origin.FLP;
    O #p.origin.FLT;
    JCN _r;
    L "dbCONST".BLK.SIC1.STATE.FAULT;
    T #p.origin.mc.STATE;
_r:   NOP 0;

NETWORK
TITLE = Stopped if command is ENABLE and mass not enough
    //------------------------------------------------------------------------//
    // STOPPED if command is enable and no interlock but mass not enough:     //
    //------------------------------------------------------------------------//
    A #cmdEnable;
    AN #permitMass;
    JCN _s;
    L "dbCONST".BLK.SIC1.STATE.STOPPED;
    T #p.origin.mc.STATE;
_s:   NOP 0;

NETWORK
TITLE = Running if output should be on
    //------------------------------------------------------------------------//
    // RUNNING if command is enable and no interlock and mass permits:        //
    //------------------------------------------------------------------------//
    A #tDO;
    JCN _t;
    L "dbCONST".BLK.SIC1.STATE.RUNNING;
    T #p.origin.mc.STATE;
_t:   NOP 0;
END_FUNCTION_BLOCK
