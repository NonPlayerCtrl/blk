//----------------------------------------------------------------------------//
//            Copyright 2018 Rieckermann Engineering Operations               //
//----------------------------------------------------------------------------//
// Class:       fbSIC1                                                        //
// Description:                                                               //
// Agitator speed control.                                                    //
//----------------------------------------------------------------------------//
// Revision history:                                                          //
// Rev By               Date        CC        Note                            //
// 2.0 David Paspa      30-Jan-2018 NA        Reboot for S7-1500.             //
// 1.0 Khairul/Steve    15-Oct-2009 CC-09/016 PID loop removed.               //
// 0.9 Gerald Kontriner 09-Oct-2009 CC-09/016 MON_MISMATCH Logic              //
// 0.8 Khairul Basar    02-Oct-2009 CC-09/016 ALARM_L corrected in NW25.      //
// 0.7 Mr. Khoon        01-Oct-2009 CC-09/016 Mode=Initialized,OOS coded.     //
// 0.6 Steve Linehan    29-Sep-2009 CC-09/016 Bypass Input Mode Added.        //
// 0.5 Khairul Basar    16-Sep-2009 CC-09/016 Duplicate Auto/man parameters   //
//                                            deleted auto/manual both now    //
//                                            using same parameters.          //
// 0.4 Khairul Basar    14-Sep-2009 CC-09/016 DataQuality variable&logic      //
//                                            added.                          //
// 0.3 Khairul Basar    11-Sep-2009 CC-09/016 Ref2.                           //
// 0.2 Khairul Basar    03-Sep-2009 CC-09/016 Ref1.                           //
// 0.1 Khairul Basar    03-Aug-2009           Initial design                  //
//                                                                            //
// Ref2:                                                                      //
// Now Setpoint is moved to PID as per selected mode.TAH,THR & FLT Contact are//
// corrected as per Failsafe siganl from field & FLT will result device state //
// 'FAULT=5'.In DB1, Device state changed to 3=Stop, 4=Running instead of     //
// 4=stop,3=Running.                                                          //
//                                                                            //
// Ref1:                                                                      //
// MI1 Measure value assigned to MASS_MI1 parameter,Now the Minimum mass      //
// condition is always overridden in manual mode.Now Device states are        //
// configured for ENABLED, when enabled two sub state STOPPED & RUNNING and   //
// DISABLED. Now Parameters MEASURE_RPM for agitator RPM , MASS_MI1 is for    //
// mass of the  vessel, parameter for set point of manual is SETPOINT_MAN, &  //
// in auto is SETPOINT_AUTO configured.Set point SETPOINT_MAN and             //
// SETPOINT_AUTO initialized to 0.0 and GAIN to 1.0.ALARM_HH, ALARM_H,        //
// ALARM_L, ALARM_LL are added in SIC1 and programmed.Default value added for //
// following parameters.                                                      //
// SL.NO.Parameter NameRange of ValueDefault Value                            //
// 1.MODE=1=Manual                                                            //
// 2.CMND_AUTO=1=disable                                                      //
// 3.CMND_MAN=1=disable                                                       //
// 4.P_SEL=True                                                               //
// 5.I_SEL=True                                                               //
// 6.D_SEL=True                                                               //
// 7.CYCLE=T#1s                                                               //
//----------------------------------------------------------------------------//
FUNCTION_BLOCK "fbSIC1"
TITLE = SIC1 : Agitator speed control
{ S7_Optimized_Access := 'FALSE' }
AUTHOR : REO
NAME : fbSIC1
VERSION : 2.0

//----------------------------------------------------------------------------//
// Declare variables:                                                         //
//----------------------------------------------------------------------------//
VAR_INPUT
    OWNER : Int;             // Value to be set by Parent
    SERIAL : Int;            // Unique batch or CIPSIP serial number
    CRIL : Bool;             // Critical interlock
    NCRIL : Bool;            // Non-critical interlock
    MAN_OVERRIDE : Bool;     // Override non-critical interlocks
    SETPOINT : Real;
    RAW_INPUT : Word;        // Measured Process Value received from control module
    MAN_PID : Bool;          // Manual non pid selection
    BRK	: Bool;              // Motor breaker fault
    PHR : Bool;              // Three-phase relay alarm
    FLP : Bool;              // Pulse counter fault
    FLT : Bool;              // Inverter fault
    THM : Bool;              // Thermistor module alarm
    MASS_RUN : Real := 250.0;// M1=250.0 , M2=100.0, M3=40.0
    MASS_STOP : Real := 200.0;// M1=200,M2=70,M3=20.0
    RANGE_UPPER : Real := 60.0;// M1=1500,M2=500,M3=100.0
    RANGE_LOWER : Real;
    POLARITY : Bool;         // 0- no polarity(0 to z), 1= dual polarity(-x to +y)
    LIMIT_HH : Real := 252.0;// High High speed alarm limit
    LIMIT_H : Real := 251.0; // High speed alarm limit
    MI1_MASS : Real;         // Measured Mass
    MI1_DQ : Bool;           // Measured Mass Data Quality
    FB_TDELAY : Time := T#20S;
    P_SEL : Bool := TRUE;
    I_SEL : Bool := TRUE;
    D_SEL : Bool := TRUE;
    GAIN : Real := 1.0;
    TI : Time := T#20S;
    TD : Time := T#10S;
    CYCLE : Time := T#1S;    // SAMPLING TIME:The time between the block calls constant
END_VAR

VAR_OUTPUT
    PV : Real;               // Measured Value (after scaling)
    DQ : Bool;
    OUT_Q : Bool;            // Inverter Motor Run/Stop Command
    OUT_Q_F : Bool;
    OUT_Q_R : Bool;
    ALM_BRK : Bool;
    ALM_PHR : Bool;
    ALM_FLP : Bool;
    ALM_FLT : Bool;
    ALM_THM : Bool;
    ALARM_HH : Bool;         // Alamr HH
    ALARM_H : Bool;          // Alarm_H
    RUNNING : Bool;
    RUN_FAULT : Bool;
    OUT_SETPOINT : Real;     // Setpoint readvalue
    LMN : Real;              // PID controller output (0-100%)
    OUT_LMN_PER : Word;      // Inverter speed reference input
    OUT_LMN : Real;          // Inverter Speed reference from PID
END_VAR

VAR_IN_OUT
    CMD : Int;               // Device Command from dbCONST
    MODE : Int;              // Control Mode
    STATE : Int;             // Device State from dbCONST
    INTERLOCK : Bool;        // Interlock Flag (0 = Inactive, 1 = Active)
END_VAR

VAR
    startTMR {OriginalPartName := 'TON'; LibVersion := '1.0'} : TON;
    dirTMR {OriginalPartName := 'TON'; LibVersion := '1.0'} : TON;
    PID1 {OriginalPartName := 'CONT_C'; LibVersion := '1.0'} : CONT_C;
    permitMass : Bool;
    enable : Bool;
END_VAR

VAR_TEMP
    ALARM_L : Bool;          // Alarm_L
    ALARM_LL : Bool;         // Alarm_LL
    cmdEnable : Bool;
    cmdDisable : Bool;
    edgeStart : Bool;
    eventStart : Bool;
    eventTMRFwd : Bool;
    eventTMRRev : Bool;
    tDO : Bool;
    tILAnalog : Bool;
    tPV : Real;
    tPV_MASS : Real;
    RET_VAL1 : Word;
    unscaledOUT : Int;
    percentSpeed : Real;
    tSetpoint : Real;
    RANGE_ERROR : Bool;
    BROKEN_WIRE : Bool;
    modeAUTO : Bool;
    modeMANUAL : Bool;
    modeOOS : Bool;
    dirTMRStart : Bool;
    tManual_Not_PID : Bool;
END_VAR

BEGIN
NETWORK
TITLE = Call Mode and Command handling block
    //------------------------------------------------------------------------//
    // COMMAND PROCESSOR   COMMAND PROCESSOR   COMMAND PROCESSOR   COMMAND    //
    //                                                                        //
    // Process the standard block functions for command, mode, interlock and  //
    // state:                                                                 //
    //------------------------------------------------------------------------//
    CALL "fcModeCmd"
    (
        CRIL                 := #CRIL ,
        NCRIL                := #NCRIL ,
        MAN_OVERRIDE         := #MAN_OVERRIDE ,
        CMD_SAFE             := "dbCONST".BLK.SIC1.SAFE.CMD ,
        MODE                 := #MODE ,
        CMD                  := #CMD ,
        STATE                := #STATE ,
        INTERLOCK            := #INTERLOCK ,
        modeAUTO             := #modeAUTO ,
        modeMANUAL           := #modeMANUAL ,
        modeOOS              := #modeOOS
    );
    NOP 0;

NETWORK
TITLE = Enable command
    //------------------------------------------------------------------------//
    // COMMAND   COMMAND   COMMAND   COMMAND   COMMAND   COMMAND   COMMAND    //
    // COMMAND   COMMAND   COMMAND   COMMAND   COMMAND   COMMAND   COMMAND    //
    //                                                                        //
    // CMD is ENABLE:                                                         //
    //------------------------------------------------------------------------//
    L #CMD;
    L "dbCONST".BLK.SIC1.CMD.ENABLE;
    ==I;
    =#cmdEnable;

NETWORK
TITLE = Disable command
    //------------------------------------------------------------------------//
    // CMD is DISABLE:                                                        //
    //------------------------------------------------------------------------//
    L #CMD;
    L "dbCONST".BLK.SIC1.CMD.DISABLE;
    ==I;
    = #cmdDisable

NETWORK
TITLE = Call Analog Input handling function
    //------------------------------------------------------------------------//
    // INPUTS   INPUTS   INPUTS   INPUTS   INPUTS   INPUTS   INPUTS   INPUTS  //
    // INPUTS   INPUTS   INPUTS   INPUTS   INPUTS   INPUTS   INPUTS   INPUTS  //
    //                                                                        //
    // Scale the analog input value and check it is healty:                   //
    //------------------------------------------------------------------------//
    CALL "fcAnalog"
    (   RAW_INPUT            := #RAW_INPUT ,
        USER_INPUT           := #USER_INPUT ,
        RANGE_UPPER          := #RANGE_UPPER ,
        RANGE_LOWER          := #RANGE_LOWER ,
        POLARITY             := #POLARITY ,
        LIMIT_HH             := #LIMIT_HH ,
        LIMIT_H              := #LIMIT_H ,
        LIMIT_L              := 0 ,
        LIMIT_LL             := 0 ,
        ENABLE_HH            := 1 ,
        ENABLE_H             := 1 ,
        ENABLE_L             := -1 ,
        ENABLE_LL            := -2 ,
        STATE_ENABLED        := #STATE_ENABLED ,
        STATE_FAULT          := #STATE_FAULT ,
        modeAUTO             := #modeAUTO ,
        modeMANUAL           := #modeMANUAL ,
        modeOOS              := #modeOOS ,
        PV                   := #PV ,
        DQ                   := #DQ ,
        ALARM_HH             := #ALARM_HH ,
        ALARM_H              := #ALARM_H ,
        ALARM_L              := #ALARM_L ,
        ALARM_LL             := #ALARM_LL ,
        STATE                := #STATE ,
        INTERLOCK            := #tILAnalog ,
        RANGE_ERROR          := #RANGE_ERROR ,
        BROKEN_WIRE          := #BROKEN_WIRE
    );
    NOP 0;

NETWORK
TITLE = Motor faults and three phase relay alarm
    //------------------------------------------------------------------------//
    // MOTOR FAULTS                                                           //
    // Raise alarm if any motor control fault condition is active:            //
    //------------------------------------------------------------------------//
    A #PHR;
    = #ALM_PHR;

NETWORK
TITLE = Motor breaker fault
    A #BRK;
    = #ALM_BRK;

NETWORK
TITLE = Pulse counter fault
    A #FLP;
    = #ALM_FLP;

NETWORK
TITLE = Inverter fault
    A #FLT;
    = #ALM_FLT;

NETWORK
TITLE = Thermistor module alarm
    A #THM;
    = #ALM_THM;

NETWORK
TITLE = Aggregate all interlock conditions
    //------------------------------------------------------------------------//
    // Collect all interlock conditions:                                      //
    //------------------------------------------------------------------------//
    O #INTERLOCK;
    O tILAnalog;
    O #BRK;
    O #THM;
    O #FLP;
    O #FLT;
    ON #MI1_DQ;
    = #INTERLOCK;

NETWORK
TITLE = Interlock overrides ENABLE command
    //------------------------------------------------------------------------//
    // Don't allow enable command if any interlock:                           //
    //------------------------------------------------------------------------//
    A #cmdEnable;
    AN #INTERLOCK;
    = #cmdEnable;

NETWORK
TITLE = If not ENABLE then command must be DISABLE
    //------------------------------------------------------------------------//
    // Don't allow enable command if any interlock:                           //
    //------------------------------------------------------------------------//
    AN #cmdEnable;
    = #cmdDisable;

NETWORK
TITLE = Vessel mass
    //------------------------------------------------------------------------//
    // Get the vessel mass from the MI1 CM:                                   //
    //------------------------------------------------------------------------//
    L #MI1_MASS;
    T #tPV_MASS;

NETWORK
TITLE = Permitted to run agitator if mass above minimum value
    //------------------------------------------------------------------------//
    // Permit the agitator to run if mass above minimum start level:          //
    //------------------------------------------------------------------------//
    L #tPV_MASS;
    L #MASS_RUN;
    >=R;
    S #permitMass;

NETWORK
TITLE = Low mass condition must stop the agitator from running
    //------------------------------------------------------------------------//
    // Inhibit the agitator from running if mass below minimum stop level:    //
    //------------------------------------------------------------------------//
    L #tPV_MASS;
    L #MASS_STOP;
    <R;
    R #permitMass;

NETWORK
TITLE = Setpoint if Enabled
    //------------------------------------------------------------------------//
    // Setpoint if ENABLE:                                                    //
    //------------------------------------------------------------------------//
    A #cmdEnable;
    L #SETPOINT;
    T #tSetpoint;

NETWORK
TITLE = Setpoint if Disabled
    //------------------------------------------------------------------------//
    // Setpoint should be 0 if disabled:                                      //
    //------------------------------------------------------------------------//
    A #cmdDisable;
    L 0;
    T #tSetpoint;

NETWORK
TITLE = PID in manual if disabled or manual flag set
    //------------------------------------------------------------------------//
    // PID in manual mode if requested:                                       //
    //------------------------------------------------------------------------//
    O #cmdDisable;
    O(;
    A #cmdEnable;
    A #modeMANUAL;
    A #MAN_PID;
    );
    = #tManual_Not_PID;

NETWORK
TITLE = Disable command
    //------------------------------------------------------------------------//
    // OUTPUTS   OUTPUTS   OUTPUTS   OUTPUTS   OUTPUTS   OUTPUTS   OUTPUTS    //
    // OUTPUTS   OUTPUTS   OUTPUTS   OUTPUTS   OUTPUTS   OUTPUTS   OUTPUTS    //
    //                                                                        //
    // DISABLE command if not enabled or any interlock:                       //
    //------------------------------------------------------------------------//
    A #cmdDisable;
    L "dbCONST".BLK.SIC1.CMD.DISABLE;
    T #CMD;

NETWORK
TITLE = Flag output should be on if command is ENABLE and mass is enough
    //------------------------------------------------------------------------//
    // Flag output to be set on if command is enable and no interlock and     //
    // mass in the vessel is high enough to permit agiator operation:         //
    //------------------------------------------------------------------------//
    A #cmdEnable;
    A #permitMass;
    AN #modeOOS;
    = #tDO;

NETWORK
TITLE = Drive the agitator output on if commanded and safe to run
    //------------------------------------------------------------------------//
    // Start the agitator if allowed to run if command is ENABLE and there    //
    // are no interlocks and mass in the vessel is sufficient:                //
    //------------------------------------------------------------------------//
    A #tDO;
    = #OUT_Q;

NETWORK
TITLE = Transfer the setpoint to the inverter reference value
    //------------------------------------------------------------------------//
    // Start the agitator if allowed to run if command is ENABLE and there    //
    // are no interlocks and mass in the vessel is sufficient:                //
    //------------------------------------------------------------------------//
    A #tDO;
    L #tSetpoint;
    T #OUT_LMN;

NETWORK
TITLE = Unscale Setpoint
    //------------------------------------------------------------------------//
    // Unscale the setpoint to set the inverter percent reference value:      //
    //------------------------------------------------------------------------//
    A #tDO;
    CALL UNSCALE
    (   IN                   := #tSetpoint ,
        HI_LIM               := #RANGE_UPPER ,
        LO_LIM               := #RANGE_LOWER ,
        BIPOLAR              := 0 ,
        RET_VAL              := #RET_VAL1 ,
        OUT                  := #unscaledOUT
    );

NETWORK
TITLE = Setpoint reference to inverter in percent
    //------------------------------------------------------------------------//
    // Set the inverter percent reference value if running:                   //
    //------------------------------------------------------------------------//
    A #tDO;
    L #unscaledOUT;
    T #OUT_LMN_PER;

NETWORK
TITLE = PID Controller
    //------------------------------------------------------------------------//
    // PID algorithm if enabled in AUTO mode:                                 //
    //------------------------------------------------------------------------//
    CALL #PID1
    (   COM_RST              := "flagFirstScanRestart" ,
        MAN_ON               := #tManual_Not_PID ,
        P_SEL                := #P_SEL ,
        I_SEL                := #I_SEL ,
        D_SEL                := #D_SEL ,
        CYCLE                := #CYCLE ,
        SP_INT               := #tSetpoint ,
        PV_IN                := #PV ,
        MAN                  := #tSetpoint ,
        GAIN                 := #GAIN ,
        TI                   := #TI ,
        TD                   := #TD ,
        LMN_HLM              := 100.0 ,
        LMN_LLM              := 0.0 ,
        LMN                  := #LMN
    );

NETWORK
TITLE = Output if Disabled
    //------------------------------------------------------------------------//
    // Output should be 0 if disabled:                                        //
    //------------------------------------------------------------------------//
    A #cmdDisable;
    L 0.0;
    T #LMN;

NETWORK
TITLE = Start event if commanded to start
    //------------------------------------------------------------------------//
    // Flag start event if just commanded to start:                           //
    //------------------------------------------------------------------------//
    A #tDO;
    FP #edgeStart;
    = #eventStart;

NETWORK
TITLE = Start timer to check if fail to start or run at low speed
    //------------------------------------------------------------------------//
    // Start timer if commanded to run:                                       //
    //------------------------------------------------------------------------//
    A #eventStart;
    CALL #startTMR
    {time_type := 'Time'}
    (   IN                   := #tDO ,
        PT                   := #FB_TDELAY ,
        Q                    := #startTMR.Q ,
        ET                   := #startTMR.ET
    );

NETWORK
TITLE = Fault if start timer expired and not running
    //------------------------------------------------------------------------//
    // Fault if start timer expired and still not running:                    //
    //------------------------------------------------------------------------//
    A #startTMR.Q;
    AN #RUNNING;
    AN #modeOOS;
    = #RUN_FAULT;

NETWORK
TITLE = Calculate speed as a fraction of the setpoint
    //------------------------------------------------------------------------//
    // Calculate actual speed as a fraction of setpoint:                      //
    //------------------------------------------------------------------------//
    A #OUT_Q;
    L #tPV;
    L #OUT_SETPOINT;
    /R;
    T #percentSpeed;

NETWORK
TITLE = Calculate speed as a percent of the setpoint
    //------------------------------------------------------------------------//
    // Calculate actual speed as a percent of setpoint:                       //
    //------------------------------------------------------------------------//
    A #OUT_Q;
    L #percentSpeed;
    L 100.0;
    *R;
    T #percentSpeed;

NETWORK
TITLE = Flag RUNNING if speed above 25% of setponit
    //------------------------------------------------------------------------//
    // Flag RUNNING if actual speed is above 25% of setpoint:                 //
    //------------------------------------------------------------------------//
    A #OUT_Q;
    L #percentSpeed;
    L 25.0;
    >R;
    = #RUNNING;

NETWORK
TITLE = Run Direction Forward if just started
    //------------------------------------------------------------------------//
    // Direction is forward if command to start raised:                       //
    //------------------------------------------------------------------------//
    A #eventStart;
    = #OUT_Q_F;

NETWORK
TITLE = Check run command and direction timer expired
    //------------------------------------------------------------------------//
    // Check if run command output is on and direction change timer expired:  //
    //------------------------------------------------------------------------//
    A #tDO;
    AN #dirTMR.Q;
    = #dirTMRStart;

NETWORK
TITLE = Start Forward Reverse Direction Timer
    //------------------------------------------------------------------------//
    // If running and direction changed, start timer to reverse again:        //
    //------------------------------------------------------------------------//
    CALL #dirTMR
    {time_type := 'Time'}
    (   IN                   := #dirTMRStart ,
        PT                   := T#5M ,
        Q                    := #dirTMR.Q ,
        ET                   := #dirTMR.ET
    );
    NOP 0;

NETWORK
TITLE = Reverse direction if timer expired
    //------------------------------------------------------------------------//
    // Change direction if timer expired:                                     //
    //------------------------------------------------------------------------//
    A #dirTMR.Q;
    A #OUT_Q_F;
    = #eventTMRRev;

    A #eventTMRRev;
    R #OUT_Q_F;

    A #eventTMRRev;
    S #OUT_Q_R;

    A #dirTMR.Q;
    A #OUT_Q_R;
    = #eventTMRFwd;

    A #eventTMRFwd;
    S #OUT_Q_F;

    A #eventTMRFwd;
    R #OUT_Q_R;
NETWORK

TITLE = Disable state
    //------------------------------------------------------------------------//
    // STATE   STATE   STATE   STATE   STATE   STATE   STATE   STATE   STATE  //
    // STATE   STATE   STATE   STATE   STATE   STATE   STATE   STATE   STATE  //
    //                                                                        //
    // DISABLED if command is disable or any interlock and not motor fault:   //
    //------------------------------------------------------------------------//
    AN #BRK;
    AN #THM;
    AN #FLP;
    AN #FLT;
    A #cmdDisable;
    L "dbCONST".BLK.SIC1.STATE.DISABLED;
    T #STATE;

NETWORK
TITLE = FAULT if any fault condition active
    //------------------------------------------------------------------------//
    // FAULT if any motor fault condition is active:                          //
    //------------------------------------------------------------------------//
    O #BRK;
    O #THM;
    O #FLP;
    O #FLT;
    L "dbCONST".BLK.SIC1.STATE.FAULT;
    T #STATE;

NETWORK
TITLE = Stopped if command is ENABLE and mass not enough
    //------------------------------------------------------------------------//
    // STOPPED if command is enable and no interlock but mass not enough:     //
    //------------------------------------------------------------------------//
    A #cmdEnable;
    AN #permitMass;
    L "dbCONST".BLK.SIC1.STATE.STOPPED;
    T #STATE;

NETWORK
TITLE = Running if output should be on
    //------------------------------------------------------------------------//
    // RUNNING if command is enable and no interlock and mass permits:        //
    //------------------------------------------------------------------------//
    A #tDO;
    L "dbCONST".BLK.SIC1.STATE.RUNNING;
    T #STATE;
END_FUNCTION_BLOCK
