//----------------------------------------------------------------------------//
//            Copyright 2018 Rieckermann Engineering Operations               //
//----------------------------------------------------------------------------//
// Class:       fbSIC1                                                        //
// Description:                                                               //
// Agitator speed control.                                                    //
//----------------------------------------------------------------------------//
// Revision history:                                                          //
// Rev By               Date        CC        Note                            //
// 2.0 David Paspa      30-Jan-2018 NA        Reboot for S7-1500.             //
// 1.0 Khairul/Steve    15-Oct-2009 CC-09/016 PID loop removed.               //
// 0.9 Gerald Kontriner 09-Oct-2009 CC-09/016 MON_MISMATCH Logic              //
// 0.8 Khairul Basar    02-Oct-2009 CC-09/016 ALARM_L corrected in NW25.      //
// 0.7 Mr. Khoon        01-Oct-2009 CC-09/016 Mode=Initialized,OOS coded.     //
// 0.6 Steve Linehan    29-Sep-2009 CC-09/016 Bypass Input Mode Added.        //
// 0.5 Khairul Basar    16-Sep-2009 CC-09/016 Duplicate Auto/man parameters   //
//                                            deleted auto/manual both now    //
//                                            using same parameters.          //
// 0.4 Khairul Basar    14-Sep-2009 CC-09/016 DataQuality variable&logic      //
//                                            added.                          //
// 0.3 Khairul Basar    11-Sep-2009 CC-09/016 Ref2.                           //
// 0.2 Khairul Basar    03-Sep-2009 CC-09/016 Ref1.                           //
// 0.1 Khairul Basar    03-Aug-2009           Initial design                  //
//                                                                            //
// Ref2:                                                                      //
// Now Setpoint is moved to PID as per selected mode.TAH,THR & FLT Contact are//
// corrected as per Failsafe siganl from field & FLT will result device state //
// 'FAULT=5'.In DB1, Device state changed to 3=Stop, 4=Running instead of     //
// 4=stop,3=Running.                                                          //
//                                                                            //
// Ref1:                                                                      //
// MI1 Measure value assigned to MASS_MI1 parameter,Now the Minimum mass      //
// condition is always overridden in manual mode.Now Device states are        //
// configured for ENABLED, when enabled two sub state STOPPED & RUNNING and   //
// DISABLED. Now Parameters MEASURE_RPM for agitator RPM , MASS_MI1 is for    //
// mass of the  vessel, parameter for set point of manual is SETPOINT_MAN, &  //
// in auto is SETPOINT_AUTO configured.Set point SETPOINT_MAN and             //
// SETPOINT_AUTO initialized to 0.0 and GAIN to 1.0.ALARM_HH, ALARM_H,        //
// ALARM_L, ALARM_LL are added in SIC1 and programmed.Default value added for //
// following parameters.                                                      //
// SL.NO.Parameter NameRange of ValueDefault Value                            //
// 1.MODE=1=Manual                                                            //
// 2.CMND_AUTO=1=disable                                                      //
// 3.CMND_MAN=1=disable                                                       //
// 4.P_SEL=True                                                               //
// 5.I_SEL=True                                                               //
// 6.D_SEL=True                                                               //
// 7.CYCLE=T#1s                                                               //
//----------------------------------------------------------------------------//
FUNCTION_BLOCK "fbSIC1"
TITLE = SIC1 : Agitator speed control
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : REO
NAME : fbSIC1
VERSION : 2.0

//----------------------------------------------------------------------------//
// Declare variables:                                                         //
//----------------------------------------------------------------------------//
VAR_INPUT
    _SETPOINT : Real;        // Agitator speed setpoint
    RAW_INPUT : Int;         // Raw input from the field
    BRK	: Bool;              // Motor breaker fault
    PHR : Bool;              // Three-phase relay alarm
    FLP : Bool;              // Pulse counter fault
    FLT : Bool;              // Inverter fault
    THM : Bool;              // Thermistor module alarm
    MASS_RUN : Real;         // Low mass threshold at which the agitator may run
    MASS_STOP : Real;        // Low low mass threshold at which the agitator must stop
    MI1_MASS : Real;         // Measured Mass
    MI1_DQ : Bool;           // Measured Mass Data Quality
    RANGE_UPPER : Real;      // Upper mass range limit
    RANGE_LOWER : Real;      // Lower mass range limit
    POLARITY : Bool;         // 0- no polarity(0 to z), 1= dual polarity(-x to +y)
    LIMIT_HH : Real;         // High High speed alarm limit
    LIMIT_H : Real;          // High speed alarm limit
    FB_TDELAY : Time := T#20S;
    P_SEL : Bool := TRUE;
    I_SEL : Bool := TRUE;
    D_SEL : Bool := TRUE;
    GAIN : Real := 1.0;
    TI : Time := T#20S;
    TD : Time := T#10S;
    CYCLE : Time := T#1S;    // SAMPLING TIME:The time between the block calls constant
END_VAR

VAR_OUTPUT
    OUT_Q : Bool;            // Inverter Motor Run/Stop Command
END_VAR

VAR_IN_OUT
    _PV : Real;              // Measured Value (after scaling)
    RUNNING : Bool;
    OUT_Q_F : Bool;
    OUT_Q_R : Bool;
    LMN : Real;              // PID controller output (0-100%)
END_VAR

VAR
    mc : "udtModeCommand";   // Block mode and command
    ai : "udtAnalog";        // Analog input structure
    DQ : Bool;
    USER_INPUT : Word;       // Manual mode, equivallent of Analog input, to be entered by Operator
    MAN_PID : Bool;          // Manual non pid selection
    ALM_BRK : Bool;
    ALM_PHR : Bool;
    ALM_FLP : Bool;
    ALM_FLT : Bool;
    ALM_THM : Bool;
    RUN_FAULT : Bool;
    OUT_SETPOINT : Real;     // Setpoint readvalue
    OUT_LMN_PER : Word;      // Inverter speed reference input
    OUT_LMN : Real;          // Inverter Speed reference from PID
    FB_TDELAY : Time := T#20S;
    P_SEL : Bool := TRUE;
    I_SEL : Bool := TRUE;
    D_SEL : Bool := TRUE;
    GAIN : Real := 1.0;
    TI : Time := T#20S;
    TD : Time := T#10S;
    CYCLE : Time := T#1S;    // SAMPLING TIME:The time between the block calls constant
    startTMR {OriginalPartName := 'TON'; LibVersion := '1.0'} : TON;
    dirTMR {OriginalPartName := 'TON'; LibVersion := '1.0'} : TON;
    PID1 {OriginalPartName := 'CONT_C'; LibVersion := '1.0'} : CONT_C;
END_VAR

VAR_TEMP
    ALARM_L : Bool;          // Alarm_L
    ALARM_LL : Bool;         // Alarm_LL
    cmdEnable : Bool;
    cmdDisable : Bool;
    edgeStart : Bool;
    eventStart : Bool;
    eventTMRFwd : Bool;
    eventTMRRev : Bool;
    tDO : Bool;
    tILAnalog : Bool;
    tPV : Real;
    tPV_MASS : Real;
    RET_VAL1 : Word;
    unscaledOUT : Int;
    percentSpeed : Real;
    tSetpoint : Real;
    RANGE_ERROR : Bool;
    BROKEN_WIRE : Bool;
    dirTMRStart : Bool;
    startTMRExpired : Bool;
    dirTMRExpired : Bool;
    tManual_Not_PID : Bool;
    startTMRElapsed : Time;
    dirTMRElapsed : Time;
    permitMass : Bool;
    enable : Bool;
END_VAR

BEGIN
NETWORK
TITLE = Call Mode and Command handling block
    //------------------------------------------------------------------------//
    // COMMAND PROCESSOR   COMMAND PROCESSOR   COMMAND PROCESSOR   COMMAND    //
    //                                                                        //
    // Process the standard block functions for command, mode, interlock and  //
    // state:                                                                 //
    //------------------------------------------------------------------------//
    CALL "fcModeCmd"
    (   mc                   := #mc
    );

NETWORK
TITLE = Enable command
    //------------------------------------------------------------------------//
    // COMMAND   COMMAND   COMMAND   COMMAND   COMMAND   COMMAND   COMMAND    //
    // COMMAND   COMMAND   COMMAND   COMMAND   COMMAND   COMMAND   COMMAND    //
    //                                                                        //
    // CMD is ENABLE:                                                         //
    //------------------------------------------------------------------------//
    A(;
    L #mc.CMD;
    L "dbCONST".BLK.SIC1.CMD.ENABLE;
    ==I;
    );
    =#cmdEnable;

NETWORK
TITLE = Disable command
    //------------------------------------------------------------------------//
    // CMD is DISABLE:                                                        //
    //------------------------------------------------------------------------//
    A(;
    L #mc.CMD;
    L "dbCONST".BLK.SIC1.CMD.DISABLE;
    ==I;
    );
    = #cmdDisable

NETWORK
TITLE = Analog input attributes
    //------------------------------------------------------------------------//
    // Set the analog input attributes:                                       //
    //------------------------------------------------------------------------//
    L #RANGE_LOWER;
    T #ai.RANGE_LOWER;
    L #RANGE_UPPER;
    T #ai.RANGE_UPPER;
    L #LIMIT_HH;
    T #ai.LIMIT_HH;
    L #LIMIT_H;
    T #ai.LIMIT_H;
    L 0.0;
    T #ai.LIMIT_L;
    L 0.0;
    T #ai.LIMIT_LL;
    A "alwaysHigh";
    = #ai.ENABLE_HH;
    A "alwaysHigh";
    = #ai.ENABLE_H;
    A "alwaysLow";
    = #ai.ENABLE_L;
    A "alwaysLow";
    = #ai.ENABLE_LL;
    L #RAW_INPUT;
    T #ai.RAW_INPUT;

NETWORK
TITLE = Call Analog Input handling function
    //------------------------------------------------------------------------//
    // INPUTS   INPUTS   INPUTS   INPUTS   INPUTS   INPUTS   INPUTS   INPUTS  //
    // INPUTS   INPUTS   INPUTS   INPUTS   INPUTS   INPUTS   INPUTS   INPUTS  //
    //                                                                        //
    // Scale the analog input value and check it is healty:                   //
    //------------------------------------------------------------------------//
    CALL "fcAnalog"
    (   ai                   := #ai
    );

NETWORK
TITLE = Motor faults and three phase relay alarm
    //------------------------------------------------------------------------//
    // MOTOR FAULTS                                                           //
    // Raise alarm if any motor control fault condition is active:            //
    //------------------------------------------------------------------------//
    A #PHR;
    = #ALM_PHR;

NETWORK
TITLE = Motor breaker fault
    A #BRK;
    = #ALM_BRK;

NETWORK
TITLE = Pulse counter fault
    A #FLP;
    = #ALM_FLP;

NETWORK
TITLE = Inverter fault
    A #FLT;
    = #ALM_FLT;

NETWORK
TITLE = Thermistor module alarm
    A #THM;
    = #ALM_THM;

NETWORK
TITLE = Aggregate all interlock conditions
    //------------------------------------------------------------------------//
    // Collect all interlock conditions:                                      //
    //------------------------------------------------------------------------//
    O #mc.INTERLOCK;
    O tILAnalog;
    O #BRK;
    O #THM;
    O #FLP;
    O #FLT;
    ON #MI1_DQ;
    = #mc.INTERLOCK;

NETWORK
TITLE = Interlock overrides ENABLE command
    //------------------------------------------------------------------------//
    // Don't allow enable command if any interlock:                           //
    //------------------------------------------------------------------------//
    A #cmdEnable;
    AN #mc.INTERLOCK;
    = #cmdEnable;

NETWORK
TITLE = If not ENABLE then command must be DISABLE
    //------------------------------------------------------------------------//
    // Don't allow enable command if any interlock:                           //
    //------------------------------------------------------------------------//
    AN #cmdEnable;
    = #cmdDisable;

NETWORK
TITLE = Vessel mass
    //------------------------------------------------------------------------//
    // Get the vessel mass from the MI1 CM:                                   //
    //------------------------------------------------------------------------//
    L #MI1_MASS;
    T #tPV_MASS;

NETWORK
TITLE = Permitted to run agitator if mass above minimum value
    //------------------------------------------------------------------------//
    // Permit the agitator to run if mass above minimum start level:          //
    //------------------------------------------------------------------------//
    A(;
    L #tPV_MASS;
    L #MASS_RUN;
    >=R;
    );
    JCN _a;
    S #permitMass;
_a:   NOP 0;

NETWORK
TITLE = Low mass condition must stop the agitator from running
    //------------------------------------------------------------------------//
    // Inhibit the agitator from running if mass below minimum stop level:    //
    //------------------------------------------------------------------------//
    A(;
    L #tPV_MASS;
    L #MASS_STOP;
    <R;
    );
    JCN _b;
    R #permitMass;
_b:   NOP 0;

NETWORK
TITLE = Setpoint if Enabled
    //------------------------------------------------------------------------//
    // Setpoint if ENABLE:                                                    //
    //------------------------------------------------------------------------//
    A #cmdEnable;
    JCN _c;
    L #_SETPOINT;
    T #tSetpoint;
_c:   NOP 0;

NETWORK
TITLE = Setpoint if Disabled
    //------------------------------------------------------------------------//
    // Setpoint should be 0 if disabled:                                      //
    //------------------------------------------------------------------------//
    A #cmdDisable;
    JCN _d;
    L 0;
    T #tSetpoint;
_d:   NOP 0;

NETWORK
TITLE = PID in manual if disabled or manual flag set
    //------------------------------------------------------------------------//
    // PID in manual mode if requested:                                       //
    //------------------------------------------------------------------------//
    O #cmdDisable;
    O(;
    A #cmdEnable;
    A #mc.modeMANUAL;
    A #MAN_PID;
    );
    = #tManual_Not_PID;

NETWORK
TITLE = Disable command
    //------------------------------------------------------------------------//
    // OUTPUTS   OUTPUTS   OUTPUTS   OUTPUTS   OUTPUTS   OUTPUTS   OUTPUTS    //
    // OUTPUTS   OUTPUTS   OUTPUTS   OUTPUTS   OUTPUTS   OUTPUTS   OUTPUTS    //
    //                                                                        //
    // DISABLE command if not enabled or any interlock:                       //
    //------------------------------------------------------------------------//
    A #cmdDisable;
    JCN _e;
    L "dbCONST".BLK.SIC1.CMD.DISABLE;
    T #mc.CMD;
_e:   NOP 0;

NETWORK
TITLE = Flag output should be on if command is ENABLE and mass is enough
    //------------------------------------------------------------------------//
    // Flag output to be set on if command is enable and no interlock and     //
    // mass in the vessel is high enough to permit agiator operation:         //
    //------------------------------------------------------------------------//
    A #cmdEnable;
    A #permitMass;
    AN #mc.modeOOS;
    = #tDO;

NETWORK
TITLE = Drive the agitator output on if commanded and safe to run
    //------------------------------------------------------------------------//
    // Start the agitator if allowed to run if command is ENABLE and there    //
    // are no interlocks and mass in the vessel is sufficient:                //
    //------------------------------------------------------------------------//
    A #tDO;
    = #OUT_Q;

NETWORK
TITLE = Transfer the setpoint to the inverter reference value
    //------------------------------------------------------------------------//
    // Start the agitator if allowed to run if command is ENABLE and there    //
    // are no interlocks and mass in the vessel is sufficient:                //
    //------------------------------------------------------------------------//
    A #tDO;
    JCN _f;
    L #tSetpoint;
    T #OUT_LMN;
_f:   NOP 0;

NETWORK
TITLE = Transfer the setpoint to the output setpoint
    //------------------------------------------------------------------------//
    // Transfer setpoint to output setpoint:                                  //
    //------------------------------------------------------------------------//
    L #tSetpoint;
    T #OUT_SETPOINT;

NETWORK
TITLE = Unscale Setpoint
    //------------------------------------------------------------------------//
    // Unscale the setpoint to set the inverter percent reference value:      //
    //------------------------------------------------------------------------//
    A #tDO;
    JCN _g;
    CALL UNSCALE
    (   IN                   := #tSetpoint ,
        HI_LIM               := #ai.RANGE_UPPER ,
        LO_LIM               := #ai.RANGE_LOWER ,
        BIPOLAR              := 0 ,
        RET_VAL              := #RET_VAL1 ,
        OUT                  := #unscaledOUT
    );
_g:   NOP 0;

NETWORK
TITLE = Setpoint reference to inverter in percent
    //------------------------------------------------------------------------//
    // Set the inverter percent reference value if running:                   //
    //------------------------------------------------------------------------//
    A #tDO;
    JCN _h;
    L #unscaledOUT;
    T #OUT_LMN_PER;
_h:   NOP 0;

NETWORK
TITLE = PID Controller
    //------------------------------------------------------------------------//
    // PID algorithm if enabled in AUTO mode:                                 //
    //------------------------------------------------------------------------//
    CALL #PID1
    (   COM_RST              := "flagFirstScanRestart" ,
        MAN_ON               := #tManual_Not_PID ,
        P_SEL                := #P_SEL ,
        I_SEL                := #I_SEL ,
        D_SEL                := #D_SEL ,
        CYCLE                := #CYCLE ,
        SP_INT               := #tSetpoint ,
        PV_IN                := #_PV ,
        MAN                  := #tSetpoint ,
        GAIN                 := #GAIN ,
        TI                   := #TI ,
        TD                   := #TD ,
        LMN_HLM              := 100.0 ,
        LMN_LLM              := 0.0 ,
        LMN                  := #LMN
    );

NETWORK
TITLE = Output if Disabled
    //------------------------------------------------------------------------//
    // Output should be 0 if disabled:                                        //
    //------------------------------------------------------------------------//
    A #cmdDisable;
    JCN _i;
    L 0.0;
    T #LMN;
_i:   NOP 0;

NETWORK
TITLE = Start event if commanded to start
    //------------------------------------------------------------------------//
    // Flag start event if just commanded to start:                           //
    //------------------------------------------------------------------------//
    A #tDO;
    FP #edgeStart;
    = #eventStart;

NETWORK
TITLE = Start timer to check if fail to start or run at low speed
    //------------------------------------------------------------------------//
    // Start timer if commanded to run:                                       //
    //------------------------------------------------------------------------//
    A #eventStart;
    JCN _j;
    CALL #startTMR
    {time_type := 'Time'}
    (   IN                   := #tDO ,
        PT                   := #FB_TDELAY ,
        Q                    := #startTMRExpired ,
        ET                   := #startTMRElapsed
    );
_j:   NOP 0;

NETWORK
TITLE = Fault if start timer expired and not running
    //------------------------------------------------------------------------//
    // Fault if start timer expired and still not running:                    //
    //------------------------------------------------------------------------//
    A #startTMR.Q;
    AN #RUNNING;
    AN #mc.modeOOS;
    = #RUN_FAULT;

NETWORK
TITLE = Calculate speed as a fraction of the setpoint
    //------------------------------------------------------------------------//
    // Calculate actual speed as a fraction of setpoint:                      //
    //------------------------------------------------------------------------//
    A #tDO;
    JCN _k;
    L #tPV;
    L #tSetpoint;
    /R;
    T #percentSpeed;
_k:   NOP 0;

NETWORK
TITLE = Calculate speed as a percent of the setpoint
    //------------------------------------------------------------------------//
    // Calculate actual speed as a percent of setpoint:                       //
    //------------------------------------------------------------------------//
    A #tDO;
    JCN _l;
    L #percentSpeed;
    L 100.0;
    *R;
    T #percentSpeed;
_l:   NOP 0;

NETWORK
TITLE = Flag RUNNING if speed above 25% of setpoint
    //------------------------------------------------------------------------//
    // Flag RUNNING if actual speed is above 25% of setpoint:                 //
    //------------------------------------------------------------------------//
    A #tDO;
    L #percentSpeed;
    L 25.0;
    >R;
    = #RUNNING;

NETWORK
TITLE = Run Direction Forward if just started
    //------------------------------------------------------------------------//
    // Direction is forward if command to start raised:                       //
    //------------------------------------------------------------------------//
    A #eventStart;
    = #OUT_Q_F;

NETWORK
TITLE = Check run command and direction timer expired
    //------------------------------------------------------------------------//
    // Check if run command output is on and direction change timer expired:  //
    //------------------------------------------------------------------------//
    A #tDO;
    AN #dirTMR.Q;
    = #dirTMRStart;

NETWORK
TITLE = Start Forward Reverse Direction Timer
    //------------------------------------------------------------------------//
    // If running and direction changed, start timer to reverse again:        //
    //------------------------------------------------------------------------//
    CALL #dirTMR
    {time_type := 'Time'}
    (   IN                   := #dirTMRStart ,
        PT                   := T#5M ,
        Q                    := #dirTMRExpired ,
        ET                   := #dirTMRElapsed
    );
    NOP 0;

NETWORK
TITLE = Reverse direction if timer expired
    //------------------------------------------------------------------------//
    // Change direction if timer expired:                                     //
    //------------------------------------------------------------------------//
    A #dirTMR.Q;
    A #OUT_Q_F;
    = #eventTMRRev;

    A #eventTMRRev;
    JCN _m;
    R #OUT_Q_F;
_m:   NOP 0;

    A #eventTMRRev;
    JCN _n;
    S #OUT_Q_R;
_n:   NOP 0;

    A #dirTMR.Q;
    A #OUT_Q_R;
    = #eventTMRFwd;

    A #eventTMRFwd;
    JCN _o;
    S #OUT_Q_F;
_o:   NOP 0;

    A #eventTMRFwd;
    JCN _p;
    R #OUT_Q_R;
_p:   NOP 0;
NETWORK

TITLE = Disable state
    //------------------------------------------------------------------------//
    // STATE   STATE   STATE   STATE   STATE   STATE   STATE   STATE   STATE  //
    // STATE   STATE   STATE   STATE   STATE   STATE   STATE   STATE   STATE  //
    //                                                                        //
    // DISABLED if command is disable or any interlock and not motor fault:   //
    //------------------------------------------------------------------------//
    AN #BRK;
    AN #THM;
    AN #FLP;
    AN #FLT;
    A #cmdDisable;
    JCN _q;
    L "dbCONST".BLK.SIC1.STATE.DISABLED;
    T #mc.STATE;
_q:   NOP 0;

NETWORK
TITLE = FAULT if any fault condition active
    //------------------------------------------------------------------------//
    // FAULT if any motor fault condition is active:                          //
    //------------------------------------------------------------------------//
    O #BRK;
    O #THM;
    O #FLP;
    O #FLT;
    JCN _r;
    L "dbCONST".BLK.SIC1.STATE.FAULT;
    T #mc.STATE;
_r:   NOP 0;

NETWORK
TITLE = Stopped if command is ENABLE and mass not enough
    //------------------------------------------------------------------------//
    // STOPPED if command is enable and no interlock but mass not enough:     //
    //------------------------------------------------------------------------//
    A #cmdEnable;
    AN #permitMass;
    JCN _s;
    L "dbCONST".BLK.SIC1.STATE.STOPPED;
    T #mc.STATE;
_s:   NOP 0;

NETWORK
TITLE = Running if output should be on
    //------------------------------------------------------------------------//
    // RUNNING if command is enable and no interlock and mass permits:        //
    //------------------------------------------------------------------------//
    A #tDO;
    JCN _t;
    L "dbCONST".BLK.SIC1.STATE.RUNNING;
    T #mc.STATE;
_t:   NOP 0;
END_FUNCTION_BLOCK
