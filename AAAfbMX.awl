FUNCTION_BLOCK "fbMX"
TITLE = Manufacturing Vessel and associated equipment
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : REO
NAME : fbMX
VERSION : 2.0
//----------------------------------------------------------------------------//
//            Copyright 2018 Rieckermann Engineering Operations               //
//                Automatically Generated File - Do Not Edit                  //
//----------------------------------------------------------------------------//
// Title:       MX
// Description: Manufacturing Vessel and associated equipment
//                                                                            //
// This is the main function block for all higher level S88 blocks, including //
// EMs, Units and Process Cells. The block is generic and any heirarchical    //
// structure can be supported.                                                //
//----------------------------------------------------------------------------//
// Revision history:                                                          //
// Rev By               Date        CC        Note                            //
// 2.0 David Paspa      30-Jan-2018 NA        Reboot for S7-1500.             //
// 1.0 Gerald Kontriner 10-Oct-2009 CC-09/023 Added Alarm flag MON_MISMATCH.  //
// 0.9 Khairul Basar    04-Oct-2009 CC-09/023 SHARED_BY  changed to OWNER int.//
// 0.8 Khairul Basar    02-Oct-2009 CC-09/023 SQ_STATE, ERR flag reset if SQ  //
//                                            off.                            //
// 0.7 Khoon            01-Oct-2009 CC-09/016 Mode=2 init,'Substate change'   //
//                                            added to STOP input of Subs.    //
// 0.6 Khairul Basar    30-Sep-2009 CC-09/023 EM Mode var changed to IN_OUT.  //
// 0.5 Khairul Basar    25-Sep-2009 CC-09/016 Ref2.                           //
// 0.4 Khairul Basar    21-Sep-2009 CC-09/016 Ref1.                           //
// 0.3 Khairul Basar    17-Sep-2009 CC-09/016 Duplicate command/SP parameters //
//                                            deleted auto/manual both now    //
//                                            using same parameters.          //
// 0.2 Khairul Basar    27-Aug-2009 CC-09/023 Path_IL added, Phase updated.   //
// 0.1 Khairul Basar    03-Aug-2009           Initial design.                 //
// Ref2:                                                                      //
// SQ_ACK,SQ_RESUME,SQ_ERROR,CURSTEP,SQ_STATE variables are added as to       //
// control from HMI faceplate.                                                //
// Ref1:                                                                      //
// Phases are updated.Flush & Charge Syncronised for valve commands.SQ_stop   //
// command is passed when CALL flag is OFF(previously there was error).PULSE  //
// timer is created as multiple instance of a standard FB, no more hard coded //
// S5 timer. ERR_FLT is changed to TIMEOUT_VER, PATH_IL to FLOWPATH.Shared    //
// Equipment availability flag programmed,BatchCycle variable added.          //
//----------------------------------------------------------------------------//
//----------------------------------------------------------------------------//
// Declare interface and variables:                                           //
//----------------------------------------------------------------------------//
   VAR 
      p : "udtMX";   // Block data interface
      RUNTMR : "fbRunTimer";
      UO_MX_CIP : "fbUO_MX_CIP";   // CIP of Mx
      UO_MX_FILL : "fbUO_MX_FILL";   // Filling Operation from Mx to FLz
      UO_MX_FILTER : "fbUO_MX_FILTER";   // Filtration Operation from Mx to Sy
      UO_MX_MAKE : "fbUO_MX_MAKE";   // Make Operation of Mx
      UO_MX_SETUP : "fbUO_MX_SETUP";   // Setup of Mx
      UO_MX_SIP : "fbUO_MX_SIP";   // SIP of Mx
      timeCheckChildState {OriginalPartName := 'IEC_TIMER'; LibVersion := '1.0'} : TON_TIME;
      timeCheckChildStateElapsed : Time;
      timeCheckChildStateExpired : Bool;
      cmdSTOPPED : Bool;
      stateBeforeError : Int;
      childReqCMD : Struct
         EMA_VESSEL : Int;
         EMC_GAS : Int;
         EMC_WATER : Int;
         EMG_FILTER : Int;
         EMM_VESSEL : Int;
         EMT_HEX : Int;
         EMV_INLET : Int;
         EMV_VESSEL : Int;
         EMX_DRAIN : Int;
         EMX_FILL1 : Int;
         EMX_FILL2 : Int;
         EMX_MMFL : Int;
         EMX_SMFL : Int;
         EMX_SMFLDRN : Int;
         EMX_TRANSFER1 : Int;
         EMX_TRANSFER2 : Int;
      END_STRUCT;
      flags : Struct
         childInterlock : Bool;
         childFailed : Bool;
         childMismatch : Bool;
         childUnavailable : Bool;
         sfcAborted : Bool;
         sfcCompleted : Bool;
         substateCompleted : Bool;
      END_STRUCT;
      acquire : Struct
         EMA_VESSEL : Bool;   // EMA_VESSEL
         EMC_GAS : Bool;   // EMC_GAS
         EMC_WATER : Bool;   // EMC_WATER
         EMG_FILTER : Bool;   // EMG_FILTER
         EMM_VESSEL : Bool;   // EMM_VESSEL
         EMT_HEX : Bool;   // EMT_HEX
         EMV_INLET : Bool;   // EMV_INLET
         EMV_VESSEL : Bool;   // EMV_VESSEL
         EMX_DRAIN : Bool;   // EMX_DRAIN
         EMX_MMFL : Bool;   // EMX_MMFL
         EMX_SMFL : Bool;   // EMX_SMFL
         EMX_SMFLDRN : Bool;   // EMX_SMFLDRN
         EMX_FILL1 : Bool;   // EMX_FILL1
         EMX_FILL2 : Bool;   // EMX_FILL2
         EMX_TRANSFER1 : Bool;   // EMX_TRANSFER1
         EMX_TRANSFER2 : Bool;   // EMX_TRANSFER2
         VS_VACUUM1 : Bool;   // VS_VACUUM1
         DI_ASL : Bool;   // DI_ASL
         DI_ESTOP : Bool;   // DI_ESTOP
         DI_ESTOP_AUX1 : Bool;   // DI_ESTOP_AUX1
         DI_ESTOP_AUX2 : Bool;   // DI_ESTOP_AUX2
         DI_ESTOP_AUX3 : Bool;   // DI_ESTOP_AUX3
         DI_RELAY : Bool;   // DI_RELAY
      END_STRUCT;
      alreadyOwned : Struct
         EMA_VESSEL : Bool;   // EMA_VESSEL
         EMC_GAS : Bool;   // EMC_GAS
         EMC_WATER : Bool;   // EMC_WATER
         EMG_FILTER : Bool;   // EMG_FILTER
         EMM_VESSEL : Bool;   // EMM_VESSEL
         EMT_HEX : Bool;   // EMT_HEX
         EMV_INLET : Bool;   // EMV_INLET
         EMV_VESSEL : Bool;   // EMV_VESSEL
         EMX_DRAIN : Bool;   // EMX_DRAIN
         EMX_MMFL : Bool;   // EMX_MMFL
         EMX_SMFL : Bool;   // EMX_SMFL
         EMX_SMFLDRN : Bool;   // EMX_SMFLDRN
         EMX_FILL1 : Bool;   // EMX_FILL1
         EMX_FILL2 : Bool;   // EMX_FILL2
         EMX_TRANSFER1 : Bool;   // EMX_TRANSFER1
         EMX_TRANSFER2 : Bool;   // EMX_TRANSFER2
         VS_VACUUM1 : Bool;   // VS_VACUUM1
         DI_ASL : Bool;   // DI_ASL
         DI_ESTOP : Bool;   // DI_ESTOP
         DI_ESTOP_AUX1 : Bool;   // DI_ESTOP_AUX1
         DI_ESTOP_AUX2 : Bool;   // DI_ESTOP_AUX2
         DI_ESTOP_AUX3 : Bool;   // DI_ESTOP_AUX3
         DI_RELAY : Bool;   // DI_RELAY
      END_STRUCT;
      selected_FILL_FLZ : Struct
         FL1 : Bool;
         FL2 : Bool;
         NONE : Bool;
      END_STRUCT;
      selected_VESSEL_MX : Struct
         M1 : Bool;
         M2 : Bool;
         NONE : Bool;
      END_STRUCT;
      selected_VESSEL_SY : Struct
         NONE : Bool;
         S1 : Bool;
         S2 : Bool;
      END_STRUCT;
      subsHasSFC : Struct
         CIP : Bool := TRUE;   // CIP of Mx
         FILL : Bool := TRUE;   // Filling Operation from Mx to FLz
         FILTER : Bool := TRUE;   // Filtration Operation from Mx to Sy
         MAKE : Bool := TRUE;   // Make Operation of Mx
         SETUP : Bool := TRUE;   // Setup of Mx
         SIP : Bool := TRUE;   // SIP of Mx
      END_STRUCT;
      subsRunning : Struct
         CIP : Bool;   // CIP of Mx
         FILL : Bool;   // Filling Operation from Mx to FLz
         FILTER : Bool;   // Filtration Operation from Mx to Sy
         MAKE : Bool;   // Make Operation of Mx
         SETUP : Bool;   // Setup of Mx
         SIP : Bool;   // SIP of Mx
      END_STRUCT;
      subsStart : Struct
         CIP : Bool;   // CIP of Mx
         FILL : Bool;   // Filling Operation from Mx to FLz
         FILTER : Bool;   // Filtration Operation from Mx to Sy
         MAKE : Bool;   // Make Operation of Mx
         SETUP : Bool;   // Setup of Mx
         SIP : Bool;   // SIP of Mx
      END_STRUCT;
   END_VAR
   VAR DB_SPECIFIC
      w { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;
      b { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} AT w : Array[0..15] of Bool;
      wEventConfirmNo { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..0] of Word;
      bEventConfirmNo { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} AT wEventConfirmNo : Array[0..2] of Bool;
      wEventConfirmYes { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..0] of Word;
      bEventConfirmYes { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} AT wEventConfirmYes : Array[0..11] of Bool;
      wEventLogMsg { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..3] of Word;
      bEventLogMsg { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} AT wEventLogMsg : Array[0..48] of Bool;
      wEventLogReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..0] of Word;
      bEventLogReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} AT wEventLogReal : Array[0..12] of Bool;
      wEventLogTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..0] of Word;
      bEventLogTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} AT wEventLogTime : Array[0..7] of Bool;
   END_VAR

   VAR_TEMP 
      sq_finished : Bool;
      returnValue : Int;
      dummy : Bool;
   END_VAR


BEGIN
NETWORK
TITLE = Safe Command as STOPPED on restart
//------------------------------------------------------------------------//
// Set the safe command if restarting the PLC:                            //
//------------------------------------------------------------------------//
      A "flagFirstScanRestart";
      JCN _noRestart;
      L "dbCONST".BLK.SAFE.CMD;
      T #p.write.mc.CMD;
      T #p.read.mc.CMD_SAFE;
      R #subsRunning.CIP;
      R #subsRunning.FILL;
      R #subsRunning.FILTER;
      R #subsRunning.MAKE;
      R #subsRunning.SETUP;
      R #subsRunning.SIP;

_noRestart:      NOP 0;

NETWORK
TITLE = Shutdown if STOPPED command no matter what
//------------------------------------------------------------------------//
// Check for STOPPED comamnd:                                             //
//------------------------------------------------------------------------//
      A(;
      L #p.write.mc.CMD;
      L "dbCONST".BLK.CMD.STOP;
      ==I;
      );
      = #cmdSTOPPED;

NETWORK
TITLE = Check if any shared Child is not Owned or not Available
//------------------------------------------------------------------------//
// CHILD UNAVAILABLE   CHILD UNAVAILABLE   CHILD UNAVAILABLE   CHILD UNAV //
//                                                                        //
// Check any shared child devices are Available. If Available they will   //
// be acquired if needed later to execute a command:                      //
//------------------------------------------------------------------------//
      O(;
      A #selected_FILL_FLZ.FL1;
      AN "idbEMX5".f[#p.child.EMX_FILL1].p.read.mc.isAvailable;
      AN(;
      L "idbEMX5".f[#p.child.EMX_FILL1].p.write.mc.OWNER;
      L #p.read.mc.ME;
      ==I;
      );
      );
      O(;
      A #selected_FILL_FLZ.FL2;
      AN "idbEMX5".f[#p.child.EMX_FILL2].p.read.mc.isAvailable;
      AN(;
      L "idbEMX5".f[#p.child.EMX_FILL2].p.write.mc.OWNER;
      L #p.read.mc.ME;
      ==I;
      );
      );
      O(;
      O #selected_FILL_FLZ.FL1;
      O #selected_FILL_FLZ.FL2;
      O #selected_VESSEL_SY.S1;
      O #selected_VESSEL_SY.S2;
      AN "idbEMX6".f[#p.child.EMX_SMFL].p.read.mc.isAvailable;
      AN(;
      L "idbEMX6".f[#p.child.EMX_SMFL].p.write.mc.OWNER;
      L #p.read.mc.ME;
      ==I;
      );
      );
      O(;
      O #selected_FILL_FLZ.FL1;
      O #selected_FILL_FLZ.FL2;
      O #selected_VESSEL_SY.S1;
      O #selected_VESSEL_SY.S2;
      AN "idbEMX4".f[#p.child.EMX_SMFLDRN].p.read.mc.isAvailable;
      AN(;
      L "idbEMX4".f[#p.child.EMX_SMFLDRN].p.write.mc.OWNER;
      L #p.read.mc.ME;
      ==I;
      );
      );
      O(;
      A #selected_VESSEL_SY.S1;
      AN "idbEMX2".f[#p.child.EMX_TRANSFER1].p.read.mc.isAvailable;
      AN(;
      L "idbEMX2".f[#p.child.EMX_TRANSFER1].p.write.mc.OWNER;
      L #p.read.mc.ME;
      ==I;
      );
      );
      O(;
      A #selected_VESSEL_SY.S2;
      AN "idbEMX2".f[#p.child.EMX_TRANSFER2].p.read.mc.isAvailable;
      AN(;
      L "idbEMX2".f[#p.child.EMX_TRANSFER2].p.write.mc.OWNER;
      L #p.read.mc.ME;
      ==I;
      );
      );
      = #flags.childUnavailable;

NETWORK
TITLE = Check if any Child has Failed
//------------------------------------------------------------------------//
// CHILD FAILED   CHILD FAILED   CHILD FAILED   CHILD FAILED   CHILD FAIL //
//                                                                        //
// Check if any child cannot be controlled by this parent block in which  //
// case this block will fail and so operation at this level should be     //
// inhibited:                                                             //
//------------------------------------------------------------------------//
      O #flags.childInterlock;
      O #flags.childUnavailable;
      O #timeCheckChildStateExpired;
      JCN _noChildFail;
      S #flags.childFailed;
_noChildFail:      NOP 0;

NETWORK
TITLE = Check if Child Failed condition cleard
//------------------------------------------------------------------------//
// Child fail condition cleared if all children match:                    //
//------------------------------------------------------------------------//
      AN #flags.childInterlock;
      AN #flags.childUnavailable;
      AN #flags.childMismatch;
      JCN _childFailCleared;
      R #flags.childFailed;
_childFailCleared:      NOP 0;

NETWORK
TITLE = Call General Mode and Command handling block
//------------------------------------------------------------------------//
// COMMAND PROCESSOR   COMMAND PROCESSOR   COMMAND PROCESSOR   COMMAND    //
//                                                                        //
// Process the standard block functions for command, mode, interlock and  //
// state:                                                                 //
//------------------------------------------------------------------------//

      CALL "fcModeCmd"
      (  mcRead                      := #p.read.mc , 
         mcWrite                     := #p.write.mc
      );

NETWORK
TITLE = Set Start command permitted flag if all okay
//------------------------------------------------------------------------//
// PERMIT START   PERMIT START   PERMIT START   PERMIT START   PERMIT ST  //
//                                                                        //
// If no interlock and all calling parameters and child devices are okay  //
// then a Start is permitted:                                             //
//------------------------------------------------------------------------//
      AN #p.read.mc.INTERLOCK;
      AN #flags.childFailed;
      = #p.read.bmc.permitStart;

NETWORK
TITLE = Operator Attention Flag
//------------------------------------------------------------------------//
// If not in Auto or any interlock or inhibit condition then the block    //
// needs operator attention:                                              //
//------------------------------------------------------------------------//
      O #p.read.mc.needAttention;
      ON #p.read.bmc.permitStart;
      = #p.read.mc.needAttention;

NETWORK
TITLE = Call BLOCK Mode and Command handling block
//------------------------------------------------------------------------//
// Process the stackable block functions for mode and command change      //
// events:                                                                //
//------------------------------------------------------------------------//

      CALL "fcModeCmdBLK"
      (  mcRead                      := #p.read.mc , 
         mcWrite                     := #p.write.mc , 
         bmc                         := #p.read.bmc
      );

NETWORK
TITLE = Set child devices to safe state if stopped command or SFC pause
//------------------------------------------------------------------------//
// SAFE STATE   SAFE STATE   SAFE STATE   SAFE STATE  SAFE STATE  SAFE ST //
//                                                                        //
// Set the child device to the safe state on stop or pause command:       //
//------------------------------------------------------------------------//
      O #cmdSTOPPED;
      O(;
      A #subsRunning.CIP;
      A #UO_MX_CIP.smc.ERR_FAULT;
      A #subsRunning.FILL;
      A #UO_MX_FILL.smc.ERR_FAULT;
      A #subsRunning.FILTER;
      A #UO_MX_FILTER.smc.ERR_FAULT;
      A #subsRunning.MAKE;
      A #UO_MX_MAKE.smc.ERR_FAULT;
      A #subsRunning.SETUP;
      A #UO_MX_SETUP.smc.ERR_FAULT;
      A #subsRunning.SIP;
      A #UO_MX_SIP.smc.ERR_FAULT;
      );
      = #p.read.err.childSafeState;
      JCN _notChildSafe;

  //------------------------------------------------------------------------//
  // Set all child devices to safe state due to block stop or problem:      //
  //------------------------------------------------------------------------//
      A "alwaysHigh";
      A "idbEMA1".f[#p.child.EMA_VESSEL].p.read.mc.modeAUTO;
      JCN _blkSafe_EMA_VESSEL;
      L "idbEMA1".f[#p.child.EMA_VESSEL].p.read.mc.CMD_SAFE;
      T "idbEMA1".f[#p.child.EMA_VESSEL].p.write.mc.CMD;
      T #childReqCMD.EMA_VESSEL;
_blkSafe_EMA_VESSEL:      NOP 0;
      A "alwaysHigh";
      A "idbEMC1".f[#p.child.EMC_GAS].p.read.mc.modeAUTO;
      JCN _blkSafe_EMC_GAS;
      L "idbEMC1".f[#p.child.EMC_GAS].p.read.mc.CMD_SAFE;
      T "idbEMC1".f[#p.child.EMC_GAS].p.write.mc.CMD;
      T #childReqCMD.EMC_GAS;
_blkSafe_EMC_GAS:      NOP 0;
      A "alwaysHigh";
      A "idbEMC2".f[#p.child.EMC_WATER].p.read.mc.modeAUTO;
      JCN _blkSafe_EMC_WATER;
      L "idbEMC2".f[#p.child.EMC_WATER].p.read.mc.CMD_SAFE;
      T "idbEMC2".f[#p.child.EMC_WATER].p.write.mc.CMD;
      T #childReqCMD.EMC_WATER;
_blkSafe_EMC_WATER:      NOP 0;
      A "alwaysHigh";
      A "idbEMG1".f[#p.child.EMG_FILTER].p.read.mc.modeAUTO;
      JCN _blkSafe_EMG_FILTER;
      L "idbEMG1".f[#p.child.EMG_FILTER].p.read.mc.CMD_SAFE;
      T "idbEMG1".f[#p.child.EMG_FILTER].p.write.mc.CMD;
      T #childReqCMD.EMG_FILTER;
_blkSafe_EMG_FILTER:      NOP 0;
      A "alwaysHigh";
      A "idbEMM1".f[#p.child.EMM_VESSEL].p.read.mc.modeAUTO;
      JCN _blkSafe_EMM_VESSEL;
      L "idbEMM1".f[#p.child.EMM_VESSEL].p.read.mc.CMD_SAFE;
      T "idbEMM1".f[#p.child.EMM_VESSEL].p.write.mc.CMD;
      T #childReqCMD.EMM_VESSEL;
_blkSafe_EMM_VESSEL:      NOP 0;
      A "alwaysHigh";
      A "idbEMT1".f[#p.child.EMT_HEX].p.read.mc.modeAUTO;
      JCN _blkSafe_EMT_HEX;
      L "idbEMT1".f[#p.child.EMT_HEX].p.read.mc.CMD_SAFE;
      T "idbEMT1".f[#p.child.EMT_HEX].p.write.mc.CMD;
      T #childReqCMD.EMT_HEX;
_blkSafe_EMT_HEX:      NOP 0;
      A "alwaysHigh";
      A "idbEMV2".f[#p.child.EMV_INLET].p.read.mc.modeAUTO;
      JCN _blkSafe_EMV_INLET;
      L "idbEMV2".f[#p.child.EMV_INLET].p.read.mc.CMD_SAFE;
      T "idbEMV2".f[#p.child.EMV_INLET].p.write.mc.CMD;
      T #childReqCMD.EMV_INLET;
_blkSafe_EMV_INLET:      NOP 0;
      A "alwaysHigh";
      A "idbEMV1".f[#p.child.EMV_VESSEL].p.read.mc.modeAUTO;
      JCN _blkSafe_EMV_VESSEL;
      L "idbEMV1".f[#p.child.EMV_VESSEL].p.read.mc.CMD_SAFE;
      T "idbEMV1".f[#p.child.EMV_VESSEL].p.write.mc.CMD;
      T #childReqCMD.EMV_VESSEL;
_blkSafe_EMV_VESSEL:      NOP 0;
      A "alwaysHigh";
      A "idbEMX4".f[#p.child.EMX_DRAIN].p.read.mc.modeAUTO;
      JCN _blkSafe_EMX_DRAIN;
      L "idbEMX4".f[#p.child.EMX_DRAIN].p.read.mc.CMD_SAFE;
      T "idbEMX4".f[#p.child.EMX_DRAIN].p.write.mc.CMD;
      T #childReqCMD.EMX_DRAIN;
_blkSafe_EMX_DRAIN:      NOP 0;
      A #selected_FILL_FLZ.FL1;
      A "idbEMX5".f[#p.child.EMX_FILL1].p.read.mc.modeAUTO;
      JCN _blkSafe_EMX_FILL1;
      L "idbEMX5".f[#p.child.EMX_FILL1].p.read.mc.CMD_SAFE;
      T "idbEMX5".f[#p.child.EMX_FILL1].p.write.mc.CMD;
      T #childReqCMD.EMX_FILL1;
_blkSafe_EMX_FILL1:      NOP 0;
      A #selected_FILL_FLZ.FL2;
      A "idbEMX5".f[#p.child.EMX_FILL2].p.read.mc.modeAUTO;
      JCN _blkSafe_EMX_FILL2;
      L "idbEMX5".f[#p.child.EMX_FILL2].p.read.mc.CMD_SAFE;
      T "idbEMX5".f[#p.child.EMX_FILL2].p.write.mc.CMD;
      T #childReqCMD.EMX_FILL2;
_blkSafe_EMX_FILL2:      NOP 0;
      A "alwaysHigh";
      A "idbEMX1".f[#p.child.EMX_MMFL].p.read.mc.modeAUTO;
      JCN _blkSafe_EMX_MMFL;
      L "idbEMX1".f[#p.child.EMX_MMFL].p.read.mc.CMD_SAFE;
      T "idbEMX1".f[#p.child.EMX_MMFL].p.write.mc.CMD;
      T #childReqCMD.EMX_MMFL;
_blkSafe_EMX_MMFL:      NOP 0;
      O #selected_FILL_FLZ.FL1;
      O #selected_FILL_FLZ.FL2;
      O #selected_VESSEL_SY.S1;
      O #selected_VESSEL_SY.S2;
      A "idbEMX6".f[#p.child.EMX_SMFL].p.read.mc.modeAUTO;
      JCN _blkSafe_EMX_SMFL;
      L "idbEMX6".f[#p.child.EMX_SMFL].p.read.mc.CMD_SAFE;
      T "idbEMX6".f[#p.child.EMX_SMFL].p.write.mc.CMD;
      T #childReqCMD.EMX_SMFL;
_blkSafe_EMX_SMFL:      NOP 0;
      O #selected_FILL_FLZ.FL1;
      O #selected_FILL_FLZ.FL2;
      O #selected_VESSEL_SY.S1;
      O #selected_VESSEL_SY.S2;
      A "idbEMX4".f[#p.child.EMX_SMFLDRN].p.read.mc.modeAUTO;
      JCN _blkSafe_EMX_SMFLDRN;
      L "idbEMX4".f[#p.child.EMX_SMFLDRN].p.read.mc.CMD_SAFE;
      T "idbEMX4".f[#p.child.EMX_SMFLDRN].p.write.mc.CMD;
      T #childReqCMD.EMX_SMFLDRN;
_blkSafe_EMX_SMFLDRN:      NOP 0;
      A #selected_VESSEL_SY.S1;
      A "idbEMX2".f[#p.child.EMX_TRANSFER1].p.read.mc.modeAUTO;
      JCN _blkSafe_EMX_TRANSFER1;
      L "idbEMX2".f[#p.child.EMX_TRANSFER1].p.read.mc.CMD_SAFE;
      T "idbEMX2".f[#p.child.EMX_TRANSFER1].p.write.mc.CMD;
      T #childReqCMD.EMX_TRANSFER1;
_blkSafe_EMX_TRANSFER1:      NOP 0;
      A #selected_VESSEL_SY.S2;
      A "idbEMX2".f[#p.child.EMX_TRANSFER2].p.read.mc.modeAUTO;
      JCN _blkSafe_EMX_TRANSFER2;
      L "idbEMX2".f[#p.child.EMX_TRANSFER2].p.read.mc.CMD_SAFE;
      T "idbEMX2".f[#p.child.EMX_TRANSFER2].p.write.mc.CMD;
      T #childReqCMD.EMX_TRANSFER2;
_blkSafe_EMX_TRANSFER2:      NOP 0;

_notChildSafe:      NOP 0;

NETWORK
TITLE = All SQ are in Auto mode when EM in Auto
//------------------------------------------------------------------------//
// SFC AUTO   SFC AUTO   SFC AUTO   SFC AUTO   SFC AUTO   SFC AUTO   SFC  //
//                                                                        //
// Set all SFCs to AUTO mode if the block is in AUTO:                     //
//------------------------------------------------------------------------//
      A #p.read.bmc.eventModeAuto;
      JCN _nomcAuto;
      L #p.write.mc.MODE;
      T #UO_MX_CIP.smc.MODE;
      T #UO_MX_FILL.smc.MODE;
      T #UO_MX_FILTER.smc.MODE;
      T #UO_MX_MAKE.smc.MODE;
      T #UO_MX_SETUP.smc.MODE;
      T #UO_MX_SIP.smc.MODE;
_nomcAuto:      NOP 0;

NETWORK
TITLE = Cascade Auto or OOS Mode to children
//------------------------------------------------------------------------//
// MODE CASCADE   MODE CASCADE   MODE CASCADE   MODE CASCADE   MODE CASC  //
//                                                                        //
// Switch child mode to Auto or OOS when parent mode transitions:         //
//------------------------------------------------------------------------//
      A(;
      O #p.read.bmc.eventModeAuto;
      O #p.read.bmc.eventModeOOS;
      );
      JCN _nomcAutoOOS;

      A "alwaysHigh";
      JCN _cascMode1;
      L #p.write.mc.MODE;
      T "idbEMA1".f[#p.child.EMA_VESSEL].p.write.mc.MODE;
_cascMode1:      NOP 0;

      A "alwaysHigh";
      JCN _cascMode2;
      L #p.write.mc.MODE;
      T "idbEMC1".f[#p.child.EMC_GAS].p.write.mc.MODE;
_cascMode2:      NOP 0;

      A "alwaysHigh";
      JCN _cascMode3;
      L #p.write.mc.MODE;
      T "idbEMC2".f[#p.child.EMC_WATER].p.write.mc.MODE;
_cascMode3:      NOP 0;

      A "alwaysHigh";
      JCN _cascMode4;
      L #p.write.mc.MODE;
      T "idbEMG1".f[#p.child.EMG_FILTER].p.write.mc.MODE;
_cascMode4:      NOP 0;

      A "alwaysHigh";
      JCN _cascMode5;
      L #p.write.mc.MODE;
      T "idbEMM1".f[#p.child.EMM_VESSEL].p.write.mc.MODE;
_cascMode5:      NOP 0;

      A "alwaysHigh";
      JCN _cascMode6;
      L #p.write.mc.MODE;
      T "idbEMT1".f[#p.child.EMT_HEX].p.write.mc.MODE;
_cascMode6:      NOP 0;

      A "alwaysHigh";
      JCN _cascMode7;
      L #p.write.mc.MODE;
      T "idbEMV2".f[#p.child.EMV_INLET].p.write.mc.MODE;
_cascMode7:      NOP 0;

      A "alwaysHigh";
      JCN _cascMode8;
      L #p.write.mc.MODE;
      T "idbEMV1".f[#p.child.EMV_VESSEL].p.write.mc.MODE;
_cascMode8:      NOP 0;

      A "alwaysHigh";
      JCN _cascMode9;
      L #p.write.mc.MODE;
      T "idbEMX4".f[#p.child.EMX_DRAIN].p.write.mc.MODE;
_cascMode9:      NOP 0;

      A #selected_FILL_FLZ.FL1;
      JCN _cascMode10;
      L #p.write.mc.MODE;
      T "idbEMX5".f[#p.child.EMX_FILL1].p.write.mc.MODE;
_cascMode10:      NOP 0;

      A #selected_FILL_FLZ.FL2;
      JCN _cascMode11;
      L #p.write.mc.MODE;
      T "idbEMX5".f[#p.child.EMX_FILL2].p.write.mc.MODE;
_cascMode11:      NOP 0;

      A "alwaysHigh";
      JCN _cascMode12;
      L #p.write.mc.MODE;
      T "idbEMX1".f[#p.child.EMX_MMFL].p.write.mc.MODE;
_cascMode12:      NOP 0;

      O #selected_FILL_FLZ.FL1;
      O #selected_FILL_FLZ.FL2;
      O #selected_VESSEL_SY.S1;
      O #selected_VESSEL_SY.S2;
      JCN _cascMode13;
      L #p.write.mc.MODE;
      T "idbEMX6".f[#p.child.EMX_SMFL].p.write.mc.MODE;
_cascMode13:      NOP 0;

      O #selected_FILL_FLZ.FL1;
      O #selected_FILL_FLZ.FL2;
      O #selected_VESSEL_SY.S1;
      O #selected_VESSEL_SY.S2;
      JCN _cascMode14;
      L #p.write.mc.MODE;
      T "idbEMX4".f[#p.child.EMX_SMFLDRN].p.write.mc.MODE;
_cascMode14:      NOP 0;

      A #selected_VESSEL_SY.S1;
      JCN _cascMode15;
      L #p.write.mc.MODE;
      T "idbEMX2".f[#p.child.EMX_TRANSFER1].p.write.mc.MODE;
_cascMode15:      NOP 0;

      A #selected_VESSEL_SY.S2;
      JCN _cascMode16;
      L #p.write.mc.MODE;
      T "idbEMX2".f[#p.child.EMX_TRANSFER2].p.write.mc.MODE;
_cascMode16:      NOP 0;

_nomcAutoOOS:      NOP 0;

NETWORK
TITLE = Interlocked condition cleared
//------------------------------------------------------------------------//
// Set the state stopped if the interlock condition just cleared:         //
//------------------------------------------------------------------------//
      AN #p.read.mc.INTERLOCK;
      A(;
      L #p.read.mc.STATE;
      L "dbCONST".BLK.STATE.INTERLOCKED;
      ==I;
      );
      JCN _ilCleared;
      L #p.read.bmc.lastSTATE;
      T #p.read.mc.STATE;

_ilCleared:      NOP 0;

NETWORK
TITLE = Upload non-boolean child parameter values
//------------------------------------------------------------------------//
// CHILD PARAMETER   CHILD PARAMETER   CHILD PARAMETER   CHILD PARAMETER  //
//                                                                        //
// Get the initial input non-boolean value for the child parameter:       //
//------------------------------------------------------------------------//
      L "idbEMA1".f[#p.child.EMA_VESSEL].p.read.ACUMTIMEH;
      T #p.read.EMA_VESSEL_ACUMTIMEH;
      L "idbEMA1".f[#p.child.EMA_VESSEL].p.read.ACUMTIMEM;
      T #p.read.EMA_VESSEL_ACUMTIMEM;
      L "idbEMA1".f[#p.child.EMA_VESSEL].p.read.ACUMTIMES;
      T #p.read.EMA_VESSEL_ACUMTIMES;
      L "idbEMC1".f[#p.child.EMC_GAS].p.read.PI_VESSEL_PV;
      T #p.read.EMC_GAS_PI_VESSEL_PV;
      L "idbEMC2".f[#p.child.EMC_WATER].p.read.MASS_ACTUAL;
      T #p.read.EMC_WATER_MASS_ACTUAL;
      L "idbEMC2".f[#p.child.EMC_WATER].p.read.MASS_FINAL;
      T #p.read.EMC_WATER_MASS_FINAL;
      L "idbEMC2".f[#p.child.EMC_WATER].p.read.MASS_INITIAL;
      T #p.read.EMC_WATER_MASS_INITIAL;
      L "idbEMG1".f[#p.child.EMG_FILTER].p.read.TI_DRAIN_PV;
      T #p.read.EMG_FILTER_TI_DRAIN_PV;
      L "idbEMG1".f[#p.child.EMG_FILTER].p.read.TI_VENT_PV;
      T #p.read.EMG_FILTER_TI_VENT_PV;
      L "idbEMM1".f[#p.child.EMM_VESSEL].p.read.MASS_GROSS;
      T #p.read.EMM_VESSEL_MASS_GROSS;
      L "idbEMM1".f[#p.child.EMM_VESSEL].p.read.MASS_NETT;
      T #p.read.EMM_VESSEL_MASS_NETT;
      L "idbEMM1".f[#p.child.EMM_VESSEL].p.read.MASS_TARE;
      T #p.read.EMM_VESSEL_MASS_TARE;
      L "idbEMM1".f[#p.child.EMM_VESSEL].p.read.MI_VESSEL_PV;
      T #p.read.EMM_VESSEL_MI_VESSEL_PV;
      L "idbEMV1".f[#p.child.EMV_VESSEL].p.read.TI_VESSEL_PV;
      T #p.read.EMV_VESSEL_TI_VESSEL_PV;
      L "idbEMX4".f[#p.child.EMX_DRAIN].p.read.TI_DRAIN_PV;
      T #p.read.EMX_DRAIN_TI_DRAIN_PV;

NETWORK
TITLE = Upload boolean child parameter values
//------------------------------------------------------------------------//
// CHILD PARAMETER   CHILD PARAMETER   CHILD PARAMETER   CHILD PARAMETER  //
//                                                                        //
// Get the initial boolean input value for the child parameter:           //
//------------------------------------------------------------------------//
      A "idbEMA1".f[#p.child.EMA_VESSEL].p.read.AGIT_RUNNING;
      = #p.read.EMA_VESSEL_AGIT_RUNNING;
      A "idbEMA1".f[#p.child.EMA_VESSEL].p.read.AGIT_STOPPED;
      = #p.read.EMA_VESSEL_AGIT_STOPPED;
      A "idbEMC2".f[#p.child.EMC_WATER].p.read.MASS_READY;
      = #p.read.EMC_WATER_MASS_READY;

NETWORK
TITLE = Set parent parameter FILL_FLZ value for child device EMX_TRANSFER1
//------------------------------------------------------------------------//
// PARENT PARAMETER   PARENT PARAMETER   PARENT PARAMETER   PARENT PARAM  //
//                                                                        //
// Set the initial input value for the child calling parameter:           //
//------------------------------------------------------------------------//
      A "idbEMX2".f[#p.child.EMX_TRANSFER1].p.read.mc.modeAUTO;
      A #selected_VESSEL_SY.S1;
      JCN _parentWrite_1_EMX_TRANSFER1_FILL_FLZ;
      L #p.write.FILL_FLZ;
      T #p.write.EMX_TRANSFER1_FILL_FLZ;

_parentWrite_1_EMX_TRANSFER1_FILL_FLZ:      NOP 0;

NETWORK
TITLE = Set parent parameter VESSEL_MX value for child device EMX_TRANSFER1
//------------------------------------------------------------------------//
// PARENT PARAMETER   PARENT PARAMETER   PARENT PARAMETER   PARENT PARAM  //
//                                                                        //
// Set the initial input value for the child calling parameter:           //
//------------------------------------------------------------------------//
      A "idbEMX2".f[#p.child.EMX_TRANSFER1].p.read.mc.modeAUTO;
      A #selected_VESSEL_SY.S1;
      JCN _parentWrite_2_EMX_TRANSFER1_VESSEL_MX;
      L #p.write.VESSEL_MX;
      T #p.write.EMX_TRANSFER1_VESSEL_MX;

_parentWrite_2_EMX_TRANSFER1_VESSEL_MX:      NOP 0;

NETWORK
TITLE = Set parent parameter FILL_FLZ value for child device EMX_TRANSFER2
//------------------------------------------------------------------------//
// PARENT PARAMETER   PARENT PARAMETER   PARENT PARAMETER   PARENT PARAM  //
//                                                                        //
// Set the initial input value for the child calling parameter:           //
//------------------------------------------------------------------------//
      A "idbEMX2".f[#p.child.EMX_TRANSFER2].p.read.mc.modeAUTO;
      A #selected_VESSEL_SY.S2;
      JCN _parentWrite_1_EMX_TRANSFER2_FILL_FLZ;
      L #p.write.FILL_FLZ;
      T #p.write.EMX_TRANSFER2_FILL_FLZ;

_parentWrite_1_EMX_TRANSFER2_FILL_FLZ:      NOP 0;

NETWORK
TITLE = Set parent parameter VESSEL_MX value for child device EMX_TRANSFER2
//------------------------------------------------------------------------//
// PARENT PARAMETER   PARENT PARAMETER   PARENT PARAMETER   PARENT PARAM  //
//                                                                        //
// Set the initial input value for the child calling parameter:           //
//------------------------------------------------------------------------//
      A "idbEMX2".f[#p.child.EMX_TRANSFER2].p.read.mc.modeAUTO;
      A #selected_VESSEL_SY.S2;
      JCN _parentWrite_2_EMX_TRANSFER2_VESSEL_MX;
      L #p.write.VESSEL_MX;
      T #p.write.EMX_TRANSFER2_VESSEL_MX;

_parentWrite_2_EMX_TRANSFER2_VESSEL_MX:      NOP 0;



NETWORK
TITLE = Hygiene Status Calculation
//------------------------------------------------------------------------//
// HYGIENE   HYGIENE   HYGIENE   HYGIENE   HYGIENE   HYGIENE   HYGIENE    //
//                                                                        //
// Calculate the hygiene status of the block:                             //
//------------------------------------------------------------------------//

      CALL "fcHygiene"
      (  hs                          := #p.read.hs
      );

NETWORK
TITLE = SWITCH SWITCH SWITCH command and state
//------------------------------------------------------------------------//
// SWITCH   SWITCH   SWITCH   SWITCH   SWITCH   SWITCH   SWITCH   SWITCH  //
//                                                                        //
// Switch statement for block command and state. The order of the jumps   //
// is important:                                                          //
//------------------------------------------------------------------------//
_switch:      NOP 0;
      A #cmdSTOPPED;
      JC _state_STOPPED;

      A #p.read.bmc.eventCmdStop;
      JC _state_STOPPING;

      O #p.read.bmc.eventCmdStart;
      O #p.read.bmc.eventCmdRestart;
      JC _state_STARTING;

      A #flags.substateCompleted;
      JC _state_COMPLETED;

      A #p.read.bmc.stateRUNNING;
      JC _state_RUNNING;

      SET;
      JC _switch_end;

  //------------------------------------------------------------------------//
  // SWITCH   SWITCH   SWITCH   SWITCH   SWITCH   SWITCH   SWITCH   SWITCH  //
  // STOPPED   STOPPED   STOPPED   STOPPED   STOPPED   STOPPED   STOPPED    //
  // STOPPED   STOPPED   STOPPED   STOPPED   STOPPED   STOPPED   STOPPED    //
  //------------------------------------------------------------------------//
_state_STOPPED:      NOP 0;

NETWORK
TITLE = STOPPED STOPPED STOPPED Set block state STOPPED
//------------------------------------------------------------------------//
// Reset the completed flag and the block state to stopped:               //
//------------------------------------------------------------------------//
      L "dbCONST".BLK.MX.STATE.STOPPED;
      T #p.read.mc.STATE;

NETWORK
TITLE = Send SFC STOP command
//------------------------------------------------------------------------//
// If commanded to Stop then tell the SFC to go to the last step:         //
//------------------------------------------------------------------------//
      L "dbCONST".SEQ.CMD.STOP;
      T #UO_MX_CIP.smc.SQ_CMD;
      T #UO_MX_CIP.sqSequencer.CMD.New;
      T #UO_MX_FILL.smc.SQ_CMD;
      T #UO_MX_FILL.sqSequencer.CMD.New;
      T #UO_MX_FILTER.smc.SQ_CMD;
      T #UO_MX_FILTER.sqSequencer.CMD.New;
      T #UO_MX_MAKE.smc.SQ_CMD;
      T #UO_MX_MAKE.sqSequencer.CMD.New;
      T #UO_MX_SETUP.smc.SQ_CMD;
      T #UO_MX_SETUP.sqSequencer.CMD.New;
      T #UO_MX_SIP.smc.SQ_CMD;
      T #UO_MX_SIP.sqSequencer.CMD.New;

NETWORK
TITLE = Reset running substate and completion flags
//------------------------------------------------------------------------//
// Reset flags:                                                           //
//------------------------------------------------------------------------//
      R #flags.sfcAborted;
      R #flags.sfcCompleted;
      R #flags.substateCompleted;
      R #subsRunning.CIP;
      R #subsRunning.FILL;
      R #subsRunning.FILTER;
      R #subsRunning.MAKE;
      R #subsRunning.SETUP;
      R #subsRunning.SIP;

NETWORK
TITLE = Disarm flowpath devices on STOP command
//------------------------------------------------------------------------//
// Disarm the flowpath child devices when STOP command issued:            //
//------------------------------------------------------------------------//
      R "idbEMA1".f[#p.child.EMA_VESSEL].p.write.mc.ARMED;
      R "idbEMC1".f[#p.child.EMC_GAS].p.write.mc.ARMED;
      R "idbEMC2".f[#p.child.EMC_WATER].p.write.mc.ARMED;
      R "idbEMG1".f[#p.child.EMG_FILTER].p.write.mc.ARMED;
      R "idbEMM1".f[#p.child.EMM_VESSEL].p.write.mc.ARMED;
      R "idbEMT1".f[#p.child.EMT_HEX].p.write.mc.ARMED;
      R "idbEMV2".f[#p.child.EMV_INLET].p.write.mc.ARMED;
      R "idbEMV1".f[#p.child.EMV_VESSEL].p.write.mc.ARMED;
      R "idbEMX4".f[#p.child.EMX_DRAIN].p.write.mc.ARMED;
      R "idbEMX5".f[#p.child.EMX_FILL1].p.write.mc.ARMED;
      R "idbEMX5".f[#p.child.EMX_FILL2].p.write.mc.ARMED;
      R "idbEMX1".f[#p.child.EMX_MMFL].p.write.mc.ARMED;
      R "idbEMX6".f[#p.child.EMX_SMFL].p.write.mc.ARMED;
      R "idbEMX4".f[#p.child.EMX_SMFLDRN].p.write.mc.ARMED;
      R "idbEMX2".f[#p.child.EMX_TRANSFER1].p.write.mc.ARMED;
      R "idbEMX2".f[#p.child.EMX_TRANSFER2].p.write.mc.ARMED;

NETWORK
TITLE = Clear the operator prompt flags
//------------------------------------------------------------------------//
// CLEAR OPERATOR PROMPT   CLEAR OPERATOR PROMPT   CLEAR OPERATOR PROMPT  //
//                                                                        //
// Clear the SFC prompt and confirm bits and the global shared event bits.//
// Each HMI requires its own trigger and active flags;                    //
//------------------------------------------------------------------------//
      R #UO_MX_FILL._prompt_abort;
      R #UO_MX_FILL._prompt_abort_confirm_yes;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_1].cancel1;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_1].cancel2;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_1].cancel3;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_1].cancel4;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_1].cancel5;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_1].confirmYes;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_1].confirmNo;
      R #UO_MX_FILTER._prompt_abort;
      R #UO_MX_FILTER._prompt_abort_confirm_yes;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_2].cancel1;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_2].cancel2;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_2].cancel3;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_2].cancel4;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_2].cancel5;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_2].confirmYes;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_2].confirmNo;
      R #UO_MX_SETUP._prompt_connect_ok;
      R #UO_MX_SETUP._prompt_connect_ok_confirm_yes;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_3].cancel1;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_3].cancel2;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_3].cancel3;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_3].cancel4;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_3].cancel5;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_3].confirmYes;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_3].confirmNo;
      R #UO_MX_FILTER._prompt_filt_completed;
      R #UO_MX_FILTER._prompt_filt_completed_confirm_yes;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_4].cancel1;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_4].cancel2;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_4].cancel3;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_4].cancel4;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_4].cancel5;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_4].confirmYes;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_4].confirmNo;
      R #UO_MX_FILL._prompt_filtration;
      R #UO_MX_FILL._prompt_filtration_confirm_yes;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_5].cancel1;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_5].cancel2;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_5].cancel3;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_5].cancel4;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_5].cancel5;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_5].confirmYes;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_5].confirmNo;
      R #UO_MX_FILTER._prompt_filtration;
      R #UO_MX_FILTER._prompt_filtration_confirm_yes;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_6].cancel1;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_6].cancel2;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_6].cancel3;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_6].cancel4;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_6].cancel5;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_6].confirmYes;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_6].confirmNo;
      R #UO_MX_MAKE._prompt_manway_complete;
      R #UO_MX_MAKE._prompt_manway_complete_confirm_yes;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_7].cancel1;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_7].cancel2;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_7].cancel3;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_7].cancel4;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_7].cancel5;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_7].confirmYes;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_7].confirmNo;
      R #UO_MX_SETUP._prompt_not_held;
      R #UO_MX_SETUP._prompt_not_held_confirm_yes;
      R #UO_MX_SETUP._prompt_not_held_confirm_no;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_8].cancel1;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_8].cancel2;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_8].cancel3;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_8].cancel4;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_8].cancel5;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_8].confirmYes;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_8].confirmNo;
      R #UO_MX_SETUP._prompt_not_reach;
      R #UO_MX_SETUP._prompt_not_reach_confirm_yes;
      R #UO_MX_SETUP._prompt_not_reach_confirm_no;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_9].cancel1;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_9].cancel2;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_9].cancel3;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_9].cancel4;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_9].cancel5;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_9].confirmYes;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_9].confirmNo;
      R #UO_MX_MAKE._prompt_pmo;
      R #UO_MX_MAKE._prompt_pmo_confirm_yes;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_10].cancel1;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_10].cancel2;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_10].cancel3;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_10].cancel4;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_10].cancel5;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_10].confirmYes;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_10].confirmNo;
      R #UO_MX_MAKE._prompt_tare;
      R #UO_MX_MAKE._prompt_tare_confirm_yes;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_11].cancel1;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_11].cancel2;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_11].cancel3;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_11].cancel4;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_11].cancel5;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_11].confirmYes;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_11].confirmNo;
      R #UO_MX_SIP._prompt_try_again;
      R #UO_MX_SIP._prompt_try_again_confirm_yes;
      R #UO_MX_SIP._prompt_try_again_confirm_no;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_12].cancel1;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_12].cancel2;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_12].cancel3;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_12].cancel4;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_12].cancel5;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_12].confirmYes;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_12].confirmNo;

NETWORK
TITLE = Clear the event prompt confirm No message flags
//------------------------------------------------------------------------//
// CLEAR PROMPT NO   CLEAR PROMPT NO   CLEAR PROMPT NO   CLEAR PROMPT NO  //
//                                                                        //
// Clear the SFC event prompt confirm No  bits and the class bits:        //
//------------------------------------------------------------------------//
      L 0;
      T #wEventConfirmNo[0];

NETWORK
TITLE = Clear the event prompt confirm Yes message flags
//------------------------------------------------------------------------//
// CLEAR PROMPT YES   CLEAR PROMPT YES   CLEAR PROMPT YES   CLEAR PROMPT  //
//                                                                        //
// Clear the SFC event prompt confirm Yes  bits and the class bits:       //
//------------------------------------------------------------------------//
      L 0;
      T #wEventConfirmYes[0];

NETWORK
TITLE = Clear the log message flags
//------------------------------------------------------------------------//
// CLEAR LOG MESSAGE   CLEAR LOG MESSAGE   CLEAR LOG MESSAGE   CLEAR LOG  //
//                                                                        //
// Clear the SFC log message bits and the class bits:                     //
//------------------------------------------------------------------------//
      L 0;
      T #wEventLogMsg[0];
      T #wEventLogMsg[1];
      T #wEventLogMsg[2];
      T #wEventLogMsg[3];
      R #UO_MX_CIP._log_msg_cip_begin;
      R #UO_MX_CIP._log_msg_cip_end;
      R #UO_MX_FILL._log_msg_fill_begin;
      R #UO_MX_FILL._log_msg_fill_end;
      R #UO_MX_FILTER._log_msg_filter_begin;
      R #UO_MX_FILTER._log_msg_filter_end;
      R #UO_MX_FILL._log_msg_filtration_complete;
      R #UO_MX_FILTER._log_msg_filtration_complete;
      R #UO_MX_FILL._log_msg_filtration_end;
      R #UO_MX_FILTER._log_msg_filtration_end;
      R #UO_MX_FILL._log_msg_filtration_start;
      R #UO_MX_MAKE._log_msg_make_begin;
      R #UO_MX_MAKE._log_msg_make_end;
      R #UO_MX_SETUP._log_msg_not_held_abort;
      R #UO_MX_SETUP._log_msg_not_held_repeat;
      R #UO_MX_SETUP._log_msg_not_reach_abort;
      R #UO_MX_SETUP._log_msg_not_reach_repeat;
      R #UO_MX_MAKE._log_msg_pmo_complete;
      R #UO_MX_SIP._log_msg_pres_blow_reached;
      R #UO_MX_SIP._log_msg_pres_leave_reached;
      R #UO_MX_CIP._log_msg_pw_fl_wash_begin;
      R #UO_MX_CIP._log_msg_pw_fl_wash_end;
      R #UO_MX_CIP._log_msg_pw_flood_begin;
      R #UO_MX_CIP._log_msg_pw_flood_end;
      R #UO_MX_CIP._log_msg_pw_flood_timeout;
      R #UO_MX_CIP._log_msg_pw_flush_begin;
      R #UO_MX_CIP._log_msg_pw_flush_end;
      R #UO_MX_CIP._log_msg_pw_wash_begin;
      R #UO_MX_CIP._log_msg_pw_wash_end;
      R #UO_MX_SETUP._log_msg_setup_begin;
      R #UO_MX_SETUP._log_msg_setup_end;
      R #UO_MX_SIP._log_msg_sip_abort;
      R #UO_MX_SIP._log_msg_sip_begin;
      R #UO_MX_SIP._log_msg_sip_complete;
      R #UO_MX_SIP._log_msg_sip_end;
      R #UO_MX_SIP._log_msg_sip_start;
      R #UO_MX_SIP._log_msg_sip_timer_reset;
      R #UO_MX_SIP._log_msg_steam_closed;
      R #UO_MX_SIP._log_msg_steam_open;
      R #UO_MX_FILTER._log_msg_temperature_abort;
      R #UO_MX_SETUP._log_msg_vacuum_begin;
      R #UO_MX_SIP._log_msg_vacuum_begin;
      R #UO_MX_SIP._log_msg_vacuum_fail;
      R #UO_MX_SIP._log_msg_vacuum_fail_abort;
      R #UO_MX_SIP._log_msg_vacuum_fail_repeat;
      R #UO_MX_CIP._log_msg_wfi_rinse_begin;
      R #UO_MX_CIP._log_msg_wfi_rinse_end;
      R #UO_MX_FILL._log_msg_wrong_hygiene;
      R #UO_MX_FILTER._log_msg_wrong_hygiene;

NETWORK
TITLE = Clear the log real data flags
//------------------------------------------------------------------------//
// CLEAR LOG REAL   CLEAR LOG REAL   CLEAR LOG REAL   CLEAR LOG REAL   CL //
//                                                                        //
// Clear the SFC log real data:                                           //
//------------------------------------------------------------------------//
      L 0;
      T #wEventLogReal[0];
      T "dbEVENT".eventDataReal[9];
      T "dbEVENT".eventDataReal[10];
      T "dbEVENT".eventDataReal[11];
      T "dbEVENT".eventDataReal[12];
      T "dbEVENT".eventDataReal[13];
      T "dbEVENT".eventDataReal[14];
      T "dbEVENT".eventDataReal[15];
      T "dbEVENT".eventDataReal[16];
      T "dbEVENT".eventDataReal[17];
      T "dbEVENT".eventDataReal[18];
      T "dbEVENT".eventDataReal[19];
      T "dbEVENT".eventDataReal[20];
      T "dbEVENT".eventDataReal[21];
      R #UO_MX_SIP._log_real_emg_ti_drain_pv;
      R #UO_MX_SIP._log_real_emg_ti_vent_pv;
      R #UO_MX_SIP._log_real_emv_ti_vessel_pv;
      R #UO_MX_SIP._log_real_emx_ti_drain_pv;
      R #UO_MX_FILTER._log_real_hi_temperature;
      R #UO_MX_FILTER._log_real_hihi_temperature;
      R #UO_MX_SETUP._log_real_not_held;
      R #UO_MX_SIP._log_real_positive_pressure;
      R #UO_MX_SETUP._log_real_pressure_mx;
      R #UO_MX_CIP._log_real_pw_flood_mass;
      R #UO_MX_FILTER._log_real_reduced_vessel_mass;
      R #UO_MX_FILTER._log_real_throttled_vessel_mass;
      R #UO_MX_SETUP._log_real_vacuum_fail;

NETWORK
TITLE = Clear the log time data flags
//------------------------------------------------------------------------//
// CLEAR LOG TIME   CLEAR LOG TIME   CLEAR LOG TIME   CLEAR LOG TIME   CL //
//                                                                        //
// Clear the SFC log time data:                                           //
//------------------------------------------------------------------------//
      T #wEventLogTime[0];
      T "dbEVENT".eventDataTime[1];
      T "dbEVENT".eventDataTime[2];
      T "dbEVENT".eventDataTime[3];
      T "dbEVENT".eventDataTime[4];
      T "dbEVENT".eventDataTime[5];
      T "dbEVENT".eventDataTime[6];
      T "dbEVENT".eventDataTime[7];
      T "dbEVENT".eventDataTime[8];
      R #UO_MX_CIP._log_time_act_flood_mixing;
      R #UO_MX_CIP._log_time_act_pw_flush;
      R #UO_MX_CIP._log_time_act_pw_flwash;
      R #UO_MX_CIP._log_time_act_pw_steam;
      R #UO_MX_CIP._log_time_act_pw_wash;
      R #UO_MX_SETUP._log_time_act_vacuum_held;
      R #UO_MX_CIP._log_time_act_wfi_flrinse;
      R #UO_MX_CIP._log_time_act_wfi_rinse;

NETWORK
TITLE = Zero the real data values
//------------------------------------------------------------------------//
// ZERO DATA REAL   ZERO DATA REAL   ZERO DATA REAL   ZERO DATA REAL   ZE //
//                                                                        //
// Zero the SFC log real data parameter:                                  //
//------------------------------------------------------------------------//
      L 0;
      T #UO_MX_CIP._real_pw_flood_mass;
      T #UO_MX_FILTER._real_throttled_vessel_mass;
      T #UO_MX_FILTER._real_hihi_temperature;
      T #UO_MX_FILTER._real_hi_temperature;
      T #UO_MX_FILTER._real_reduced_vessel_mass;
      T #UO_MX_SETUP._real_not_held;
      T #UO_MX_SETUP._real_vacuum_fail;
      T #UO_MX_SETUP._real_pressure_mx;
      T #UO_MX_SIP._real_emg_ti_vent_pv;
      T #UO_MX_SIP._real_emg_ti_drain_pv;
      T #UO_MX_SIP._real_emv_ti_vessel_pv;
      T #UO_MX_SIP._real_emx_ti_drain_pv;
      T #UO_MX_SIP._real_positive_pressure;

NETWORK
TITLE = Zero the log time data values
//------------------------------------------------------------------------//
// ZERO DATA TIME   ZERO DATA TIME   ZERO DATA TIME   ZERO DATA TIME   ZE //
//                                                                        //
// Zero the SFC log time data and the global shared event DB data:        //
//------------------------------------------------------------------------//
      L 0;
      T #UO_MX_CIP._time_act_wfi_flrinse;
      T #UO_MX_CIP._time_act_wfi_rinse;
      T #UO_MX_CIP._time_act_pw_steam;
      T #UO_MX_CIP._time_act_pw_flwash;
      T #UO_MX_CIP._time_act_pw_wash;
      T #UO_MX_CIP._time_act_flood_mixing;
      T #UO_MX_CIP._time_act_pw_flush;
      T #UO_MX_SETUP._time_act_vacuum_held;

      SET;
      JC _switch_end;

  //------------------------------------------------------------------------//
  // SWITCH   SWITCH   SWITCH   SWITCH   SWITCH   SWITCH   SWITCH   SWITCH  //
  // STARTING   STARTING   STARTING   STARTING   STARTING   STARTING   STAR //
  // STARTING   STARTING   STARTING   STARTING   STARTING   STARTING   STAR //
  //------------------------------------------------------------------------//
_state_STARTING:      NOP 0;

NETWORK
TITLE = STARTING STARTING STARTING Reset running substate and completion flags
//------------------------------------------------------------------------//
// Reset flags:                                                           //
//------------------------------------------------------------------------//
      R #flags.sfcAborted;
      R #flags.sfcCompleted;
      R #flags.substateCompleted;
      R #subsRunning.CIP;
      R #subsRunning.FILL;
      R #subsRunning.FILTER;
      R #subsRunning.MAKE;
      R #subsRunning.SETUP;
      R #subsRunning.SIP;

NETWORK
TITLE = Set running SUBSTATE if CIP
//------------------------------------------------------------------------//
// RUNNING SUBSTATE FLAG   RUNNING SUBSTATE FLAG   RUNNING SUBSTATE FLAG  //
//                                                                        //
// Convert running substate values into boolean flags for ease of use in  //
// boolean logic:                                                         //
//------------------------------------------------------------------------//
      A(;
      L #p.write.mc.SUBS;
      L "dbCONST".BLK.MX.SUBS.CIP;
      ==I;
      );
      = #subsStart.CIP;
      JCN _noSubsRun_CIP;
      S #subsRunning.CIP;
_noSubsRun_CIP:      NOP 0;

NETWORK
TITLE = Set running SUBSTATE if FILL
//------------------------------------------------------------------------//
// RUNNING SUBSTATE FLAG   RUNNING SUBSTATE FLAG   RUNNING SUBSTATE FLAG  //
//                                                                        //
// Convert running substate values into boolean flags for ease of use in  //
// boolean logic:                                                         //
//------------------------------------------------------------------------//
      A(;
      L #p.write.mc.SUBS;
      L "dbCONST".BLK.MX.SUBS.FILL;
      ==I;
      );
      = #subsStart.FILL;
      JCN _noSubsRun_FILL;
      S #subsRunning.FILL;
_noSubsRun_FILL:      NOP 0;

NETWORK
TITLE = Set running SUBSTATE if FILTER
//------------------------------------------------------------------------//
// RUNNING SUBSTATE FLAG   RUNNING SUBSTATE FLAG   RUNNING SUBSTATE FLAG  //
//                                                                        //
// Convert running substate values into boolean flags for ease of use in  //
// boolean logic:                                                         //
//------------------------------------------------------------------------//
      A(;
      L #p.write.mc.SUBS;
      L "dbCONST".BLK.MX.SUBS.FILTER;
      ==I;
      );
      = #subsStart.FILTER;
      JCN _noSubsRun_FILTER;
      S #subsRunning.FILTER;
_noSubsRun_FILTER:      NOP 0;

NETWORK
TITLE = Set running SUBSTATE if MAKE
//------------------------------------------------------------------------//
// RUNNING SUBSTATE FLAG   RUNNING SUBSTATE FLAG   RUNNING SUBSTATE FLAG  //
//                                                                        //
// Convert running substate values into boolean flags for ease of use in  //
// boolean logic:                                                         //
//------------------------------------------------------------------------//
      A(;
      L #p.write.mc.SUBS;
      L "dbCONST".BLK.MX.SUBS.MAKE;
      ==I;
      );
      = #subsStart.MAKE;
      JCN _noSubsRun_MAKE;
      S #subsRunning.MAKE;
_noSubsRun_MAKE:      NOP 0;

NETWORK
TITLE = Set running SUBSTATE if SETUP
//------------------------------------------------------------------------//
// RUNNING SUBSTATE FLAG   RUNNING SUBSTATE FLAG   RUNNING SUBSTATE FLAG  //
//                                                                        //
// Convert running substate values into boolean flags for ease of use in  //
// boolean logic:                                                         //
//------------------------------------------------------------------------//
      A(;
      L #p.write.mc.SUBS;
      L "dbCONST".BLK.MX.SUBS.SETUP;
      ==I;
      );
      = #subsStart.SETUP;
      JCN _noSubsRun_SETUP;
      S #subsRunning.SETUP;
_noSubsRun_SETUP:      NOP 0;

NETWORK
TITLE = Set running SUBSTATE if SIP
//------------------------------------------------------------------------//
// RUNNING SUBSTATE FLAG   RUNNING SUBSTATE FLAG   RUNNING SUBSTATE FLAG  //
//                                                                        //
// Convert running substate values into boolean flags for ease of use in  //
// boolean logic:                                                         //
//------------------------------------------------------------------------//
      A(;
      L #p.write.mc.SUBS;
      L "dbCONST".BLK.MX.SUBS.SIP;
      ==I;
      );
      = #subsStart.SIP;
      JCN _noSubsRun_SIP;
      S #subsRunning.SIP;
_noSubsRun_SIP:      NOP 0;


NETWORK
TITLE = The STATE follows the SUBSTATE when running
//------------------------------------------------------------------------//
// Set the state to the substate if running:                              //
//------------------------------------------------------------------------//
      O #subsRunning.CIP;
      O #subsRunning.FILL;
      O #subsRunning.FILTER;
      O #subsRunning.MAKE;
      O #subsRunning.SETUP;
      O #subsRunning.SIP;
      JCN _noSubsRun;
      L #p.write.mc.SUBS;
      T #p.read.mc.STATE;
_noSubsRun:      NOP 0;

NETWORK
TITLE = Set selected child EMX_FILL1 index value
//------------------------------------------------------------------------//
// CHILD SELECT   CHILD SELECT   CHILD SELECT   CHILD SELECT   CHILD SEL  //
//                                                                        //
// Set the index value for the selected child:                            //
//------------------------------------------------------------------------//
      A #selected_FILL_FLZ.FL1;
      JCN _childSelect_1;
      L #p.child.EMX_FILL1;
      T #p.select.EMX_FILL;
_childSelect_1:      NOP 0;

NETWORK
TITLE = Set selected child EMX_FILL2 index value
//------------------------------------------------------------------------//
// CHILD SELECT   CHILD SELECT   CHILD SELECT   CHILD SELECT   CHILD SEL  //
//                                                                        //
// Set the index value for the selected child:                            //
//------------------------------------------------------------------------//
      A #selected_FILL_FLZ.FL2;
      JCN _childSelect_2;
      L #p.child.EMX_FILL2;
      T #p.select.EMX_FILL;
_childSelect_2:      NOP 0;

NETWORK
TITLE = Set selected child EMX_TRANSFER1 index value
//------------------------------------------------------------------------//
// CHILD SELECT   CHILD SELECT   CHILD SELECT   CHILD SELECT   CHILD SEL  //
//                                                                        //
// Set the index value for the selected child:                            //
//------------------------------------------------------------------------//
      A #selected_VESSEL_SY.S1;
      JCN _childSelect_3;
      L #p.child.EMX_TRANSFER1;
      T #p.select.EMX_TRANSFER;
_childSelect_3:      NOP 0;

NETWORK
TITLE = Set selected child EMX_TRANSFER2 index value
//------------------------------------------------------------------------//
// CHILD SELECT   CHILD SELECT   CHILD SELECT   CHILD SELECT   CHILD SEL  //
//                                                                        //
// Set the index value for the selected child:                            //
//------------------------------------------------------------------------//
      A #selected_VESSEL_SY.S2;
      JCN _childSelect_4;
      L #p.child.EMX_TRANSFER2;
      T #p.select.EMX_TRANSFER;
_childSelect_4:      NOP 0;


NETWORK
TITLE = Calling Parameter Selection flags
//------------------------------------------------------------------------//
// CALLING PARAMETER SELECTION FLAG   CALLING PARAMETER SELECTION FLAG    //
//                                                                        //
// Convert calling parameter selections into the boolean flags for ease   //
// of use in boolean logic if starting a new substate:                    //
//------------------------------------------------------------------------//
      A(;
      L #p.write.FILL_FLZ;
      L "dbCONST".SEL.FLZ.FL1;
      ==I;
      );
      JCN _noSelect_FILL_FLZ_FL1;
      S #selected_FILL_FLZ.FL1;
      JC _select_FILL_FLZ_FL1;

_noSelect_FILL_FLZ_FL1:      NOP 0;
      R #selected_FILL_FLZ.FL1;

_select_FILL_FLZ_FL1:      NOP 0;

      A(;
      L #p.write.FILL_FLZ;
      L "dbCONST".SEL.FLZ.FL2;
      ==I;
      );
      JCN _noSelect_FILL_FLZ_FL2;
      S #selected_FILL_FLZ.FL2;
      JC _select_FILL_FLZ_FL2;

_noSelect_FILL_FLZ_FL2:      NOP 0;
      R #selected_FILL_FLZ.FL2;

_select_FILL_FLZ_FL2:      NOP 0;

      A(;
      L #p.write.FILL_FLZ;
      L "dbCONST".SEL.FLZ.NONE;
      ==I;
      );
      JCN _noSelect_FILL_FLZ_NONE;
      S #selected_FILL_FLZ.NONE;
      JC _select_FILL_FLZ_NONE;

_noSelect_FILL_FLZ_NONE:      NOP 0;
      R #selected_FILL_FLZ.NONE;

_select_FILL_FLZ_NONE:      NOP 0;

      A(;
      L #p.write.VESSEL_MX;
      L "dbCONST".SEL.MX.M1;
      ==I;
      );
      JCN _noSelect_VESSEL_MX_M1;
      S #selected_VESSEL_MX.M1;
      JC _select_VESSEL_MX_M1;

_noSelect_VESSEL_MX_M1:      NOP 0;
      R #selected_VESSEL_MX.M1;

_select_VESSEL_MX_M1:      NOP 0;

      A(;
      L #p.write.VESSEL_MX;
      L "dbCONST".SEL.MX.M2;
      ==I;
      );
      JCN _noSelect_VESSEL_MX_M2;
      S #selected_VESSEL_MX.M2;
      JC _select_VESSEL_MX_M2;

_noSelect_VESSEL_MX_M2:      NOP 0;
      R #selected_VESSEL_MX.M2;

_select_VESSEL_MX_M2:      NOP 0;

      A(;
      L #p.write.VESSEL_MX;
      L "dbCONST".SEL.MX.NONE;
      ==I;
      );
      JCN _noSelect_VESSEL_MX_NONE;
      S #selected_VESSEL_MX.NONE;
      JC _select_VESSEL_MX_NONE;

_noSelect_VESSEL_MX_NONE:      NOP 0;
      R #selected_VESSEL_MX.NONE;

_select_VESSEL_MX_NONE:      NOP 0;

      A(;
      L #p.write.VESSEL_SY;
      L "dbCONST".SEL.SY.NONE;
      ==I;
      );
      JCN _noSelect_VESSEL_SY_NONE;
      S #selected_VESSEL_SY.NONE;
      JC _select_VESSEL_SY_NONE;

_noSelect_VESSEL_SY_NONE:      NOP 0;
      R #selected_VESSEL_SY.NONE;

_select_VESSEL_SY_NONE:      NOP 0;

      A(;
      L #p.write.VESSEL_SY;
      L "dbCONST".SEL.SY.S1;
      ==I;
      );
      JCN _noSelect_VESSEL_SY_S1;
      S #selected_VESSEL_SY.S1;
      JC _select_VESSEL_SY_S1;

_noSelect_VESSEL_SY_S1:      NOP 0;
      R #selected_VESSEL_SY.S1;

_select_VESSEL_SY_S1:      NOP 0;

      A(;
      L #p.write.VESSEL_SY;
      L "dbCONST".SEL.SY.S2;
      ==I;
      );
      JCN _noSelect_VESSEL_SY_S2;
      S #selected_VESSEL_SY.S2;
      JC _select_VESSEL_SY_S2;

_noSelect_VESSEL_SY_S2:      NOP 0;
      R #selected_VESSEL_SY.S2;

_select_VESSEL_SY_S2:      NOP 0;


NETWORK
TITLE = Acquire child EMX_FILL1
//------------------------------------------------------------------------//
// ACQUIRE CHILDREN   ACQUIRE CHILDREN   ACQUIRE CHILDREN   ACQUIRE CHILD //
//                                                                        //
// Flag to take writeship of the child now and release at the end if      //
// the child is available as it would be a child unavailabile failure     //
// above if not available at this point:                                  //
//------------------------------------------------------------------------//
      A #selected_FILL_FLZ.FL1;
      A "idbEMX5".f[#p.child.EMX_FILL1].p.read.mc.isAvailable;
      JCN _childAvail_1;
      S #acquire.EMX_FILL1;
      L #p.read.mc.ME;
      T "idbEMX5".f[#p.child.EMX_FILL1].p.write.mc.OWNER;

_childAvail_1:      NOP 0;

NETWORK
TITLE = Acquire child EMX_FILL2
//------------------------------------------------------------------------//
// ACQUIRE CHILDREN   ACQUIRE CHILDREN   ACQUIRE CHILDREN   ACQUIRE CHILD //
//                                                                        //
// Flag to take writeship of the child now and release at the end if      //
// the child is available as it would be a child unavailabile failure     //
// above if not available at this point:                                  //
//------------------------------------------------------------------------//
      A #selected_FILL_FLZ.FL2;
      A "idbEMX5".f[#p.child.EMX_FILL2].p.read.mc.isAvailable;
      JCN _childAvail_2;
      S #acquire.EMX_FILL2;
      L #p.read.mc.ME;
      T "idbEMX5".f[#p.child.EMX_FILL2].p.write.mc.OWNER;

_childAvail_2:      NOP 0;

NETWORK
TITLE = Acquire child EMX_SMFL
//------------------------------------------------------------------------//
// ACQUIRE CHILDREN   ACQUIRE CHILDREN   ACQUIRE CHILDREN   ACQUIRE CHILD //
//                                                                        //
// Flag to take writeship of the child now and release at the end if      //
// the child is available as it would be a child unavailabile failure     //
// above if not available at this point:                                  //
//------------------------------------------------------------------------//
      O #selected_FILL_FLZ.FL1;
      O #selected_FILL_FLZ.FL2;
      O #selected_VESSEL_SY.S1;
      O #selected_VESSEL_SY.S2;
      A "idbEMX6".f[#p.child.EMX_SMFL].p.read.mc.isAvailable;
      JCN _childAvail_3;
      S #acquire.EMX_SMFL;
      L #p.read.mc.ME;
      T "idbEMX6".f[#p.child.EMX_SMFL].p.write.mc.OWNER;

_childAvail_3:      NOP 0;

NETWORK
TITLE = Acquire child EMX_SMFLDRN
//------------------------------------------------------------------------//
// ACQUIRE CHILDREN   ACQUIRE CHILDREN   ACQUIRE CHILDREN   ACQUIRE CHILD //
//                                                                        //
// Flag to take writeship of the child now and release at the end if      //
// the child is available as it would be a child unavailabile failure     //
// above if not available at this point:                                  //
//------------------------------------------------------------------------//
      O #selected_FILL_FLZ.FL1;
      O #selected_FILL_FLZ.FL2;
      O #selected_VESSEL_SY.S1;
      O #selected_VESSEL_SY.S2;
      A "idbEMX4".f[#p.child.EMX_SMFLDRN].p.read.mc.isAvailable;
      JCN _childAvail_4;
      S #acquire.EMX_SMFLDRN;
      L #p.read.mc.ME;
      T "idbEMX4".f[#p.child.EMX_SMFLDRN].p.write.mc.OWNER;

_childAvail_4:      NOP 0;

NETWORK
TITLE = Acquire child EMX_TRANSFER1
//------------------------------------------------------------------------//
// ACQUIRE CHILDREN   ACQUIRE CHILDREN   ACQUIRE CHILDREN   ACQUIRE CHILD //
//                                                                        //
// Flag to take writeship of the child now and release at the end if      //
// the child is available as it would be a child unavailabile failure     //
// above if not available at this point:                                  //
//------------------------------------------------------------------------//
      A #selected_VESSEL_SY.S1;
      A "idbEMX2".f[#p.child.EMX_TRANSFER1].p.read.mc.isAvailable;
      JCN _childAvail_5;
      S #acquire.EMX_TRANSFER1;
      L #p.read.mc.ME;
      T "idbEMX2".f[#p.child.EMX_TRANSFER1].p.write.mc.OWNER;

_childAvail_5:      NOP 0;

NETWORK
TITLE = Acquire child EMX_TRANSFER2
//------------------------------------------------------------------------//
// ACQUIRE CHILDREN   ACQUIRE CHILDREN   ACQUIRE CHILDREN   ACQUIRE CHILD //
//                                                                        //
// Flag to take writeship of the child now and release at the end if      //
// the child is available as it would be a child unavailabile failure     //
// above if not available at this point:                                  //
//------------------------------------------------------------------------//
      A #selected_VESSEL_SY.S2;
      A "idbEMX2".f[#p.child.EMX_TRANSFER2].p.read.mc.isAvailable;
      JCN _childAvail_6;
      S #acquire.EMX_TRANSFER2;
      L #p.read.mc.ME;
      T "idbEMX2".f[#p.child.EMX_TRANSFER2].p.write.mc.OWNER;

_childAvail_6:      NOP 0;


NETWORK
TITLE = Cascade Batch Serial Number to all children
//------------------------------------------------------------------------//
// RECIPE AND BATCH ID    RECIPE AND BATCH ID    RECIPE AND BATCH ID      //
//                                                                        //
// Cascade this block's Batch Number and Recipe ID to all child devices:  //
//------------------------------------------------------------------------//
      A "alwaysHigh";
      JCN _childBatch_1;
      L #p.write.mc.SERIALNUM;
      T "idbDI1".f[#p.child.DI_ASL].p.write.mc.SERIALNUM;
      L #p.write.mc.RECIPE;
      T "idbDI1".f[#p.child.DI_ASL].p.write.mc.RECIPE;
_childBatch_1:      NOP 0;

      A "alwaysHigh";
      JCN _childBatch_2;
      L #p.write.mc.SERIALNUM;
      T "idbDI1".f[#p.child.DI_ESTOP].p.write.mc.SERIALNUM;
      L #p.write.mc.RECIPE;
      T "idbDI1".f[#p.child.DI_ESTOP].p.write.mc.RECIPE;
_childBatch_2:      NOP 0;

      A "alwaysHigh";
      JCN _childBatch_3;
      L #p.write.mc.SERIALNUM;
      T "idbDI1".f[#p.child.DI_ESTOP_AUX1].p.write.mc.SERIALNUM;
      L #p.write.mc.RECIPE;
      T "idbDI1".f[#p.child.DI_ESTOP_AUX1].p.write.mc.RECIPE;
_childBatch_3:      NOP 0;

      A "alwaysHigh";
      JCN _childBatch_4;
      L #p.write.mc.SERIALNUM;
      T "idbDI1".f[#p.child.DI_ESTOP_AUX2].p.write.mc.SERIALNUM;
      L #p.write.mc.RECIPE;
      T "idbDI1".f[#p.child.DI_ESTOP_AUX2].p.write.mc.RECIPE;
_childBatch_4:      NOP 0;

      A "alwaysHigh";
      JCN _childBatch_5;
      L #p.write.mc.SERIALNUM;
      T "idbDI1".f[#p.child.DI_ESTOP_AUX3].p.write.mc.SERIALNUM;
      L #p.write.mc.RECIPE;
      T "idbDI1".f[#p.child.DI_ESTOP_AUX3].p.write.mc.RECIPE;
_childBatch_5:      NOP 0;

      A "alwaysHigh";
      JCN _childBatch_6;
      L #p.write.mc.SERIALNUM;
      T "idbDI2".f[#p.child.DI_RELAY].p.write.mc.SERIALNUM;
      L #p.write.mc.RECIPE;
      T "idbDI2".f[#p.child.DI_RELAY].p.write.mc.RECIPE;
_childBatch_6:      NOP 0;

      A "alwaysHigh";
      JCN _childBatch_7;
      L #p.write.mc.SERIALNUM;
      T "idbEMA1".f[#p.child.EMA_VESSEL].p.write.mc.SERIALNUM;
      L #p.write.mc.RECIPE;
      T "idbEMA1".f[#p.child.EMA_VESSEL].p.write.mc.RECIPE;
_childBatch_7:      NOP 0;

      A "alwaysHigh";
      JCN _childBatch_8;
      L #p.write.mc.SERIALNUM;
      T "idbEMC1".f[#p.child.EMC_GAS].p.write.mc.SERIALNUM;
      L #p.write.mc.RECIPE;
      T "idbEMC1".f[#p.child.EMC_GAS].p.write.mc.RECIPE;
_childBatch_8:      NOP 0;

      A "alwaysHigh";
      JCN _childBatch_9;
      L #p.write.mc.SERIALNUM;
      T "idbEMC2".f[#p.child.EMC_WATER].p.write.mc.SERIALNUM;
      L #p.write.mc.RECIPE;
      T "idbEMC2".f[#p.child.EMC_WATER].p.write.mc.RECIPE;
_childBatch_9:      NOP 0;

      A "alwaysHigh";
      JCN _childBatch_10;
      L #p.write.mc.SERIALNUM;
      T "idbEMG1".f[#p.child.EMG_FILTER].p.write.mc.SERIALNUM;
      L #p.write.mc.RECIPE;
      T "idbEMG1".f[#p.child.EMG_FILTER].p.write.mc.RECIPE;
_childBatch_10:      NOP 0;

      A "alwaysHigh";
      JCN _childBatch_11;
      L #p.write.mc.SERIALNUM;
      T "idbEMM1".f[#p.child.EMM_VESSEL].p.write.mc.SERIALNUM;
      L #p.write.mc.RECIPE;
      T "idbEMM1".f[#p.child.EMM_VESSEL].p.write.mc.RECIPE;
_childBatch_11:      NOP 0;

      A "alwaysHigh";
      JCN _childBatch_12;
      L #p.write.mc.SERIALNUM;
      T "idbEMT1".f[#p.child.EMT_HEX].p.write.mc.SERIALNUM;
      L #p.write.mc.RECIPE;
      T "idbEMT1".f[#p.child.EMT_HEX].p.write.mc.RECIPE;
_childBatch_12:      NOP 0;

      A "alwaysHigh";
      JCN _childBatch_13;
      L #p.write.mc.SERIALNUM;
      T "idbEMV2".f[#p.child.EMV_INLET].p.write.mc.SERIALNUM;
      L #p.write.mc.RECIPE;
      T "idbEMV2".f[#p.child.EMV_INLET].p.write.mc.RECIPE;
_childBatch_13:      NOP 0;

      A "alwaysHigh";
      JCN _childBatch_14;
      L #p.write.mc.SERIALNUM;
      T "idbEMV1".f[#p.child.EMV_VESSEL].p.write.mc.SERIALNUM;
      L #p.write.mc.RECIPE;
      T "idbEMV1".f[#p.child.EMV_VESSEL].p.write.mc.RECIPE;
_childBatch_14:      NOP 0;

      A "alwaysHigh";
      JCN _childBatch_15;
      L #p.write.mc.SERIALNUM;
      T "idbEMX4".f[#p.child.EMX_DRAIN].p.write.mc.SERIALNUM;
      L #p.write.mc.RECIPE;
      T "idbEMX4".f[#p.child.EMX_DRAIN].p.write.mc.RECIPE;
_childBatch_15:      NOP 0;

      A #selected_FILL_FLZ.FL1;
      JCN _childBatch_16;
      L #p.write.mc.SERIALNUM;
      T "idbEMX5".f[#p.child.EMX_FILL1].p.write.mc.SERIALNUM;
      L #p.write.mc.RECIPE;
      T "idbEMX5".f[#p.child.EMX_FILL1].p.write.mc.RECIPE;
_childBatch_16:      NOP 0;

      A #selected_FILL_FLZ.FL2;
      JCN _childBatch_17;
      L #p.write.mc.SERIALNUM;
      T "idbEMX5".f[#p.child.EMX_FILL2].p.write.mc.SERIALNUM;
      L #p.write.mc.RECIPE;
      T "idbEMX5".f[#p.child.EMX_FILL2].p.write.mc.RECIPE;
_childBatch_17:      NOP 0;

      A "alwaysHigh";
      JCN _childBatch_18;
      L #p.write.mc.SERIALNUM;
      T "idbEMX1".f[#p.child.EMX_MMFL].p.write.mc.SERIALNUM;
      L #p.write.mc.RECIPE;
      T "idbEMX1".f[#p.child.EMX_MMFL].p.write.mc.RECIPE;
_childBatch_18:      NOP 0;

      O #selected_FILL_FLZ.FL1;
      O #selected_FILL_FLZ.FL2;
      O #selected_VESSEL_SY.S1;
      O #selected_VESSEL_SY.S2;
      JCN _childBatch_19;
      L #p.write.mc.SERIALNUM;
      T "idbEMX6".f[#p.child.EMX_SMFL].p.write.mc.SERIALNUM;
      L #p.write.mc.RECIPE;
      T "idbEMX6".f[#p.child.EMX_SMFL].p.write.mc.RECIPE;
_childBatch_19:      NOP 0;

      O #selected_FILL_FLZ.FL1;
      O #selected_FILL_FLZ.FL2;
      O #selected_VESSEL_SY.S1;
      O #selected_VESSEL_SY.S2;
      JCN _childBatch_20;
      L #p.write.mc.SERIALNUM;
      T "idbEMX4".f[#p.child.EMX_SMFLDRN].p.write.mc.SERIALNUM;
      L #p.write.mc.RECIPE;
      T "idbEMX4".f[#p.child.EMX_SMFLDRN].p.write.mc.RECIPE;
_childBatch_20:      NOP 0;

      A #selected_VESSEL_SY.S1;
      JCN _childBatch_21;
      L #p.write.mc.SERIALNUM;
      T "idbEMX2".f[#p.child.EMX_TRANSFER1].p.write.mc.SERIALNUM;
      L #p.write.mc.RECIPE;
      T "idbEMX2".f[#p.child.EMX_TRANSFER1].p.write.mc.RECIPE;
_childBatch_21:      NOP 0;

      A #selected_VESSEL_SY.S2;
      JCN _childBatch_22;
      L #p.write.mc.SERIALNUM;
      T "idbEMX2".f[#p.child.EMX_TRANSFER2].p.write.mc.SERIALNUM;
      L #p.write.mc.RECIPE;
      T "idbEMX2".f[#p.child.EMX_TRANSFER2].p.write.mc.RECIPE;
_childBatch_22:      NOP 0;


NETWORK
TITLE = Command child device EMA_VESSEL for initial TRUE command STOP
//------------------------------------------------------------------------//
// CHILD INITIAL TRUE COMMAND   CHILD INITIAL TRUE COMMAND   CHILD INITIA //
//                                                                        //
// Set the initial command values for the child devices.                  //
// Command the child device to its initial command if condition is true:  //
//------------------------------------------------------------------------//
      A "idbEMA1".f[#p.child.EMA_VESSEL].p.read.mc.modeAUTO;
      A(;
      O(;
      A #subsStart.CIP;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      O(;
      A #subsStart.FILL;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      O(;
      A #subsStart.FILTER;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      O(;
      A #subsStart.MAKE;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      O(;
      A #subsStart.SETUP;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      O(;
      A #subsStart.SIP;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      );
      JCN _childInitTrue_EMA_VESSEL_STOP;
      L "dbCONST".BLK.EMA1.CMD.STOP;
      T #p.write.EMA_VESSEL_CMD;
      T #childReqCMD.EMA_VESSEL;

_childInitTrue_EMA_VESSEL_STOP:      NOP 0;

NETWORK
TITLE = Command child device EMC_GAS for initial TRUE command STOP
//------------------------------------------------------------------------//
// CHILD INITIAL TRUE COMMAND   CHILD INITIAL TRUE COMMAND   CHILD INITIA //
//                                                                        //
// Set the initial command values for the child devices.                  //
// Command the child device to its initial command if condition is true:  //
//------------------------------------------------------------------------//
      A "idbEMC1".f[#p.child.EMC_GAS].p.read.mc.modeAUTO;
      A(;
      O(;
      A #subsStart.CIP;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      O(;
      A #subsStart.FILL;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      O(;
      A #subsStart.FILTER;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      O(;
      A #subsStart.MAKE;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      O(;
      A #subsStart.SETUP;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      O(;
      A #subsStart.SIP;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      );
      JCN _childInitTrue_EMC_GAS_STOP;
      L "dbCONST".BLK.EMC1.CMD.STOP;
      T #p.write.EMC_GAS_CMD;
      T #childReqCMD.EMC_GAS;

_childInitTrue_EMC_GAS_STOP:      NOP 0;

NETWORK
TITLE = Command child device EMC_WATER for initial TRUE command STOP
//------------------------------------------------------------------------//
// CHILD INITIAL TRUE COMMAND   CHILD INITIAL TRUE COMMAND   CHILD INITIA //
//                                                                        //
// Set the initial command values for the child devices.                  //
// Command the child device to its initial command if condition is true:  //
//------------------------------------------------------------------------//
      A "idbEMC2".f[#p.child.EMC_WATER].p.read.mc.modeAUTO;
      A(;
      O(;
      A #subsStart.CIP;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      O(;
      A #subsStart.FILL;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      O(;
      A #subsStart.FILTER;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      O(;
      A #subsStart.MAKE;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      O(;
      A #subsStart.SETUP;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      O(;
      A #subsStart.SIP;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      );
      JCN _childInitTrue_EMC_WATER_STOP;
      L "dbCONST".BLK.EMC2.CMD.STOP;
      T #p.write.EMC_WATER_CMD;
      T #childReqCMD.EMC_WATER;

_childInitTrue_EMC_WATER_STOP:      NOP 0;

NETWORK
TITLE = Command child device EMG_FILTER for initial TRUE command STOP
//------------------------------------------------------------------------//
// CHILD INITIAL TRUE COMMAND   CHILD INITIAL TRUE COMMAND   CHILD INITIA //
//                                                                        //
// Set the initial command values for the child devices.                  //
// Command the child device to its initial command if condition is true:  //
//------------------------------------------------------------------------//
      A "idbEMG1".f[#p.child.EMG_FILTER].p.read.mc.modeAUTO;
      A(;
      O(;
      A #subsStart.CIP;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      O(;
      A #subsStart.FILL;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      O(;
      A #subsStart.FILTER;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      O(;
      A #subsStart.MAKE;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      O(;
      A #subsStart.SETUP;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      O(;
      A #subsStart.SIP;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      );
      JCN _childInitTrue_EMG_FILTER_STOP;
      L "dbCONST".BLK.EMG1.CMD.STOP;
      T #p.write.EMG_FILTER_CMD;
      T #childReqCMD.EMG_FILTER;

_childInitTrue_EMG_FILTER_STOP:      NOP 0;

NETWORK
TITLE = Command child device EMM_VESSEL for initial TRUE command STOP
//------------------------------------------------------------------------//
// CHILD INITIAL TRUE COMMAND   CHILD INITIAL TRUE COMMAND   CHILD INITIA //
//                                                                        //
// Set the initial command values for the child devices.                  //
// Command the child device to its initial command if condition is true:  //
//------------------------------------------------------------------------//
      A "idbEMM1".f[#p.child.EMM_VESSEL].p.read.mc.modeAUTO;
      A(;
      O(;
      A #subsStart.CIP;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      O(;
      A #subsStart.FILL;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      O(;
      A #subsStart.FILTER;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      O(;
      A #subsStart.MAKE;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      O(;
      A #subsStart.SETUP;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      O(;
      A #subsStart.SIP;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      );
      JCN _childInitTrue_EMM_VESSEL_STOP;
      L "dbCONST".BLK.EMM1.CMD.STOP;
      T #p.write.EMM_VESSEL_CMD;
      T #childReqCMD.EMM_VESSEL;

_childInitTrue_EMM_VESSEL_STOP:      NOP 0;

NETWORK
TITLE = Command child device EMT_HEX for initial TRUE command STOP
//------------------------------------------------------------------------//
// CHILD INITIAL TRUE COMMAND   CHILD INITIAL TRUE COMMAND   CHILD INITIA //
//                                                                        //
// Set the initial command values for the child devices.                  //
// Command the child device to its initial command if condition is true:  //
//------------------------------------------------------------------------//
      A "idbEMT1".f[#p.child.EMT_HEX].p.read.mc.modeAUTO;
      A(;
      O(;
      A #subsStart.CIP;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      O(;
      A #subsStart.FILL;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      O(;
      A #subsStart.FILTER;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      O(;
      A #subsStart.MAKE;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      O(;
      A #subsStart.SETUP;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      O(;
      A #subsStart.SIP;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      );
      JCN _childInitTrue_EMT_HEX_STOP;
      L "dbCONST".BLK.EMT1.CMD.STOP;
      T #p.write.EMT_HEX_CMD;
      T #childReqCMD.EMT_HEX;

_childInitTrue_EMT_HEX_STOP:      NOP 0;

NETWORK
TITLE = Command child device EMV_INLET for initial TRUE command STOP
//------------------------------------------------------------------------//
// CHILD INITIAL TRUE COMMAND   CHILD INITIAL TRUE COMMAND   CHILD INITIA //
//                                                                        //
// Set the initial command values for the child devices.                  //
// Command the child device to its initial command if condition is true:  //
//------------------------------------------------------------------------//
      A "idbEMV2".f[#p.child.EMV_INLET].p.read.mc.modeAUTO;
      A(;
      O(;
      A #subsStart.CIP;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      O(;
      A #subsStart.FILL;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      O(;
      A #subsStart.FILTER;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      O(;
      A #subsStart.MAKE;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      O(;
      A #subsStart.SETUP;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      O(;
      A #subsStart.SIP;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      );
      JCN _childInitTrue_EMV_INLET_STOP;
      L "dbCONST".BLK.EMV2.CMD.STOP;
      T #p.write.EMV_INLET_CMD;
      T #childReqCMD.EMV_INLET;

_childInitTrue_EMV_INLET_STOP:      NOP 0;

NETWORK
TITLE = Command child device EMV_VESSEL for initial TRUE command STOP
//------------------------------------------------------------------------//
// CHILD INITIAL TRUE COMMAND   CHILD INITIAL TRUE COMMAND   CHILD INITIA //
//                                                                        //
// Set the initial command values for the child devices.                  //
// Command the child device to its initial command if condition is true:  //
//------------------------------------------------------------------------//
      A "idbEMV1".f[#p.child.EMV_VESSEL].p.read.mc.modeAUTO;
      A(;
      O(;
      A #subsStart.CIP;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      O(;
      A #subsStart.FILL;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      O(;
      A #subsStart.FILTER;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      O(;
      A #subsStart.MAKE;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      O(;
      A #subsStart.SETUP;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      O(;
      A #subsStart.SIP;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      );
      JCN _childInitTrue_EMV_VESSEL_STOP;
      L "dbCONST".BLK.EMV1.CMD.STOP;
      T #p.write.EMV_VESSEL_CMD;
      T #childReqCMD.EMV_VESSEL;

_childInitTrue_EMV_VESSEL_STOP:      NOP 0;

NETWORK
TITLE = Command child device EMX_DRAIN for initial TRUE command STOP
//------------------------------------------------------------------------//
// CHILD INITIAL TRUE COMMAND   CHILD INITIAL TRUE COMMAND   CHILD INITIA //
//                                                                        //
// Set the initial command values for the child devices.                  //
// Command the child device to its initial command if condition is true:  //
//------------------------------------------------------------------------//
      A "idbEMX4".f[#p.child.EMX_DRAIN].p.read.mc.modeAUTO;
      A(;
      O(;
      A #subsStart.CIP;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      O(;
      A #subsStart.FILL;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      O(;
      A #subsStart.FILTER;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      O(;
      A #subsStart.MAKE;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      O(;
      A #subsStart.SETUP;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      O(;
      A #subsStart.SIP;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      );
      JCN _childInitTrue_EMX_DRAIN_STOP;
      L "dbCONST".BLK.EMX4.CMD.STOP;
      T #p.write.EMX_DRAIN_CMD;
      T #childReqCMD.EMX_DRAIN;

_childInitTrue_EMX_DRAIN_STOP:      NOP 0;

NETWORK
TITLE = Command child device EMX_FILL1 for initial TRUE command STOP
//------------------------------------------------------------------------//
// CHILD INITIAL TRUE COMMAND   CHILD INITIAL TRUE COMMAND   CHILD INITIA //
//                                                                        //
// Set the initial command values for the child devices.                  //
// Command the child device to its initial command if condition is true:  //
//------------------------------------------------------------------------//
      A "idbEMX5".f[#p.child.EMX_FILL1].p.read.mc.modeAUTO;
      A(;
      O(;
      A #subsStart.CIP;
      A #selected_FILL_FLZ.FL1;
      A "alwaysLow";
      );
      O(;
      A #subsStart.FILL;
      A #selected_FILL_FLZ.FL1;
      A #selected_FILL_FLZ.FL1;
      );
      O(;
      A #subsStart.FILTER;
      A #selected_FILL_FLZ.FL1;
      A "alwaysLow";
      );
      O(;
      A #subsStart.MAKE;
      A #selected_FILL_FLZ.FL1;
      A #selected_FILL_FLZ.FL1;
      );
      O(;
      A #subsStart.SETUP;
      A #selected_FILL_FLZ.FL1;
      A #selected_FILL_FLZ.FL1;
      );
      O(;
      A #subsStart.SIP;
      A #selected_FILL_FLZ.FL1;
      A #selected_FILL_FLZ.FL1;
      );
      );
      JCN _childInitTrue_EMX_FILL1_STOP;
      L "dbCONST".BLK.EMX5.CMD.STOP;
      T #p.write.EMX_FILL1_CMD;
      T #childReqCMD.EMX_FILL1;

_childInitTrue_EMX_FILL1_STOP:      NOP 0;

NETWORK
TITLE = Command child device EMX_FILL2 for initial TRUE command STOP
//------------------------------------------------------------------------//
// CHILD INITIAL TRUE COMMAND   CHILD INITIAL TRUE COMMAND   CHILD INITIA //
//                                                                        //
// Set the initial command values for the child devices.                  //
// Command the child device to its initial command if condition is true:  //
//------------------------------------------------------------------------//
      A "idbEMX5".f[#p.child.EMX_FILL2].p.read.mc.modeAUTO;
      A(;
      O(;
      A #subsStart.CIP;
      A #selected_FILL_FLZ.FL2;
      A "alwaysLow";
      );
      O(;
      A #subsStart.FILL;
      A #selected_FILL_FLZ.FL2;
      A #selected_FILL_FLZ.FL2;
      );
      O(;
      A #subsStart.FILTER;
      A #selected_FILL_FLZ.FL2;
      A "alwaysLow";
      );
      O(;
      A #subsStart.MAKE;
      A #selected_FILL_FLZ.FL2;
      A #selected_FILL_FLZ.FL2;
      );
      O(;
      A #subsStart.SETUP;
      A #selected_FILL_FLZ.FL2;
      A #selected_FILL_FLZ.FL2;
      );
      O(;
      A #subsStart.SIP;
      A #selected_FILL_FLZ.FL2;
      A #selected_FILL_FLZ.FL2;
      );
      );
      JCN _childInitTrue_EMX_FILL2_STOP;
      L "dbCONST".BLK.EMX5.CMD.STOP;
      T #p.write.EMX_FILL2_CMD;
      T #childReqCMD.EMX_FILL2;

_childInitTrue_EMX_FILL2_STOP:      NOP 0;

NETWORK
TITLE = Command child device EMX_MMFL for initial TRUE command STOP
//------------------------------------------------------------------------//
// CHILD INITIAL TRUE COMMAND   CHILD INITIAL TRUE COMMAND   CHILD INITIA //
//                                                                        //
// Set the initial command values for the child devices.                  //
// Command the child device to its initial command if condition is true:  //
//------------------------------------------------------------------------//
      A "idbEMX1".f[#p.child.EMX_MMFL].p.read.mc.modeAUTO;
      A(;
      O(;
      A #subsStart.CIP;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      O(;
      A #subsStart.FILL;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      O(;
      A #subsStart.FILTER;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      O(;
      A #subsStart.MAKE;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      O(;
      A #subsStart.SETUP;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      O(;
      A #subsStart.SIP;
      A "alwaysHigh";
      A "alwaysHigh";
      );
      );
      JCN _childInitTrue_EMX_MMFL_STOP;
      L "dbCONST".BLK.EMX1.CMD.STOP;
      T #p.write.EMX_MMFL_CMD;
      T #childReqCMD.EMX_MMFL;

_childInitTrue_EMX_MMFL_STOP:      NOP 0;

NETWORK
TITLE = Command child device EMX_SMFL for initial TRUE command STOP
//------------------------------------------------------------------------//
// CHILD INITIAL TRUE COMMAND   CHILD INITIAL TRUE COMMAND   CHILD INITIA //
//                                                                        //
// Set the initial command values for the child devices.                  //
// Command the child device to its initial command if condition is true:  //
//------------------------------------------------------------------------//
      A "idbEMX6".f[#p.child.EMX_SMFL].p.read.mc.modeAUTO;
      A(;
      O(;
      A #subsStart.CIP;
      O #selected_FILL_FLZ.FL1;
      O #selected_FILL_FLZ.FL2;
      O #selected_VESSEL_SY.S1;
      O #selected_VESSEL_SY.S2;
      A "alwaysLow";
      );
      O(;
      A #subsStart.FILL;
      O #selected_FILL_FLZ.FL1;
      O #selected_FILL_FLZ.FL2;
      O #selected_VESSEL_SY.S1;
      O #selected_VESSEL_SY.S2;
      A "alwaysHigh";
      );
      O(;
      A #subsStart.FILTER;
      O #selected_FILL_FLZ.FL1;
      O #selected_FILL_FLZ.FL2;
      O #selected_VESSEL_SY.S1;
      O #selected_VESSEL_SY.S2;
      A "alwaysHigh";
      );
      O(;
      A #subsStart.MAKE;
      O #selected_FILL_FLZ.FL1;
      O #selected_FILL_FLZ.FL2;
      O #selected_VESSEL_SY.S1;
      O #selected_VESSEL_SY.S2;
      A "alwaysLow";
      );
      O(;
      A #subsStart.SETUP;
      O #selected_FILL_FLZ.FL1;
      O #selected_FILL_FLZ.FL2;
      O #selected_VESSEL_SY.S1;
      O #selected_VESSEL_SY.S2;
      A "alwaysLow";
      );
      O(;
      A #subsStart.SIP;
      O #selected_FILL_FLZ.FL1;
      O #selected_FILL_FLZ.FL2;
      O #selected_VESSEL_SY.S1;
      O #selected_VESSEL_SY.S2;
      A "alwaysLow";
      );
      );
      JCN _childInitTrue_EMX_SMFL_STOP;
      L "dbCONST".BLK.EMX6.CMD.STOP;
      T #p.write.EMX_SMFL_CMD;
      T #childReqCMD.EMX_SMFL;

_childInitTrue_EMX_SMFL_STOP:      NOP 0;

NETWORK
TITLE = Command child device EMX_SMFLDRN for initial TRUE command STOP
//------------------------------------------------------------------------//
// CHILD INITIAL TRUE COMMAND   CHILD INITIAL TRUE COMMAND   CHILD INITIA //
//                                                                        //
// Set the initial command values for the child devices.                  //
// Command the child device to its initial command if condition is true:  //
//------------------------------------------------------------------------//
      A "idbEMX4".f[#p.child.EMX_SMFLDRN].p.read.mc.modeAUTO;
      A(;
      O(;
      A #subsStart.CIP;
      O #selected_FILL_FLZ.FL1;
      O #selected_FILL_FLZ.FL2;
      O #selected_VESSEL_SY.S1;
      O #selected_VESSEL_SY.S2;
      A "alwaysLow";
      );
      O(;
      A #subsStart.FILL;
      O #selected_FILL_FLZ.FL1;
      O #selected_FILL_FLZ.FL2;
      O #selected_VESSEL_SY.S1;
      O #selected_VESSEL_SY.S2;
      A "alwaysHigh";
      );
      O(;
      A #subsStart.FILTER;
      O #selected_FILL_FLZ.FL1;
      O #selected_FILL_FLZ.FL2;
      O #selected_VESSEL_SY.S1;
      O #selected_VESSEL_SY.S2;
      A "alwaysHigh";
      );
      O(;
      A #subsStart.MAKE;
      O #selected_FILL_FLZ.FL1;
      O #selected_FILL_FLZ.FL2;
      O #selected_VESSEL_SY.S1;
      O #selected_VESSEL_SY.S2;
      A "alwaysLow";
      );
      O(;
      A #subsStart.SETUP;
      O #selected_FILL_FLZ.FL1;
      O #selected_FILL_FLZ.FL2;
      O #selected_VESSEL_SY.S1;
      O #selected_VESSEL_SY.S2;
      A "alwaysLow";
      );
      O(;
      A #subsStart.SIP;
      O #selected_FILL_FLZ.FL1;
      O #selected_FILL_FLZ.FL2;
      O #selected_VESSEL_SY.S1;
      O #selected_VESSEL_SY.S2;
      A "alwaysLow";
      );
      );
      JCN _childInitTrue_EMX_SMFLDRN_STOP;
      L "dbCONST".BLK.EMX4.CMD.STOP;
      T #p.write.EMX_SMFLDRN_CMD;
      T #childReqCMD.EMX_SMFLDRN;

_childInitTrue_EMX_SMFLDRN_STOP:      NOP 0;

NETWORK
TITLE = Command child device EMX_TRANSFER1 for initial TRUE command STOP
//------------------------------------------------------------------------//
// CHILD INITIAL TRUE COMMAND   CHILD INITIAL TRUE COMMAND   CHILD INITIA //
//                                                                        //
// Set the initial command values for the child devices.                  //
// Command the child device to its initial command if condition is true:  //
//------------------------------------------------------------------------//
      A "idbEMX2".f[#p.child.EMX_TRANSFER1].p.read.mc.modeAUTO;
      A(;
      O(;
      A #subsStart.CIP;
      A #selected_VESSEL_SY.S1;
      A "alwaysLow";
      );
      O(;
      A #subsStart.FILL;
      A #selected_VESSEL_SY.S1;
      A #selected_VESSEL_SY.S1;
      );
      O(;
      A #subsStart.FILTER;
      A #selected_VESSEL_SY.S1;
      A #selected_VESSEL_SY.S1;
      );
      O(;
      A #subsStart.MAKE;
      A #selected_VESSEL_SY.S1;
      A #selected_VESSEL_SY.S1;
      );
      O(;
      A #subsStart.SETUP;
      A #selected_VESSEL_SY.S1;
      A #selected_VESSEL_SY.S1;
      );
      O(;
      A #subsStart.SIP;
      A #selected_VESSEL_SY.S1;
      A #selected_VESSEL_SY.S1;
      );
      );
      JCN _childInitTrue_EMX_TRANSFER1_STOP;
      L "dbCONST".BLK.EMX2.CMD.STOP;
      T #p.write.EMX_TRANSFER1_CMD;
      T #childReqCMD.EMX_TRANSFER1;

_childInitTrue_EMX_TRANSFER1_STOP:      NOP 0;

NETWORK
TITLE = Command child device EMX_TRANSFER2 for initial TRUE command STOP
//------------------------------------------------------------------------//
// CHILD INITIAL TRUE COMMAND   CHILD INITIAL TRUE COMMAND   CHILD INITIA //
//                                                                        //
// Set the initial command values for the child devices.                  //
// Command the child device to its initial command if condition is true:  //
//------------------------------------------------------------------------//
      A "idbEMX2".f[#p.child.EMX_TRANSFER2].p.read.mc.modeAUTO;
      A(;
      O(;
      A #subsStart.CIP;
      A #selected_VESSEL_SY.S2;
      A "alwaysLow";
      );
      O(;
      A #subsStart.FILL;
      A #selected_VESSEL_SY.S2;
      A #selected_VESSEL_SY.S2;
      );
      O(;
      A #subsStart.FILTER;
      A #selected_VESSEL_SY.S2;
      A #selected_VESSEL_SY.S2;
      );
      O(;
      A #subsStart.MAKE;
      A #selected_VESSEL_SY.S2;
      A #selected_VESSEL_SY.S2;
      );
      O(;
      A #subsStart.SETUP;
      A #selected_VESSEL_SY.S2;
      A #selected_VESSEL_SY.S2;
      );
      O(;
      A #subsStart.SIP;
      A #selected_VESSEL_SY.S2;
      A #selected_VESSEL_SY.S2;
      );
      );
      JCN _childInitTrue_EMX_TRANSFER2_STOP;
      L "dbCONST".BLK.EMX2.CMD.STOP;
      T #p.write.EMX_TRANSFER2_CMD;
      T #childReqCMD.EMX_TRANSFER2;

_childInitTrue_EMX_TRANSFER2_STOP:      NOP 0;




NETWORK
TITLE = Set recipe parameters if starting UO_MX_CIP running SUBSTATE
//------------------------------------------------------------------------//
// Set recipe parameters:                                                 //
//------------------------------------------------------------------------//
      A #subsStart.CIP;
      JCN _noStaticParms_CIP;
      L #p.write.R_AGIT_SETPOINT;
      T #UO_MX_CIP._r_agit_setpoint;
      L #p.write.R_MASS_PW_FLOOD;
      T #UO_MX_CIP._r_mass_pw_flood;
      L #p.write.R_PRES_GAS_EMPTY;
      T #UO_MX_CIP._r_pres_gas_empty;
      L #p.write.R_PRES_GAS_WASH;
      T #UO_MX_CIP._r_pres_gas_wash;
      L #p.write.R_TIME_AGIT_CLEAN;
      T #UO_MX_CIP._r_time_agit_clean;
      L #p.write.R_TIME_MEASURE_SETTLING;
      T #UO_MX_CIP._r_time_measure_settling;
      L #p.write.R_TIME_PW_EMPTY1;
      T #UO_MX_CIP._r_time_pw_empty1;
      L #p.write.R_TIME_PW_EMPTY2;
      T #UO_MX_CIP._r_time_pw_empty2;
      L #p.write.R_TIME_PW_FLOOD;
      T #UO_MX_CIP._r_time_pw_flood;
      L #p.write.R_TIME_PW_FLUSH_MX;
      T #UO_MX_CIP._r_time_pw_flush_mx;
      L #p.write.R_TIME_PW_STEAM_MX;
      T #UO_MX_CIP._r_time_pw_steam_mx;
      L #p.write.R_TIME_PW_WASH_MMFLX;
      T #UO_MX_CIP._r_time_pw_wash_mmflx;
      L #p.write.R_TIME_PW_WASH_MX;
      T #UO_MX_CIP._r_time_pw_wash_mx;
      L #p.write.R_TIME_SPRAYBALL_OPENED;
      T #UO_MX_CIP._r_time_sprayball_opened;
      L #p.write.R_TIME_WFI_EMPTY_MX;
      T #UO_MX_CIP._r_time_wfi_empty_mx;
      L #p.write.R_TIME_WFI_RINSE_MMFLX;
      T #UO_MX_CIP._r_time_wfi_rinse_mmflx;
      L #p.write.R_TIME_WFI_RINSE_MX;
      T #UO_MX_CIP._r_time_wfi_rinse_mx;

_noStaticParms_CIP:      NOP 0;
NETWORK
TITLE = Set recipe parameters if starting UO_MX_FILL running SUBSTATE
//------------------------------------------------------------------------//
// Set recipe parameters:                                                 //
//------------------------------------------------------------------------//
      A #subsStart.FILL;
      JCN _noStaticParms_FILL;
      L #p.write.R_MASS_THROTTLE;
      T #UO_MX_FILL._r_mass_throttle;
      L #p.write.R_PRES_HPCA_FILT;
      T #UO_MX_FILL._r_pres_hpca_filt;
      L #p.write.R_PRES_HPCA_FILT2;
      T #UO_MX_FILL._r_pres_hpca_filt2;
      L #p.write.R_PRES_LPCA_BLANKET;
      T #UO_MX_FILL._r_pres_lpca_blanket;
      L #p.write.R_TEMP_FILT;
      T #UO_MX_FILL._r_temp_filt;

_noStaticParms_FILL:      NOP 0;
NETWORK
TITLE = Set recipe parameters if starting UO_MX_FILTER running SUBSTATE
//------------------------------------------------------------------------//
// Set recipe parameters:                                                 //
//------------------------------------------------------------------------//
      A #subsStart.FILTER;
      JCN _noStaticParms_FILTER;
      L #p.write.R_MASS_EXPECT_REDUCED;
      T #UO_MX_FILTER._r_mass_expect_reduced;
      L #p.write.R_MASS_THROTTLE_MX;
      T #UO_MX_FILTER._r_mass_throttle_mx;
      L #p.write.R_PRES_HPCA_FILT;
      T #UO_MX_FILTER._r_pres_hpca_filt;
      L #p.write.R_PRES_HPCA_FILT2;
      T #UO_MX_FILTER._r_pres_hpca_filt2;
      L #p.write.R_PRES_LPCA_BLANKET;
      T #UO_MX_FILTER._r_pres_lpca_blanket;
      L #p.write.R_TEMP_LIMIT_H;
      T #UO_MX_FILTER._r_temp_limit_h;
      L #p.write.R_TEMP_LIMIT_HH;
      T #UO_MX_FILTER._r_temp_limit_hh;
      L #p.write.R_TIME_MASS_REDUCE;
      T #UO_MX_FILTER._r_time_mass_reduce;

_noStaticParms_FILTER:      NOP 0;
NETWORK
TITLE = Set recipe parameters if starting UO_MX_MAKE running SUBSTATE
//------------------------------------------------------------------------//
// Set recipe parameters:                                                 //
//------------------------------------------------------------------------//
      A #subsStart.MAKE;
      JCN _noStaticParms_MAKE;
      L #p.write.R_PRES_LPCA_MAKE;
      T #UO_MX_MAKE._r_pres_lpca_make;
      L #p.write.R_TIME_MEASURE_SETTLING;
      T #UO_MX_MAKE._r_time_measure_settling;

_noStaticParms_MAKE:      NOP 0;
NETWORK
TITLE = Set recipe parameters if starting UO_MX_SETUP running SUBSTATE
//------------------------------------------------------------------------//
// Set recipe parameters:                                                 //
//------------------------------------------------------------------------//
      A #subsStart.SETUP;
      JCN _noStaticParms_SETUP;
      L #p.write.R_PRES_VAC;
      T #UO_MX_SETUP._r_pres_vac;
      L #p.write.R_PRES_VAC_FAIL;
      T #UO_MX_SETUP._r_pres_vac_fail;
      L #p.write.R_TIME_EJECT;
      T #UO_MX_SETUP._r_time_eject;
      L #p.write.R_TIME_HEX_DRAIN;
      T #UO_MX_SETUP._r_time_hex_drain;
      L #p.write.R_TIME_VAC_HOLD;
      T #UO_MX_SETUP._r_time_vac_hold;

_noStaticParms_SETUP:      NOP 0;
NETWORK
TITLE = Set recipe parameters if starting UO_MX_SIP running SUBSTATE
//------------------------------------------------------------------------//
// Set recipe parameters:                                                 //
//------------------------------------------------------------------------//
      A #subsStart.SIP;
      JCN _noStaticParms_SIP;
      L #p.write.R_NUM_SIP_ABORT;
      T #UO_MX_SIP._r_num_sip_abort;
      L #p.write.R_PRES_HPCA_BLOW;
      T #UO_MX_SIP._r_pres_hpca_blow;
      L #p.write.R_PRES_HPCA_LEAVE;
      T #UO_MX_SIP._r_pres_hpca_leave;
      L #p.write.R_PRES_LPCA_BLANKET;
      T #UO_MX_SIP._r_pres_lpca_blanket;
      L #p.write.R_PRES_STM_POS;
      T #UO_MX_SIP._r_pres_stm_pos;
      L #p.write.R_PRES_VAC;
      T #UO_MX_SIP._r_pres_vac;
      L #p.write.R_PULSE_NUMBER;
      T #UO_MX_SIP._r_pulse_number;
      L #p.write.R_TEMP_SIP;
      T #UO_MX_SIP._r_temp_sip;
      L #p.write.R_TEMP_SIP_VENT;
      T #UO_MX_SIP._r_temp_sip_vent;
      L #p.write.R_TIME_DRAIN_PULSE;
      T #UO_MX_SIP._r_time_drain_pulse;
      L #p.write.R_TIME_EJECT;
      T #UO_MX_SIP._r_time_eject;
      L #p.write.R_TIME_SIP;
      T #UO_MX_SIP._r_time_sip;
      L #p.write.R_TIME_SIP_ABORT;
      T #UO_MX_SIP._r_time_sip_abort;
      L #p.write.R_TIME_STM_DRAIN_MX;
      T #UO_MX_SIP._r_time_stm_drain_mx;

_noStaticParms_SIP:      NOP 0;

NETWORK
TITLE = Clear the operator prompt cancel flags
//------------------------------------------------------------------------//
// Clear the SFC prompt cancel flags:                                     //
//------------------------------------------------------------------------//
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_1].cancel1;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_1].cancel2;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_1].cancel3;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_1].cancel4;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_1].cancel5;

      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_2].cancel1;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_2].cancel2;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_2].cancel3;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_2].cancel4;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_2].cancel5;

      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_3].cancel1;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_3].cancel2;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_3].cancel3;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_3].cancel4;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_3].cancel5;

      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_4].cancel1;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_4].cancel2;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_4].cancel3;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_4].cancel4;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_4].cancel5;

      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_5].cancel1;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_5].cancel2;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_5].cancel3;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_5].cancel4;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_5].cancel5;

      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_6].cancel1;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_6].cancel2;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_6].cancel3;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_6].cancel4;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_6].cancel5;

      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_7].cancel1;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_7].cancel2;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_7].cancel3;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_7].cancel4;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_7].cancel5;

      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_8].cancel1;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_8].cancel2;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_8].cancel3;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_8].cancel4;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_8].cancel5;

      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_9].cancel1;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_9].cancel2;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_9].cancel3;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_9].cancel4;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_9].cancel5;

      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_10].cancel1;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_10].cancel2;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_10].cancel3;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_10].cancel4;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_10].cancel5;

      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_11].cancel1;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_11].cancel2;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_11].cancel3;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_11].cancel4;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_11].cancel5;

      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_12].cancel1;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_12].cancel2;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_12].cancel3;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_12].cancel4;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_12].cancel5;


NETWORK
TITLE = Start the SFC sequence UO_MX_CIP in Auto for running substate CIP
//------------------------------------------------------------------------//
// START SFC   START SFC   START SFC   START SFC   START SFC   START SFC  //
//                                                                        //
// Start the running substate SFC.                                        //
//                                                                        //
// Set the running substate SFC to AUTO mode and start it:                //
//------------------------------------------------------------------------//
      A #subsStart.CIP;
      JCN _notSFCStarting_CIP;
      L "dbCONST".SEQ.MODE.AUTO;
      T #UO_MX_CIP.smc.MODE;
      L "dbCONST".SEQ.CMD.START;
      T #UO_MX_CIP.smc.SQ_CMD;
      L 0;
      T #UO_MX_CIP.sqSequencer.CMD.Old;

_notSFCStarting_CIP:      NOP 0;
NETWORK
TITLE = Start the SFC sequence UO_MX_FILL in Auto for running substate FILL
//------------------------------------------------------------------------//
// START SFC   START SFC   START SFC   START SFC   START SFC   START SFC  //
//                                                                        //
// Start the running substate SFC.                                        //
//                                                                        //
// Set the running substate SFC to AUTO mode and start it:                //
//------------------------------------------------------------------------//
      A #subsStart.FILL;
      JCN _notSFCStarting_FILL;
      L "dbCONST".SEQ.MODE.AUTO;
      T #UO_MX_FILL.smc.MODE;
      L "dbCONST".SEQ.CMD.START;
      T #UO_MX_FILL.smc.SQ_CMD;
      L 0;
      T #UO_MX_FILL.sqSequencer.CMD.Old;

_notSFCStarting_FILL:      NOP 0;
NETWORK
TITLE = Start the SFC sequence UO_MX_FILTER in Auto for running substate FILTER
//------------------------------------------------------------------------//
// START SFC   START SFC   START SFC   START SFC   START SFC   START SFC  //
//                                                                        //
// Start the running substate SFC.                                        //
//                                                                        //
// Set the running substate SFC to AUTO mode and start it:                //
//------------------------------------------------------------------------//
      A #subsStart.FILTER;
      JCN _notSFCStarting_FILTER;
      L "dbCONST".SEQ.MODE.AUTO;
      T #UO_MX_FILTER.smc.MODE;
      L "dbCONST".SEQ.CMD.START;
      T #UO_MX_FILTER.smc.SQ_CMD;
      L 0;
      T #UO_MX_FILTER.sqSequencer.CMD.Old;

_notSFCStarting_FILTER:      NOP 0;
NETWORK
TITLE = Start the SFC sequence UO_MX_MAKE in Auto for running substate MAKE
//------------------------------------------------------------------------//
// START SFC   START SFC   START SFC   START SFC   START SFC   START SFC  //
//                                                                        //
// Start the running substate SFC.                                        //
//                                                                        //
// Set the running substate SFC to AUTO mode and start it:                //
//------------------------------------------------------------------------//
      A #subsStart.MAKE;
      JCN _notSFCStarting_MAKE;
      L "dbCONST".SEQ.MODE.AUTO;
      T #UO_MX_MAKE.smc.MODE;
      L "dbCONST".SEQ.CMD.START;
      T #UO_MX_MAKE.smc.SQ_CMD;
      L 0;
      T #UO_MX_MAKE.sqSequencer.CMD.Old;

_notSFCStarting_MAKE:      NOP 0;
NETWORK
TITLE = Start the SFC sequence UO_MX_SETUP in Auto for running substate SETUP
//------------------------------------------------------------------------//
// START SFC   START SFC   START SFC   START SFC   START SFC   START SFC  //
//                                                                        //
// Start the running substate SFC.                                        //
//                                                                        //
// Set the running substate SFC to AUTO mode and start it:                //
//------------------------------------------------------------------------//
      A #subsStart.SETUP;
      JCN _notSFCStarting_SETUP;
      L "dbCONST".SEQ.MODE.AUTO;
      T #UO_MX_SETUP.smc.MODE;
      L "dbCONST".SEQ.CMD.START;
      T #UO_MX_SETUP.smc.SQ_CMD;
      L 0;
      T #UO_MX_SETUP.sqSequencer.CMD.Old;

_notSFCStarting_SETUP:      NOP 0;
NETWORK
TITLE = Start the SFC sequence UO_MX_SIP in Auto for running substate SIP
//------------------------------------------------------------------------//
// START SFC   START SFC   START SFC   START SFC   START SFC   START SFC  //
//                                                                        //
// Start the running substate SFC.                                        //
//                                                                        //
// Set the running substate SFC to AUTO mode and start it:                //
//------------------------------------------------------------------------//
      A #subsStart.SIP;
      JCN _notSFCStarting_SIP;
      L "dbCONST".SEQ.MODE.AUTO;
      T #UO_MX_SIP.smc.MODE;
      L "dbCONST".SEQ.CMD.START;
      T #UO_MX_SIP.smc.SQ_CMD;
      L 0;
      T #UO_MX_SIP.sqSequencer.CMD.Old;

_notSFCStarting_SIP:      NOP 0;

NETWORK
TITLE = Arm flowpath devices
//------------------------------------------------------------------------//
// Arm any flowpath child devices:                                        //
//------------------------------------------------------------------------//
      A "alwaysHigh";
      JCN _noArm_EMA_VESSEL;
      S "idbEMA1".f[#p.child.EMA_VESSEL].p.write.mc.ARMED;
_noArm_EMA_VESSEL:      NOP 0;

      A "alwaysHigh";
      JCN _noArm_EMC_GAS;
      S "idbEMC1".f[#p.child.EMC_GAS].p.write.mc.ARMED;
_noArm_EMC_GAS:      NOP 0;

      A "alwaysHigh";
      JCN _noArm_EMC_WATER;
      S "idbEMC2".f[#p.child.EMC_WATER].p.write.mc.ARMED;
_noArm_EMC_WATER:      NOP 0;

      A "alwaysHigh";
      JCN _noArm_EMG_FILTER;
      S "idbEMG1".f[#p.child.EMG_FILTER].p.write.mc.ARMED;
_noArm_EMG_FILTER:      NOP 0;

      A "alwaysHigh";
      JCN _noArm_EMM_VESSEL;
      S "idbEMM1".f[#p.child.EMM_VESSEL].p.write.mc.ARMED;
_noArm_EMM_VESSEL:      NOP 0;

      A "alwaysHigh";
      JCN _noArm_EMT_HEX;
      S "idbEMT1".f[#p.child.EMT_HEX].p.write.mc.ARMED;
_noArm_EMT_HEX:      NOP 0;

      A "alwaysHigh";
      JCN _noArm_EMV_INLET;
      S "idbEMV2".f[#p.child.EMV_INLET].p.write.mc.ARMED;
_noArm_EMV_INLET:      NOP 0;

      A "alwaysHigh";
      JCN _noArm_EMV_VESSEL;
      S "idbEMV1".f[#p.child.EMV_VESSEL].p.write.mc.ARMED;
_noArm_EMV_VESSEL:      NOP 0;

      A "alwaysHigh";
      JCN _noArm_EMX_DRAIN;
      S "idbEMX4".f[#p.child.EMX_DRAIN].p.write.mc.ARMED;
_noArm_EMX_DRAIN:      NOP 0;

      A #selected_FILL_FLZ.FL1;
      JCN _noArm_EMX_FILL1;
      S "idbEMX5".f[#p.child.EMX_FILL1].p.write.mc.ARMED;
_noArm_EMX_FILL1:      NOP 0;

      A #selected_FILL_FLZ.FL2;
      JCN _noArm_EMX_FILL2;
      S "idbEMX5".f[#p.child.EMX_FILL2].p.write.mc.ARMED;
_noArm_EMX_FILL2:      NOP 0;

      A "alwaysHigh";
      JCN _noArm_EMX_MMFL;
      S "idbEMX1".f[#p.child.EMX_MMFL].p.write.mc.ARMED;
_noArm_EMX_MMFL:      NOP 0;

      O #selected_FILL_FLZ.FL1;
      O #selected_FILL_FLZ.FL2;
      O #selected_VESSEL_SY.S1;
      O #selected_VESSEL_SY.S2;
      JCN _noArm_EMX_SMFL;
      S "idbEMX6".f[#p.child.EMX_SMFL].p.write.mc.ARMED;
_noArm_EMX_SMFL:      NOP 0;

      O #selected_FILL_FLZ.FL1;
      O #selected_FILL_FLZ.FL2;
      O #selected_VESSEL_SY.S1;
      O #selected_VESSEL_SY.S2;
      JCN _noArm_EMX_SMFLDRN;
      S "idbEMX4".f[#p.child.EMX_SMFLDRN].p.write.mc.ARMED;
_noArm_EMX_SMFLDRN:      NOP 0;

      A #selected_VESSEL_SY.S1;
      JCN _noArm_EMX_TRANSFER1;
      S "idbEMX2".f[#p.child.EMX_TRANSFER1].p.write.mc.ARMED;
_noArm_EMX_TRANSFER1:      NOP 0;

      A #selected_VESSEL_SY.S2;
      JCN _noArm_EMX_TRANSFER2;
      S "idbEMX2".f[#p.child.EMX_TRANSFER2].p.write.mc.ARMED;
_noArm_EMX_TRANSFER2:      NOP 0;


      SET;
      JC _switch_end;

  //------------------------------------------------------------------------//
  // SWITCH   SWITCH   SWITCH   SWITCH   SWITCH   SWITCH   SWITCH   SWITCH  //
  // STOPPING   STOPPING   STOPPING   STOPPING   STOPPING   STOPPING   STOP //
  // STOPPING   STOPPING   STOPPING   STOPPING   STOPPING   STOPPING   STOP //
  //------------------------------------------------------------------------//
_state_STOPPING:      NOP 0;

      SET;
      JC _switch_end;

  //------------------------------------------------------------------------//
  // SWITCH   SWITCH   SWITCH   SWITCH   SWITCH   SWITCH   SWITCH   SWITCH  //
  // RUNNING   RUNNING   RUNNING   RUNNING   RUNNING   RUNNING   RUNNING    //
  // RUNNING   RUNNING   RUNNING   RUNNING   RUNNING   RUNNING   RUNNING    //
  //------------------------------------------------------------------------//
_state_RUNNING:      NOP 0;

NETWORK
TITLE = RUNNING RUNNING RUNNING Interlock pauses the running SFC
//------------------------------------------------------------------------//
// Pause the running SFC sequence if any interlock or failure condition:  //
//------------------------------------------------------------------------//
      AN #cmdSTOPPED;
      AN #p.read.bmc.permitStart;
      A #subsRunning.CIP;
      JCN _ilSFC_1;
      L "dbCONST".SEQ.CMD.PAUSE;
      T #UO_MX_CIP.smc.SQ_CMD;
_ilSFC_1:      NOP 0;

NETWORK
TITLE = RUNNING RUNNING RUNNING Interlock pauses the running SFC
//------------------------------------------------------------------------//
// Pause the running SFC sequence if any interlock or failure condition:  //
//------------------------------------------------------------------------//
      AN #cmdSTOPPED;
      AN #p.read.bmc.permitStart;
      A #subsRunning.FILL;
      JCN _ilSFC_2;
      L "dbCONST".SEQ.CMD.PAUSE;
      T #UO_MX_FILL.smc.SQ_CMD;
_ilSFC_2:      NOP 0;

NETWORK
TITLE = RUNNING RUNNING RUNNING Interlock pauses the running SFC
//------------------------------------------------------------------------//
// Pause the running SFC sequence if any interlock or failure condition:  //
//------------------------------------------------------------------------//
      AN #cmdSTOPPED;
      AN #p.read.bmc.permitStart;
      A #subsRunning.FILTER;
      JCN _ilSFC_3;
      L "dbCONST".SEQ.CMD.PAUSE;
      T #UO_MX_FILTER.smc.SQ_CMD;
_ilSFC_3:      NOP 0;

NETWORK
TITLE = RUNNING RUNNING RUNNING Interlock pauses the running SFC
//------------------------------------------------------------------------//
// Pause the running SFC sequence if any interlock or failure condition:  //
//------------------------------------------------------------------------//
      AN #cmdSTOPPED;
      AN #p.read.bmc.permitStart;
      A #subsRunning.MAKE;
      JCN _ilSFC_4;
      L "dbCONST".SEQ.CMD.PAUSE;
      T #UO_MX_MAKE.smc.SQ_CMD;
_ilSFC_4:      NOP 0;

NETWORK
TITLE = RUNNING RUNNING RUNNING Interlock pauses the running SFC
//------------------------------------------------------------------------//
// Pause the running SFC sequence if any interlock or failure condition:  //
//------------------------------------------------------------------------//
      AN #cmdSTOPPED;
      AN #p.read.bmc.permitStart;
      A #subsRunning.SETUP;
      JCN _ilSFC_5;
      L "dbCONST".SEQ.CMD.PAUSE;
      T #UO_MX_SETUP.smc.SQ_CMD;
_ilSFC_5:      NOP 0;

NETWORK
TITLE = RUNNING RUNNING RUNNING Interlock pauses the running SFC
//------------------------------------------------------------------------//
// Pause the running SFC sequence if any interlock or failure condition:  //
//------------------------------------------------------------------------//
      AN #cmdSTOPPED;
      AN #p.read.bmc.permitStart;
      A #subsRunning.SIP;
      JCN _ilSFC_6;
      L "dbCONST".SEQ.CMD.PAUSE;
      T #UO_MX_SIP.smc.SQ_CMD;
_ilSFC_6:      NOP 0;


NETWORK
TITLE = Set child selection commands
//------------------------------------------------------------------------//
// Set the child selection command:                                       //
//------------------------------------------------------------------------//
      L #p.select.EMX_FILL_CMD;
      T #p.write.EMX_FILL1_CMD;
      T #p.write.EMX_FILL2_CMD;
      L #p.select.EMX_FILL_SUBS;
      T #p.write.EMX_FILL1_SUBS;
      T #p.write.EMX_FILL2_SUBS;
      L #p.select.EMX_TRANSFER_CMD;
      T #p.write.EMX_TRANSFER1_CMD;
      T #p.write.EMX_TRANSFER2_CMD;
      L #p.select.EMX_TRANSFER_SUBS;
      T #p.write.EMX_TRANSFER1_SUBS;
      T #p.write.EMX_TRANSFER2_SUBS;

NETWORK
TITLE = Set the child command attributes
//------------------------------------------------------------------------//
// Upload the child state:                                                //
//------------------------------------------------------------------------//


NETWORK
TITLE = Raise operator prompt if required
//------------------------------------------------------------------------//
// OPERATOR PROMPT   OPERATOR PROMPT   OPERATOR PROMPT   OPERATOR PROMPT  //
//                                                                        //
// Transfer the SFC eventPrompt bit to the global event datablock:        //
//------------------------------------------------------------------------//
      O #subsRunning.CIP;
      O #subsRunning.FILL;
      O #subsRunning.FILTER;
      O #subsRunning.MAKE;
      O #subsRunning.SETUP;
      O #subsRunning.SIP;
      JCN _noRunPrompt;

      A #UO_MX_FILL._prompt_abort;
      JCN _not_eventPrompt_31;
      L #p.write.mc.SERIALNUM;
      T "dbEVENT".eventPrompt.event[#p.link.eventPrompt_1].numSerial;
      R #UO_MX_FILL._prompt_abort;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_1].confirmYes;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_1].confirmNo;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_1].trigger1;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_1].trigger2;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_1].trigger3;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_1].trigger4;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_1].trigger5;
_not_eventPrompt_31:      NOP 0;

      A #UO_MX_FILTER._prompt_abort;
      JCN _not_eventPrompt_32;
      L #p.write.mc.SERIALNUM;
      T "dbEVENT".eventPrompt.event[#p.link.eventPrompt_2].numSerial;
      R #UO_MX_FILTER._prompt_abort;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_2].confirmYes;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_2].confirmNo;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_2].trigger1;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_2].trigger2;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_2].trigger3;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_2].trigger4;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_2].trigger5;
_not_eventPrompt_32:      NOP 0;

      A #UO_MX_SETUP._prompt_connect_ok;
      JCN _not_eventPrompt_33;
      L #p.write.mc.SERIALNUM;
      T "dbEVENT".eventPrompt.event[#p.link.eventPrompt_3].numSerial;
      R #UO_MX_SETUP._prompt_connect_ok;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_3].confirmYes;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_3].confirmNo;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_3].trigger1;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_3].trigger2;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_3].trigger3;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_3].trigger4;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_3].trigger5;
_not_eventPrompt_33:      NOP 0;

      A #UO_MX_FILTER._prompt_filt_completed;
      JCN _not_eventPrompt_34;
      L #p.write.mc.SERIALNUM;
      T "dbEVENT".eventPrompt.event[#p.link.eventPrompt_4].numSerial;
      R #UO_MX_FILTER._prompt_filt_completed;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_4].confirmYes;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_4].confirmNo;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_4].trigger1;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_4].trigger2;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_4].trigger3;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_4].trigger4;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_4].trigger5;
_not_eventPrompt_34:      NOP 0;

      A #UO_MX_FILL._prompt_filtration;
      JCN _not_eventPrompt_35;
      L #p.write.mc.SERIALNUM;
      T "dbEVENT".eventPrompt.event[#p.link.eventPrompt_5].numSerial;
      R #UO_MX_FILL._prompt_filtration;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_5].confirmYes;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_5].confirmNo;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_5].trigger1;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_5].trigger2;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_5].trigger3;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_5].trigger4;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_5].trigger5;
_not_eventPrompt_35:      NOP 0;

      A #UO_MX_FILTER._prompt_filtration;
      JCN _not_eventPrompt_36;
      L #p.write.mc.SERIALNUM;
      T "dbEVENT".eventPrompt.event[#p.link.eventPrompt_6].numSerial;
      R #UO_MX_FILTER._prompt_filtration;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_6].confirmYes;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_6].confirmNo;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_6].trigger1;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_6].trigger2;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_6].trigger3;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_6].trigger4;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_6].trigger5;
_not_eventPrompt_36:      NOP 0;

      A #UO_MX_MAKE._prompt_manway_complete;
      JCN _not_eventPrompt_37;
      L #p.write.mc.SERIALNUM;
      T "dbEVENT".eventPrompt.event[#p.link.eventPrompt_7].numSerial;
      R #UO_MX_MAKE._prompt_manway_complete;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_7].confirmYes;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_7].confirmNo;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_7].trigger1;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_7].trigger2;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_7].trigger3;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_7].trigger4;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_7].trigger5;
_not_eventPrompt_37:      NOP 0;

      A #UO_MX_SETUP._prompt_not_held;
      JCN _not_eventPrompt_38;
      L #p.write.mc.SERIALNUM;
      T "dbEVENT".eventPrompt.event[#p.link.eventPrompt_8].numSerial;
      R #UO_MX_SETUP._prompt_not_held;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_8].confirmYes;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_8].confirmNo;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_8].trigger1;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_8].trigger2;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_8].trigger3;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_8].trigger4;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_8].trigger5;
_not_eventPrompt_38:      NOP 0;

      A #UO_MX_SETUP._prompt_not_reach;
      JCN _not_eventPrompt_39;
      L #p.write.mc.SERIALNUM;
      T "dbEVENT".eventPrompt.event[#p.link.eventPrompt_9].numSerial;
      R #UO_MX_SETUP._prompt_not_reach;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_9].confirmYes;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_9].confirmNo;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_9].trigger1;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_9].trigger2;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_9].trigger3;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_9].trigger4;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_9].trigger5;
_not_eventPrompt_39:      NOP 0;

      A #UO_MX_MAKE._prompt_pmo;
      JCN _not_eventPrompt_40;
      L #p.write.mc.SERIALNUM;
      T "dbEVENT".eventPrompt.event[#p.link.eventPrompt_10].numSerial;
      R #UO_MX_MAKE._prompt_pmo;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_10].confirmYes;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_10].confirmNo;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_10].trigger1;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_10].trigger2;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_10].trigger3;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_10].trigger4;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_10].trigger5;
_not_eventPrompt_40:      NOP 0;

      A #UO_MX_MAKE._prompt_tare;
      JCN _not_eventPrompt_41;
      L #p.write.mc.SERIALNUM;
      T "dbEVENT".eventPrompt.event[#p.link.eventPrompt_11].numSerial;
      R #UO_MX_MAKE._prompt_tare;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_11].confirmYes;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_11].confirmNo;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_11].trigger1;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_11].trigger2;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_11].trigger3;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_11].trigger4;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_11].trigger5;
_not_eventPrompt_41:      NOP 0;

      A #UO_MX_SIP._prompt_try_again;
      JCN _not_eventPrompt_42;
      L #p.write.mc.SERIALNUM;
      T "dbEVENT".eventPrompt.event[#p.link.eventPrompt_12].numSerial;
      R #UO_MX_SIP._prompt_try_again;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_12].confirmYes;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_12].confirmNo;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_12].trigger1;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_12].trigger2;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_12].trigger3;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_12].trigger4;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_12].trigger5;
_not_eventPrompt_42:      NOP 0;

_noRunPrompt:      NOP 0;

NETWORK
TITLE = Check if operator confirm bit response
//------------------------------------------------------------------------//
// OPERATOR CONFIRM   OPERATOR CONFIRM   OPERATOR CONFIRM   OPERATOR CONF //
//                                                                        //
// Check if a confirm response has been received:                         //
//------------------------------------------------------------------------//
      O "dbEVENT".eventPrompt.event[#p.link.eventPrompt_1].confirmYes;
      O "dbEVENT".eventPrompt.event[#p.link.eventPrompt_1].confirmNo;
      JCN _not_eventPrompt_31_response;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_1].trigger1;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_1].trigger2;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_1].trigger3;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_1].trigger4;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_1].trigger5;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_1].cancel1;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_1].cancel2;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_1].cancel3;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_1].cancel4;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_1].cancel5;
_not_eventPrompt_31_response:      NOP 0;

      O "dbEVENT".eventPrompt.event[#p.link.eventPrompt_2].confirmYes;
      O "dbEVENT".eventPrompt.event[#p.link.eventPrompt_2].confirmNo;
      JCN _not_eventPrompt_32_response;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_2].trigger1;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_2].trigger2;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_2].trigger3;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_2].trigger4;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_2].trigger5;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_2].cancel1;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_2].cancel2;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_2].cancel3;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_2].cancel4;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_2].cancel5;
_not_eventPrompt_32_response:      NOP 0;

      O "dbEVENT".eventPrompt.event[#p.link.eventPrompt_3].confirmYes;
      O "dbEVENT".eventPrompt.event[#p.link.eventPrompt_3].confirmNo;
      JCN _not_eventPrompt_33_response;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_3].trigger1;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_3].trigger2;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_3].trigger3;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_3].trigger4;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_3].trigger5;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_3].cancel1;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_3].cancel2;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_3].cancel3;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_3].cancel4;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_3].cancel5;
_not_eventPrompt_33_response:      NOP 0;

      O "dbEVENT".eventPrompt.event[#p.link.eventPrompt_4].confirmYes;
      O "dbEVENT".eventPrompt.event[#p.link.eventPrompt_4].confirmNo;
      JCN _not_eventPrompt_34_response;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_4].trigger1;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_4].trigger2;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_4].trigger3;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_4].trigger4;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_4].trigger5;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_4].cancel1;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_4].cancel2;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_4].cancel3;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_4].cancel4;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_4].cancel5;
_not_eventPrompt_34_response:      NOP 0;

      O "dbEVENT".eventPrompt.event[#p.link.eventPrompt_5].confirmYes;
      O "dbEVENT".eventPrompt.event[#p.link.eventPrompt_5].confirmNo;
      JCN _not_eventPrompt_35_response;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_5].trigger1;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_5].trigger2;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_5].trigger3;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_5].trigger4;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_5].trigger5;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_5].cancel1;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_5].cancel2;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_5].cancel3;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_5].cancel4;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_5].cancel5;
_not_eventPrompt_35_response:      NOP 0;

      O "dbEVENT".eventPrompt.event[#p.link.eventPrompt_6].confirmYes;
      O "dbEVENT".eventPrompt.event[#p.link.eventPrompt_6].confirmNo;
      JCN _not_eventPrompt_36_response;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_6].trigger1;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_6].trigger2;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_6].trigger3;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_6].trigger4;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_6].trigger5;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_6].cancel1;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_6].cancel2;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_6].cancel3;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_6].cancel4;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_6].cancel5;
_not_eventPrompt_36_response:      NOP 0;

      O "dbEVENT".eventPrompt.event[#p.link.eventPrompt_7].confirmYes;
      O "dbEVENT".eventPrompt.event[#p.link.eventPrompt_7].confirmNo;
      JCN _not_eventPrompt_37_response;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_7].trigger1;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_7].trigger2;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_7].trigger3;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_7].trigger4;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_7].trigger5;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_7].cancel1;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_7].cancel2;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_7].cancel3;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_7].cancel4;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_7].cancel5;
_not_eventPrompt_37_response:      NOP 0;

      O "dbEVENT".eventPrompt.event[#p.link.eventPrompt_8].confirmYes;
      O "dbEVENT".eventPrompt.event[#p.link.eventPrompt_8].confirmNo;
      JCN _not_eventPrompt_38_response;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_8].trigger1;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_8].trigger2;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_8].trigger3;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_8].trigger4;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_8].trigger5;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_8].cancel1;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_8].cancel2;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_8].cancel3;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_8].cancel4;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_8].cancel5;
_not_eventPrompt_38_response:      NOP 0;

      O "dbEVENT".eventPrompt.event[#p.link.eventPrompt_9].confirmYes;
      O "dbEVENT".eventPrompt.event[#p.link.eventPrompt_9].confirmNo;
      JCN _not_eventPrompt_39_response;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_9].trigger1;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_9].trigger2;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_9].trigger3;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_9].trigger4;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_9].trigger5;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_9].cancel1;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_9].cancel2;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_9].cancel3;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_9].cancel4;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_9].cancel5;
_not_eventPrompt_39_response:      NOP 0;

      O "dbEVENT".eventPrompt.event[#p.link.eventPrompt_10].confirmYes;
      O "dbEVENT".eventPrompt.event[#p.link.eventPrompt_10].confirmNo;
      JCN _not_eventPrompt_40_response;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_10].trigger1;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_10].trigger2;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_10].trigger3;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_10].trigger4;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_10].trigger5;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_10].cancel1;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_10].cancel2;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_10].cancel3;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_10].cancel4;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_10].cancel5;
_not_eventPrompt_40_response:      NOP 0;

      O "dbEVENT".eventPrompt.event[#p.link.eventPrompt_11].confirmYes;
      O "dbEVENT".eventPrompt.event[#p.link.eventPrompt_11].confirmNo;
      JCN _not_eventPrompt_41_response;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_11].trigger1;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_11].trigger2;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_11].trigger3;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_11].trigger4;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_11].trigger5;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_11].cancel1;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_11].cancel2;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_11].cancel3;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_11].cancel4;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_11].cancel5;
_not_eventPrompt_41_response:      NOP 0;

      O "dbEVENT".eventPrompt.event[#p.link.eventPrompt_12].confirmYes;
      O "dbEVENT".eventPrompt.event[#p.link.eventPrompt_12].confirmNo;
      JCN _not_eventPrompt_42_response;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_12].trigger1;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_12].trigger2;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_12].trigger3;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_12].trigger4;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_12].trigger5;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_12].cancel1;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_12].cancel2;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_12].cancel3;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_12].cancel4;
      S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_12].cancel5;
_not_eventPrompt_42_response:      NOP 0;


NETWORK
TITLE = Return operator confirm bits if made
//------------------------------------------------------------------------//
// Receive the eventPrompt confirm bits from the global event datablock:  //
//------------------------------------------------------------------------//
      A "dbEVENT".eventPrompt.event[#p.link.eventPrompt_1].confirmYes;
      JCN _not_eventPrompt_31_confirmYes;
      S #UO_MX_FILL._prompt_abort_confirm_yes;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_1].confirmYes;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_1].confirmNo;
_not_eventPrompt_31_confirmYes:      NOP 0;
      A "dbEVENT".eventPrompt.event[#p.link.eventPrompt_2].confirmYes;
      JCN _not_eventPrompt_32_confirmYes;
      S #UO_MX_FILTER._prompt_abort_confirm_yes;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_2].confirmYes;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_2].confirmNo;
_not_eventPrompt_32_confirmYes:      NOP 0;
      A "dbEVENT".eventPrompt.event[#p.link.eventPrompt_3].confirmYes;
      JCN _not_eventPrompt_33_confirmYes;
      S #UO_MX_SETUP._prompt_connect_ok_confirm_yes;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_3].confirmYes;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_3].confirmNo;
_not_eventPrompt_33_confirmYes:      NOP 0;
      A "dbEVENT".eventPrompt.event[#p.link.eventPrompt_4].confirmYes;
      JCN _not_eventPrompt_34_confirmYes;
      S #UO_MX_FILTER._prompt_filt_completed_confirm_yes;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_4].confirmYes;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_4].confirmNo;
_not_eventPrompt_34_confirmYes:      NOP 0;
      A "dbEVENT".eventPrompt.event[#p.link.eventPrompt_5].confirmYes;
      JCN _not_eventPrompt_35_confirmYes;
      S #UO_MX_FILL._prompt_filtration_confirm_yes;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_5].confirmYes;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_5].confirmNo;
_not_eventPrompt_35_confirmYes:      NOP 0;
      A "dbEVENT".eventPrompt.event[#p.link.eventPrompt_6].confirmYes;
      JCN _not_eventPrompt_36_confirmYes;
      S #UO_MX_FILTER._prompt_filtration_confirm_yes;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_6].confirmYes;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_6].confirmNo;
_not_eventPrompt_36_confirmYes:      NOP 0;
      A "dbEVENT".eventPrompt.event[#p.link.eventPrompt_7].confirmYes;
      JCN _not_eventPrompt_37_confirmYes;
      S #UO_MX_MAKE._prompt_manway_complete_confirm_yes;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_7].confirmYes;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_7].confirmNo;
_not_eventPrompt_37_confirmYes:      NOP 0;
      A "dbEVENT".eventPrompt.event[#p.link.eventPrompt_8].confirmYes;
      JCN _not_eventPrompt_38_confirmYes;
      S #UO_MX_SETUP._prompt_not_held_confirm_yes;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_8].confirmYes;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_8].confirmNo;
_not_eventPrompt_38_confirmYes:      NOP 0;
      A "dbEVENT".eventPrompt.event[#p.link.eventPrompt_8].confirmNo;
      JCN _not_eventPrompt_38_confirmNo;
      S #UO_MX_SETUP._prompt_not_held_confirm_no;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_8].confirmNo;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_8].confirmYes;
_not_eventPrompt_38_confirmNo:      NOP 0;

      A "dbEVENT".eventPrompt.event[#p.link.eventPrompt_9].confirmYes;
      JCN _not_eventPrompt_39_confirmYes;
      S #UO_MX_SETUP._prompt_not_reach_confirm_yes;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_9].confirmYes;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_9].confirmNo;
_not_eventPrompt_39_confirmYes:      NOP 0;
      A "dbEVENT".eventPrompt.event[#p.link.eventPrompt_9].confirmNo;
      JCN _not_eventPrompt_39_confirmNo;
      S #UO_MX_SETUP._prompt_not_reach_confirm_no;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_9].confirmNo;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_9].confirmYes;
_not_eventPrompt_39_confirmNo:      NOP 0;

      A "dbEVENT".eventPrompt.event[#p.link.eventPrompt_10].confirmYes;
      JCN _not_eventPrompt_40_confirmYes;
      S #UO_MX_MAKE._prompt_pmo_confirm_yes;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_10].confirmYes;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_10].confirmNo;
_not_eventPrompt_40_confirmYes:      NOP 0;
      A "dbEVENT".eventPrompt.event[#p.link.eventPrompt_11].confirmYes;
      JCN _not_eventPrompt_41_confirmYes;
      S #UO_MX_MAKE._prompt_tare_confirm_yes;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_11].confirmYes;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_11].confirmNo;
_not_eventPrompt_41_confirmYes:      NOP 0;
      A "dbEVENT".eventPrompt.event[#p.link.eventPrompt_12].confirmYes;
      JCN _not_eventPrompt_42_confirmYes;
      S #UO_MX_SIP._prompt_try_again_confirm_yes;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_12].confirmYes;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_12].confirmNo;
_not_eventPrompt_42_confirmYes:      NOP 0;
      A "dbEVENT".eventPrompt.event[#p.link.eventPrompt_12].confirmNo;
      JCN _not_eventPrompt_42_confirmNo;
      S #UO_MX_SIP._prompt_try_again_confirm_no;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_12].confirmNo;
      R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_12].confirmYes;
_not_eventPrompt_42_confirmNo:      NOP 0;


NETWORK
TITLE = Log prompt confirm No if required
//------------------------------------------------------------------------//
// LOG PROMPT CONFIRM NO   LOG PROMPT CONFIRM NO   LOG PROMPT CONFIRM NO  //
//                                                                        //
// Set the eventPrompt confirm No message alarm bit if active:            //
//------------------------------------------------------------------------//
      O #subsRunning.CIP;
      O #subsRunning.FILL;
      O #subsRunning.FILTER;
      O #subsRunning.MAKE;
      O #subsRunning.SETUP;
      O #subsRunning.SIP;
      JCN _noRunConfirmNo;
      A #UO_MX_SETUP._prompt_not_held_confirm_no;
      = #bEventConfirmNo[0];
      A #UO_MX_SETUP._prompt_not_reach_confirm_no;
      = #bEventConfirmNo[1];
      A #UO_MX_SIP._prompt_try_again_confirm_no;
      = #bEventConfirmNo[2];

_noRunConfirmNo:      NOP 0;

NETWORK
TITLE = Log prompt confirm Yes if required
//------------------------------------------------------------------------//
// LOG PROMPT CONFIRM YES   LOG PROMPT CONFIRM YES   LOG PROMPT CONFIRM   //
//                                                                        //
// Set the eventPrompt confirm Yes message alarm bit if active:           //
//------------------------------------------------------------------------//
      O #subsRunning.CIP;
      O #subsRunning.FILL;
      O #subsRunning.FILTER;
      O #subsRunning.MAKE;
      O #subsRunning.SETUP;
      O #subsRunning.SIP;
      JCN _noRunConfirmYes;
      A #UO_MX_FILL._prompt_abort_confirm_yes;
      = #bEventConfirmYes[0];
      A #UO_MX_FILTER._prompt_abort_confirm_yes;
      = #bEventConfirmYes[1];
      A #UO_MX_SETUP._prompt_connect_ok_confirm_yes;
      = #bEventConfirmYes[2];
      A #UO_MX_FILTER._prompt_filt_completed_confirm_yes;
      = #bEventConfirmYes[3];
      A #UO_MX_FILL._prompt_filtration_confirm_yes;
      = #bEventConfirmYes[4];
      A #UO_MX_FILTER._prompt_filtration_confirm_yes;
      = #bEventConfirmYes[5];
      A #UO_MX_MAKE._prompt_manway_complete_confirm_yes;
      = #bEventConfirmYes[6];
      A #UO_MX_SETUP._prompt_not_held_confirm_yes;
      = #bEventConfirmYes[7];
      A #UO_MX_SETUP._prompt_not_reach_confirm_yes;
      = #bEventConfirmYes[8];
      A #UO_MX_MAKE._prompt_pmo_confirm_yes;
      = #bEventConfirmYes[9];
      A #UO_MX_MAKE._prompt_tare_confirm_yes;
      = #bEventConfirmYes[10];
      A #UO_MX_SIP._prompt_try_again_confirm_yes;
      = #bEventConfirmYes[11];

_noRunConfirmYes:      NOP 0;

NETWORK
TITLE = Log message if required
//------------------------------------------------------------------------//
// LOG MSG   LOG MSG   LOG MSG   LOG MSG   LOG MSG   LOG MSG   LOG MSG    //
//                                                                        //
// Set the eventLogMsg message alarm bit if active:                       //
//------------------------------------------------------------------------//
      O #subsRunning.CIP;
      O #subsRunning.FILL;
      O #subsRunning.FILTER;
      O #subsRunning.MAKE;
      O #subsRunning.SETUP;
      O #subsRunning.SIP;
      JCN _noRunLogMsg;
      A #UO_MX_CIP._log_msg_cip_begin ;// Bit 0
      = #bEventLogMsg[0];
      R #UO_MX_CIP._log_msg_cip_begin;

      A #UO_MX_CIP._log_msg_cip_end ;// Bit 1
      = #bEventLogMsg[1];
      R #UO_MX_CIP._log_msg_cip_end;

      A #UO_MX_FILL._log_msg_fill_begin ;// Bit 2
      = #bEventLogMsg[2];
      R #UO_MX_FILL._log_msg_fill_begin;

      A #UO_MX_FILL._log_msg_fill_end ;// Bit 3
      = #bEventLogMsg[3];
      R #UO_MX_FILL._log_msg_fill_end;

      A #UO_MX_FILTER._log_msg_filter_begin ;// Bit 4
      = #bEventLogMsg[4];
      R #UO_MX_FILTER._log_msg_filter_begin;

      A #UO_MX_FILTER._log_msg_filter_end ;// Bit 5
      = #bEventLogMsg[5];
      R #UO_MX_FILTER._log_msg_filter_end;

      A #UO_MX_FILL._log_msg_filtration_complete ;// Bit 6
      = #bEventLogMsg[6];
      R #UO_MX_FILL._log_msg_filtration_complete;

      A #UO_MX_FILTER._log_msg_filtration_complete ;// Bit 7
      = #bEventLogMsg[7];
      R #UO_MX_FILTER._log_msg_filtration_complete;

      A #UO_MX_FILL._log_msg_filtration_end ;// Bit 8
      = #bEventLogMsg[8];
      R #UO_MX_FILL._log_msg_filtration_end;

      A #UO_MX_FILTER._log_msg_filtration_end ;// Bit 9
      = #bEventLogMsg[9];
      R #UO_MX_FILTER._log_msg_filtration_end;

      A #UO_MX_FILL._log_msg_filtration_start ;// Bit 10
      = #bEventLogMsg[10];
      R #UO_MX_FILL._log_msg_filtration_start;

      A #UO_MX_MAKE._log_msg_make_begin ;// Bit 11
      = #bEventLogMsg[11];
      R #UO_MX_MAKE._log_msg_make_begin;

      A #UO_MX_MAKE._log_msg_make_end ;// Bit 12
      = #bEventLogMsg[12];
      R #UO_MX_MAKE._log_msg_make_end;

      A #UO_MX_SETUP._log_msg_not_held_abort ;// Bit 13
      = #bEventLogMsg[13];
      R #UO_MX_SETUP._log_msg_not_held_abort;

      A #UO_MX_SETUP._log_msg_not_held_repeat ;// Bit 14
      = #bEventLogMsg[14];
      R #UO_MX_SETUP._log_msg_not_held_repeat;

      A #UO_MX_SETUP._log_msg_not_reach_abort ;// Bit 15
      = #bEventLogMsg[15];
      R #UO_MX_SETUP._log_msg_not_reach_abort;

      A #UO_MX_SETUP._log_msg_not_reach_repeat ;// Bit 0
      = #bEventLogMsg[16];
      R #UO_MX_SETUP._log_msg_not_reach_repeat;

      A #UO_MX_MAKE._log_msg_pmo_complete ;// Bit 1
      = #bEventLogMsg[17];
      R #UO_MX_MAKE._log_msg_pmo_complete;

      A #UO_MX_SIP._log_msg_pres_blow_reached ;// Bit 2
      = #bEventLogMsg[18];
      R #UO_MX_SIP._log_msg_pres_blow_reached;

      A #UO_MX_SIP._log_msg_pres_leave_reached ;// Bit 3
      = #bEventLogMsg[19];
      R #UO_MX_SIP._log_msg_pres_leave_reached;

      A #UO_MX_CIP._log_msg_pw_fl_wash_begin ;// Bit 4
      = #bEventLogMsg[20];
      R #UO_MX_CIP._log_msg_pw_fl_wash_begin;

      A #UO_MX_CIP._log_msg_pw_fl_wash_end ;// Bit 5
      = #bEventLogMsg[21];
      R #UO_MX_CIP._log_msg_pw_fl_wash_end;

      A #UO_MX_CIP._log_msg_pw_flood_begin ;// Bit 6
      = #bEventLogMsg[22];
      R #UO_MX_CIP._log_msg_pw_flood_begin;

      A #UO_MX_CIP._log_msg_pw_flood_end ;// Bit 7
      = #bEventLogMsg[23];
      R #UO_MX_CIP._log_msg_pw_flood_end;

      A #UO_MX_CIP._log_msg_pw_flood_timeout ;// Bit 8
      = #bEventLogMsg[24];
      R #UO_MX_CIP._log_msg_pw_flood_timeout;

      A #UO_MX_CIP._log_msg_pw_flush_begin ;// Bit 9
      = #bEventLogMsg[25];
      R #UO_MX_CIP._log_msg_pw_flush_begin;

      A #UO_MX_CIP._log_msg_pw_flush_end ;// Bit 10
      = #bEventLogMsg[26];
      R #UO_MX_CIP._log_msg_pw_flush_end;

      A #UO_MX_CIP._log_msg_pw_wash_begin ;// Bit 11
      = #bEventLogMsg[27];
      R #UO_MX_CIP._log_msg_pw_wash_begin;

      A #UO_MX_CIP._log_msg_pw_wash_end ;// Bit 12
      = #bEventLogMsg[28];
      R #UO_MX_CIP._log_msg_pw_wash_end;

      A #UO_MX_SETUP._log_msg_setup_begin ;// Bit 13
      = #bEventLogMsg[29];
      R #UO_MX_SETUP._log_msg_setup_begin;

      A #UO_MX_SETUP._log_msg_setup_end ;// Bit 14
      = #bEventLogMsg[30];
      R #UO_MX_SETUP._log_msg_setup_end;

      A #UO_MX_SIP._log_msg_sip_abort ;// Bit 15
      = #bEventLogMsg[31];
      R #UO_MX_SIP._log_msg_sip_abort;

      A #UO_MX_SIP._log_msg_sip_begin ;// Bit 0
      = #bEventLogMsg[32];
      R #UO_MX_SIP._log_msg_sip_begin;

      A #UO_MX_SIP._log_msg_sip_complete ;// Bit 1
      = #bEventLogMsg[33];
      R #UO_MX_SIP._log_msg_sip_complete;

      A #UO_MX_SIP._log_msg_sip_end ;// Bit 2
      = #bEventLogMsg[34];
      R #UO_MX_SIP._log_msg_sip_end;

      A #UO_MX_SIP._log_msg_sip_start ;// Bit 3
      = #bEventLogMsg[35];
      R #UO_MX_SIP._log_msg_sip_start;

      A #UO_MX_SIP._log_msg_sip_timer_reset ;// Bit 4
      = #bEventLogMsg[36];
      R #UO_MX_SIP._log_msg_sip_timer_reset;

      A #UO_MX_SIP._log_msg_steam_closed ;// Bit 5
      = #bEventLogMsg[37];
      R #UO_MX_SIP._log_msg_steam_closed;

      A #UO_MX_SIP._log_msg_steam_open ;// Bit 6
      = #bEventLogMsg[38];
      R #UO_MX_SIP._log_msg_steam_open;

      A #UO_MX_FILTER._log_msg_temperature_abort ;// Bit 7
      = #bEventLogMsg[39];
      R #UO_MX_FILTER._log_msg_temperature_abort;

      A #UO_MX_SETUP._log_msg_vacuum_begin ;// Bit 8
      = #bEventLogMsg[40];
      R #UO_MX_SETUP._log_msg_vacuum_begin;

      A #UO_MX_SIP._log_msg_vacuum_begin ;// Bit 9
      = #bEventLogMsg[41];
      R #UO_MX_SIP._log_msg_vacuum_begin;

      A #UO_MX_SIP._log_msg_vacuum_fail ;// Bit 10
      = #bEventLogMsg[42];
      R #UO_MX_SIP._log_msg_vacuum_fail;

      A #UO_MX_SIP._log_msg_vacuum_fail_abort ;// Bit 11
      = #bEventLogMsg[43];
      R #UO_MX_SIP._log_msg_vacuum_fail_abort;

      A #UO_MX_SIP._log_msg_vacuum_fail_repeat ;// Bit 12
      = #bEventLogMsg[44];
      R #UO_MX_SIP._log_msg_vacuum_fail_repeat;

      A #UO_MX_CIP._log_msg_wfi_rinse_begin ;// Bit 13
      = #bEventLogMsg[45];
      R #UO_MX_CIP._log_msg_wfi_rinse_begin;

      A #UO_MX_CIP._log_msg_wfi_rinse_end ;// Bit 14
      = #bEventLogMsg[46];
      R #UO_MX_CIP._log_msg_wfi_rinse_end;

      A #UO_MX_FILL._log_msg_wrong_hygiene ;// Bit 15
      = #bEventLogMsg[47];
      R #UO_MX_FILL._log_msg_wrong_hygiene;

      A #UO_MX_FILTER._log_msg_wrong_hygiene ;// Bit 0
      = #bEventLogMsg[48];
      R #UO_MX_FILTER._log_msg_wrong_hygiene;


_noRunLogMsg:      NOP 0;

NETWORK
TITLE = Real data
//------------------------------------------------------------------------//
// REAL DATA   REAL DATA   REAL DATA   REAL DATA   REAL DATA   REAL DATA  //
//                                                                        //
// Transfer the SFC eventLogReal real data to the global event datablock: //
//------------------------------------------------------------------------//
      O #subsRunning.CIP;
      O #subsRunning.FILL;
      O #subsRunning.FILTER;
      O #subsRunning.MAKE;
      O #subsRunning.SETUP;
      O #subsRunning.SIP;
      JCN _noRunLogReal;
      L #UO_MX_CIP._real_pw_flood_mass;
      T "dbEVENT".eventDataReal[8];
      L #UO_MX_FILTER._real_throttled_vessel_mass;
      T "dbEVENT".eventDataReal[9];
      L #UO_MX_FILTER._real_hihi_temperature;
      T "dbEVENT".eventDataReal[10];
      L #UO_MX_FILTER._real_hi_temperature;
      T "dbEVENT".eventDataReal[11];
      L #UO_MX_FILTER._real_reduced_vessel_mass;
      T "dbEVENT".eventDataReal[12];
      L #UO_MX_SETUP._real_not_held;
      T "dbEVENT".eventDataReal[13];
      L #UO_MX_SETUP._real_vacuum_fail;
      T "dbEVENT".eventDataReal[14];
      L #UO_MX_SETUP._real_pressure_mx;
      T "dbEVENT".eventDataReal[15];
      L #UO_MX_SIP._real_emg_ti_vent_pv;
      T "dbEVENT".eventDataReal[16];
      L #UO_MX_SIP._real_emg_ti_drain_pv;
      T "dbEVENT".eventDataReal[17];
      L #UO_MX_SIP._real_emv_ti_vessel_pv;
      T "dbEVENT".eventDataReal[18];
      L #UO_MX_SIP._real_emx_ti_drain_pv;
      T "dbEVENT".eventDataReal[19];
      L #UO_MX_SIP._real_positive_pressure;
      T "dbEVENT".eventDataReal[20];
_noRunLogReal:      NOP 0;

NETWORK
TITLE = Log real data if required
//------------------------------------------------------------------------//
// LOG REAL   LOG REAL   LOG REAL   LOG REAL   LOG REAL   LOG REAL   LOG  //
//                                                                        //
// Set the eventLogReal data alarm bit if active:                         //
//------------------------------------------------------------------------//
      O #subsRunning.CIP;
      O #subsRunning.FILL;
      O #subsRunning.FILTER;
      O #subsRunning.MAKE;
      O #subsRunning.SETUP;
      O #subsRunning.SIP;
      JCN _noRunLogRealData;
      A #UO_MX_SIP._log_real_emg_ti_drain_pv ;// Bit 0
      = #bEventLogReal[0];
      R #UO_MX_SIP._log_real_emg_ti_drain_pv;

      A #UO_MX_SIP._log_real_emg_ti_vent_pv ;// Bit 1
      = #bEventLogReal[1];
      R #UO_MX_SIP._log_real_emg_ti_vent_pv;

      A #UO_MX_SIP._log_real_emv_ti_vessel_pv ;// Bit 2
      = #bEventLogReal[2];
      R #UO_MX_SIP._log_real_emv_ti_vessel_pv;

      A #UO_MX_SIP._log_real_emx_ti_drain_pv ;// Bit 3
      = #bEventLogReal[3];
      R #UO_MX_SIP._log_real_emx_ti_drain_pv;

      A #UO_MX_FILTER._log_real_hi_temperature ;// Bit 4
      = #bEventLogReal[4];
      R #UO_MX_FILTER._log_real_hi_temperature;

      A #UO_MX_FILTER._log_real_hihi_temperature ;// Bit 5
      = #bEventLogReal[5];
      R #UO_MX_FILTER._log_real_hihi_temperature;

      A #UO_MX_SETUP._log_real_not_held ;// Bit 6
      = #bEventLogReal[6];
      R #UO_MX_SETUP._log_real_not_held;

      A #UO_MX_SIP._log_real_positive_pressure ;// Bit 7
      = #bEventLogReal[7];
      R #UO_MX_SIP._log_real_positive_pressure;

      A #UO_MX_SETUP._log_real_pressure_mx ;// Bit 8
      = #bEventLogReal[8];
      R #UO_MX_SETUP._log_real_pressure_mx;

      A #UO_MX_CIP._log_real_pw_flood_mass ;// Bit 9
      = #bEventLogReal[9];
      R #UO_MX_CIP._log_real_pw_flood_mass;

      A #UO_MX_FILTER._log_real_reduced_vessel_mass ;// Bit 10
      = #bEventLogReal[10];
      R #UO_MX_FILTER._log_real_reduced_vessel_mass;

      A #UO_MX_FILTER._log_real_throttled_vessel_mass ;// Bit 11
      = #bEventLogReal[11];
      R #UO_MX_FILTER._log_real_throttled_vessel_mass;

      A #UO_MX_SETUP._log_real_vacuum_fail ;// Bit 12
      = #bEventLogReal[12];
      R #UO_MX_SETUP._log_real_vacuum_fail;


_noRunLogRealData:      NOP 0;

NETWORK
TITLE = Time data
//------------------------------------------------------------------------//
// TIME DATA   TIME DATA   TIME DATA   TIME DATA   TIME DATA   TIME DATA  //
//                                                                        //
// Transfer the SFC eventLogTime data to the global event datablock:      //
//------------------------------------------------------------------------//
      O #subsRunning.CIP;
      O #subsRunning.FILL;
      O #subsRunning.FILTER;
      O #subsRunning.MAKE;
      O #subsRunning.SETUP;
      O #subsRunning.SIP;
      JCN _noRunLogTime;
      L #UO_MX_CIP._time_act_wfi_flrinse;
      T "dbEVENT".eventDataTime[0];
      L #UO_MX_CIP._time_act_wfi_rinse;
      T "dbEVENT".eventDataTime[1];
      L #UO_MX_CIP._time_act_pw_steam;
      T "dbEVENT".eventDataTime[2];
      L #UO_MX_CIP._time_act_pw_flwash;
      T "dbEVENT".eventDataTime[3];
      L #UO_MX_CIP._time_act_pw_wash;
      T "dbEVENT".eventDataTime[4];
      L #UO_MX_CIP._time_act_flood_mixing;
      T "dbEVENT".eventDataTime[5];
      L #UO_MX_CIP._time_act_pw_flush;
      T "dbEVENT".eventDataTime[6];
      L #UO_MX_SETUP._time_act_vacuum_held;
      T "dbEVENT".eventDataTime[7];
_noRunLogTime:      NOP 0;

NETWORK
TITLE = Log time data if required
//------------------------------------------------------------------------//
// LOG TIME   LOG TIME   LOG TIME   LOG TIME   LOG TIME   LOG TIME   LOG  //
//                                                                        //
// Set the eventLogTime data alarm bit if active:                         //
//------------------------------------------------------------------------//
      O #subsRunning.CIP;
      O #subsRunning.FILL;
      O #subsRunning.FILTER;
      O #subsRunning.MAKE;
      O #subsRunning.SETUP;
      O #subsRunning.SIP;
      JCN _noRunLogTimeData;
      A #UO_MX_CIP._log_time_act_flood_mixing ;// Bit 0
      = #bEventLogTime[0];
      R #UO_MX_CIP._log_time_act_flood_mixing;
_not_UO_MX_CIP_log_time_act_flood_mixing:      NOP 0;

      A #UO_MX_CIP._log_time_act_pw_flush ;// Bit 1
      = #bEventLogTime[1];
      R #UO_MX_CIP._log_time_act_pw_flush;
_not_UO_MX_CIP_log_time_act_pw_flush:      NOP 0;

      A #UO_MX_CIP._log_time_act_pw_flwash ;// Bit 2
      = #bEventLogTime[2];
      R #UO_MX_CIP._log_time_act_pw_flwash;
_not_UO_MX_CIP_log_time_act_pw_flwash:      NOP 0;

      A #UO_MX_CIP._log_time_act_pw_steam ;// Bit 3
      = #bEventLogTime[3];
      R #UO_MX_CIP._log_time_act_pw_steam;
_not_UO_MX_CIP_log_time_act_pw_steam:      NOP 0;

      A #UO_MX_CIP._log_time_act_pw_wash ;// Bit 4
      = #bEventLogTime[4];
      R #UO_MX_CIP._log_time_act_pw_wash;
_not_UO_MX_CIP_log_time_act_pw_wash:      NOP 0;

      A #UO_MX_SETUP._log_time_act_vacuum_held ;// Bit 5
      = #bEventLogTime[5];
      R #UO_MX_SETUP._log_time_act_vacuum_held;
_not_UO_MX_SETUP_log_time_act_vacuum_held:      NOP 0;

      A #UO_MX_CIP._log_time_act_wfi_flrinse ;// Bit 6
      = #bEventLogTime[6];
      R #UO_MX_CIP._log_time_act_wfi_flrinse;
_not_UO_MX_CIP_log_time_act_wfi_flrinse:      NOP 0;

      A #UO_MX_CIP._log_time_act_wfi_rinse ;// Bit 7
      = #bEventLogTime[7];
      R #UO_MX_CIP._log_time_act_wfi_rinse;
_not_UO_MX_CIP_log_time_act_wfi_rinse:      NOP 0;


_noRunLogTimeData:      NOP 0;

NETWORK
TITLE = Flag SFC finished if successfully completed execution
//------------------------------------------------------------------------//
// SFC COMPLETE   SFC COMPLETE   SFC COMPLETE   SFC COMPLETE   SFC COMPL  //
//                                                                        //
// Flag SFC completed if the sequence has finished executing:             //
//------------------------------------------------------------------------//
      O(;
      A #subsRunning.CIP;
      A(;
      L #UO_MX_CIP.smc.SQ_STATE;
      L "dbCONST".SEQ.STATE.COMPLETED;
      ==I;
      );
      );
      O(;
      A #subsRunning.FILL;
      A(;
      L #UO_MX_FILL.smc.SQ_STATE;
      L "dbCONST".SEQ.STATE.COMPLETED;
      ==I;
      );
      );
      O(;
      A #subsRunning.FILTER;
      A(;
      L #UO_MX_FILTER.smc.SQ_STATE;
      L "dbCONST".SEQ.STATE.COMPLETED;
      ==I;
      );
      );
      O(;
      A #subsRunning.MAKE;
      A(;
      L #UO_MX_MAKE.smc.SQ_STATE;
      L "dbCONST".SEQ.STATE.COMPLETED;
      ==I;
      );
      );
      O(;
      A #subsRunning.SETUP;
      A(;
      L #UO_MX_SETUP.smc.SQ_STATE;
      L "dbCONST".SEQ.STATE.COMPLETED;
      ==I;
      );
      );
      O(;
      A #subsRunning.SIP;
      A(;
      L #UO_MX_SIP.smc.SQ_STATE;
      L "dbCONST".SEQ.STATE.COMPLETED;
      ==I;
      );
      );
      JCN _notFinishedSuccessful;
      S #flags.sfcCompleted;
_notFinishedSuccessful:      NOP 0;

NETWORK
TITLE = Flag SFC aborted if unsuccessfully completed execution
//------------------------------------------------------------------------//
// Flag SFC completed if the sequence has been aborted:                   //
//------------------------------------------------------------------------//
      O(;
      A #subsRunning.CIP;
      A(;
      O(;
      L #UO_MX_CIP.smc.SQ_STATE;
      L "dbCONST".SEQ.STATE.ABORTED;
      ==I;
      );
      O(;
      L "dbCONST".SEQ.STATE.OFF_IDLE;
      L #UO_MX_CIP.smc.SQ_STATE;
      ==I;
      );
      );
      );
      O(;
      A #subsRunning.FILL;
      A(;
      O(;
      L #UO_MX_FILL.smc.SQ_STATE;
      L "dbCONST".SEQ.STATE.ABORTED;
      ==I;
      );
      O(;
      L "dbCONST".SEQ.STATE.OFF_IDLE;
      L #UO_MX_FILL.smc.SQ_STATE;
      ==I;
      );
      );
      );
      O(;
      A #subsRunning.FILTER;
      A(;
      O(;
      L #UO_MX_FILTER.smc.SQ_STATE;
      L "dbCONST".SEQ.STATE.ABORTED;
      ==I;
      );
      O(;
      L "dbCONST".SEQ.STATE.OFF_IDLE;
      L #UO_MX_FILTER.smc.SQ_STATE;
      ==I;
      );
      );
      );
      O(;
      A #subsRunning.MAKE;
      A(;
      O(;
      L #UO_MX_MAKE.smc.SQ_STATE;
      L "dbCONST".SEQ.STATE.ABORTED;
      ==I;
      );
      O(;
      L "dbCONST".SEQ.STATE.OFF_IDLE;
      L #UO_MX_MAKE.smc.SQ_STATE;
      ==I;
      );
      );
      );
      O(;
      A #subsRunning.SETUP;
      A(;
      O(;
      L #UO_MX_SETUP.smc.SQ_STATE;
      L "dbCONST".SEQ.STATE.ABORTED;
      ==I;
      );
      O(;
      L "dbCONST".SEQ.STATE.OFF_IDLE;
      L #UO_MX_SETUP.smc.SQ_STATE;
      ==I;
      );
      );
      );
      O(;
      A #subsRunning.SIP;
      A(;
      O(;
      L #UO_MX_SIP.smc.SQ_STATE;
      L "dbCONST".SEQ.STATE.ABORTED;
      ==I;
      );
      O(;
      L "dbCONST".SEQ.STATE.OFF_IDLE;
      L #UO_MX_SIP.smc.SQ_STATE;
      ==I;
      );
      );
      );
      JCN _notFinishedUnsuccessful;
      S #flags.sfcAborted;
      S #flags.substateCompleted;
      L "dbCONST".BLK.MX.STATE.ABORTED;
      T #p.read.mc.STATE;
_notFinishedUnsuccessful:      NOP 0;

NETWORK
TITLE = Check if substate completed
//------------------------------------------------------------------------//
// Check if substate has been completed if SFC finished if there is one:  //
//------------------------------------------------------------------------//
      O(;
      A #subsRunning.CIP;
      A(;
      O(;
      A #subsHasSFC.CIP;
      A #flags.sfcCompleted;
      );
      ON #subsHasSFC.CIP;
      );
      );
      O(;
      A #subsRunning.FILL;
      A(;
      O(;
      A #subsHasSFC.FILL;
      A #flags.sfcCompleted;
      );
      ON #subsHasSFC.FILL;
      );
      );
      O(;
      A #subsRunning.FILTER;
      A(;
      O(;
      A #subsHasSFC.FILTER;
      A #flags.sfcCompleted;
      );
      ON #subsHasSFC.FILTER;
      );
      );
      O(;
      A #subsRunning.MAKE;
      A(;
      O(;
      A #subsHasSFC.MAKE;
      A #flags.sfcCompleted;
      );
      ON #subsHasSFC.MAKE;
      );
      );
      O(;
      A #subsRunning.SETUP;
      A(;
      O(;
      A #subsHasSFC.SETUP;
      A #flags.sfcCompleted;
      );
      ON #subsHasSFC.SETUP;
      );
      );
      O(;
      A #subsRunning.SIP;
      A(;
      O(;
      A #subsHasSFC.SIP;
      A #flags.sfcCompleted;
      );
      ON #subsHasSFC.SIP;
      );
      );
      JCN _noSubstateComplete;
      S #flags.substateCompleted;
_noSubstateComplete:      NOP 0;

      SET;
      JC _switch_end;

  //------------------------------------------------------------------------//
  // SWITCH   SWITCH   SWITCH   SWITCH   SWITCH   SWITCH   SWITCH   SWITCH  //
  // COMPLETED   COMPLETED   COMPLETED   COMPLETED   COMPLETED   COMPLETED  //
  // COMPLETED   COMPLETED   COMPLETED   COMPLETED   COMPLETED   COMPLETED  //
  //------------------------------------------------------------------------//
_state_COMPLETED:      NOP 0;

NETWORK
TITLE = COMPLETED COMPLETED COMPLETED Running substate completed
//------------------------------------------------------------------------//
// BLOCK COMPLETE   BLOCK COMPLETE   BLOCK COMPLETE   BLOCK COMPLETE   BL //
//                                                                        //
// Set the block state to COMPLETED if no SFC or SFC completed:           //
//------------------------------------------------------------------------//
      AN #flags.childMismatch;
      AN #flags.sfcAborted;
      JCN _blkComplete;
      L "dbCONST".BLK.MX.STATE.COMPLETED;
      T #p.read.mc.STATE;
      L #p.write.mc.SUBS;
      T #p.read.bmc.lastSUBS;

_blkComplete:      NOP 0;

NETWORK
TITLE = Release child EMX_FILL1 if acquired and command completed
//------------------------------------------------------------------------//
// RELEASE CHILD   RELEASE CHILD   RELEASE CHILD   RELEASE CHILD   RELE   //
//                                                                        //
// Release the child device if acquired earlier to run the command:       //
//------------------------------------------------------------------------//
      A #acquire.EMX_FILL1;
      JCN _notOwn1;
      L "dbCONST".BLK.ID.AVAILABLE;
      T "idbEMX5".f[#p.child.EMX_FILL1].p.write.mc.OWNER;
      R #acquire.EMX_FILL1;
_notOwn1:      NOP 0;

NETWORK
TITLE = Release child EMX_FILL2 if acquired and command completed
//------------------------------------------------------------------------//
// RELEASE CHILD   RELEASE CHILD   RELEASE CHILD   RELEASE CHILD   RELE   //
//                                                                        //
// Release the child device if acquired earlier to run the command:       //
//------------------------------------------------------------------------//
      A #acquire.EMX_FILL2;
      JCN _notOwn2;
      L "dbCONST".BLK.ID.AVAILABLE;
      T "idbEMX5".f[#p.child.EMX_FILL2].p.write.mc.OWNER;
      R #acquire.EMX_FILL2;
_notOwn2:      NOP 0;

NETWORK
TITLE = Release child EMX_SMFL if acquired and command completed
//------------------------------------------------------------------------//
// RELEASE CHILD   RELEASE CHILD   RELEASE CHILD   RELEASE CHILD   RELE   //
//                                                                        //
// Release the child device if acquired earlier to run the command:       //
//------------------------------------------------------------------------//
      A #acquire.EMX_SMFL;
      JCN _notOwn3;
      L "dbCONST".BLK.ID.AVAILABLE;
      T "idbEMX6".f[#p.child.EMX_SMFL].p.write.mc.OWNER;
      R #acquire.EMX_SMFL;
_notOwn3:      NOP 0;

NETWORK
TITLE = Release child EMX_SMFLDRN if acquired and command completed
//------------------------------------------------------------------------//
// RELEASE CHILD   RELEASE CHILD   RELEASE CHILD   RELEASE CHILD   RELE   //
//                                                                        //
// Release the child device if acquired earlier to run the command:       //
//------------------------------------------------------------------------//
      A #acquire.EMX_SMFLDRN;
      JCN _notOwn4;
      L "dbCONST".BLK.ID.AVAILABLE;
      T "idbEMX4".f[#p.child.EMX_SMFLDRN].p.write.mc.OWNER;
      R #acquire.EMX_SMFLDRN;
_notOwn4:      NOP 0;

NETWORK
TITLE = Release child EMX_TRANSFER1 if acquired and command completed
//------------------------------------------------------------------------//
// RELEASE CHILD   RELEASE CHILD   RELEASE CHILD   RELEASE CHILD   RELE   //
//                                                                        //
// Release the child device if acquired earlier to run the command:       //
//------------------------------------------------------------------------//
      A #acquire.EMX_TRANSFER1;
      JCN _notOwn5;
      L "dbCONST".BLK.ID.AVAILABLE;
      T "idbEMX2".f[#p.child.EMX_TRANSFER1].p.write.mc.OWNER;
      R #acquire.EMX_TRANSFER1;
_notOwn5:      NOP 0;

NETWORK
TITLE = Release child EMX_TRANSFER2 if acquired and command completed
//------------------------------------------------------------------------//
// RELEASE CHILD   RELEASE CHILD   RELEASE CHILD   RELEASE CHILD   RELE   //
//                                                                        //
// Release the child device if acquired earlier to run the command:       //
//------------------------------------------------------------------------//
      A #acquire.EMX_TRANSFER2;
      JCN _notOwn6;
      L "dbCONST".BLK.ID.AVAILABLE;
      T "idbEMX2".f[#p.child.EMX_TRANSFER2].p.write.mc.OWNER;
      R #acquire.EMX_TRANSFER2;
_notOwn6:      NOP 0;


  //------------------------------------------------------------------------//
  // SWITCH   SWITCH   SWITCH   SWITCH   SWITCH   SWITCH   SWITCH   SWITCH  //
  // END   END   END   END   END   END  END   END   END   END   END   END   //
  // END   END   END   END   END   END  END   END   END   END   END   END   //
  //------------------------------------------------------------------------//
_switch_end:      NOP 0;

NETWORK
TITLE = SWITCH END SWITCH END ERROR if child mismatch
//------------------------------------------------------------------------//
// BLOCK ERROR   BLOCK ERROR   BLOCK ERROR   BLOCK ERROR   BLOCK ERROR    //
//                                                                        //
// Set the block state to ERROR if child mismatch and not STOPPED:        //
//------------------------------------------------------------------------//
      AN #cmdSTOPPED;
      A(;
      ON #p.read.bmc.permitStart;
      O #flags.sfcAborted;
      );
      A(;
      L "dbCONST".BLK.MX.STATE.ERROR;
      L #p.read.mc.STATE;
      <>I;
      );
      JCN _blkError;
      L #p.read.mc.STATE;
      T #stateBeforeError;
      L "dbCONST".BLK.MX.STATE.ERROR;
      T #p.read.mc.STATE;
_blkError:      NOP 0;

NETWORK
TITLE = RESUME if children now okay
//------------------------------------------------------------------------//
// BLOCK RESUME   BLOCK RESUME   BLOCK RESUME   BLOCK RESUME   BLOCK RES  //
//                                                                        //
// Resume the running SFC sequence if no interlock or failure condition:  //
//------------------------------------------------------------------------//
      AN #cmdSTOPPED;
      A #p.read.bmc.permitStart;
      AN #flags.sfcAborted;
      A(;
      L "dbCONST".BLK.MX.STATE.ERROR;
      L #p.read.mc.STATE;
      ==I;
      );
      JCN _noResume;
      L #stateBeforeError;
      T #p.read.mc.STATE;

      A #subsRunning.CIP;
      JCN _resumeSFC_1;
      L "dbCONST".SEQ.CMD.RESUME;
      T #UO_MX_CIP.smc.SQ_CMD;
_resumeSFC_1:      NOP 0;

      A #subsRunning.FILL;
      JCN _resumeSFC_2;
      L "dbCONST".SEQ.CMD.RESUME;
      T #UO_MX_FILL.smc.SQ_CMD;
_resumeSFC_2:      NOP 0;

      A #subsRunning.FILTER;
      JCN _resumeSFC_3;
      L "dbCONST".SEQ.CMD.RESUME;
      T #UO_MX_FILTER.smc.SQ_CMD;
_resumeSFC_3:      NOP 0;

      A #subsRunning.MAKE;
      JCN _resumeSFC_4;
      L "dbCONST".SEQ.CMD.RESUME;
      T #UO_MX_MAKE.smc.SQ_CMD;
_resumeSFC_4:      NOP 0;

      A #subsRunning.SETUP;
      JCN _resumeSFC_5;
      L "dbCONST".SEQ.CMD.RESUME;
      T #UO_MX_SETUP.smc.SQ_CMD;
_resumeSFC_5:      NOP 0;

      A #subsRunning.SIP;
      JCN _resumeSFC_6;
      L "dbCONST".SEQ.CMD.RESUME;
      T #UO_MX_SIP.smc.SQ_CMD;
_resumeSFC_6:      NOP 0;


_noResume:      NOP 0;

NETWORK
TITLE = Upload child states
      A "alwaysHigh";
      JCN _pSTATE_DI_ASL;
      L "idbDI1".f[#p.child.DI_ASL].p.read.mc.STATE;
      T #p.read.DI_ASL_STATE;
_pSTATE_DI_ASL:      NOP 0;

      A "alwaysHigh";
      JCN _pSTATE_DI_ESTOP;
      L "idbDI1".f[#p.child.DI_ESTOP].p.read.mc.STATE;
      T #p.read.DI_ESTOP_STATE;
_pSTATE_DI_ESTOP:      NOP 0;

      A "alwaysHigh";
      JCN _pSTATE_DI_ESTOP_AUX1;
      L "idbDI1".f[#p.child.DI_ESTOP_AUX1].p.read.mc.STATE;
      T #p.read.DI_ESTOP_AUX1_STATE;
_pSTATE_DI_ESTOP_AUX1:      NOP 0;

      A "alwaysHigh";
      JCN _pSTATE_DI_ESTOP_AUX2;
      L "idbDI1".f[#p.child.DI_ESTOP_AUX2].p.read.mc.STATE;
      T #p.read.DI_ESTOP_AUX2_STATE;
_pSTATE_DI_ESTOP_AUX2:      NOP 0;

      A "alwaysHigh";
      JCN _pSTATE_DI_ESTOP_AUX3;
      L "idbDI1".f[#p.child.DI_ESTOP_AUX3].p.read.mc.STATE;
      T #p.read.DI_ESTOP_AUX3_STATE;
_pSTATE_DI_ESTOP_AUX3:      NOP 0;

      A "alwaysHigh";
      JCN _pSTATE_DI_RELAY;
      L "idbDI2".f[#p.child.DI_RELAY].p.read.mc.STATE;
      T #p.read.DI_RELAY_STATE;
_pSTATE_DI_RELAY:      NOP 0;

      A "alwaysHigh";
      JCN _pSTATE_EMA_VESSEL;
      L "idbEMA1".f[#p.child.EMA_VESSEL].p.read.mc.STATE;
      T #p.read.EMA_VESSEL_STATE;
_pSTATE_EMA_VESSEL:      NOP 0;

      A "alwaysHigh";
      JCN _pSTATE_EMC_GAS;
      L "idbEMC1".f[#p.child.EMC_GAS].p.read.mc.STATE;
      T #p.read.EMC_GAS_STATE;
_pSTATE_EMC_GAS:      NOP 0;

      A "alwaysHigh";
      JCN _pSTATE_EMC_WATER;
      L "idbEMC2".f[#p.child.EMC_WATER].p.read.mc.STATE;
      T #p.read.EMC_WATER_STATE;
_pSTATE_EMC_WATER:      NOP 0;

      A "alwaysHigh";
      JCN _pSTATE_EMG_FILTER;
      L "idbEMG1".f[#p.child.EMG_FILTER].p.read.mc.STATE;
      T #p.read.EMG_FILTER_STATE;
_pSTATE_EMG_FILTER:      NOP 0;

      A "alwaysHigh";
      JCN _pSTATE_EMM_VESSEL;
      L "idbEMM1".f[#p.child.EMM_VESSEL].p.read.mc.STATE;
      T #p.read.EMM_VESSEL_STATE;
_pSTATE_EMM_VESSEL:      NOP 0;

      A "alwaysHigh";
      JCN _pSTATE_EMT_HEX;
      L "idbEMT1".f[#p.child.EMT_HEX].p.read.mc.STATE;
      T #p.read.EMT_HEX_STATE;
_pSTATE_EMT_HEX:      NOP 0;

      A "alwaysHigh";
      JCN _pSTATE_EMV_INLET;
      L "idbEMV2".f[#p.child.EMV_INLET].p.read.mc.STATE;
      T #p.read.EMV_INLET_STATE;
_pSTATE_EMV_INLET:      NOP 0;

      A "alwaysHigh";
      JCN _pSTATE_EMV_VESSEL;
      L "idbEMV1".f[#p.child.EMV_VESSEL].p.read.mc.STATE;
      T #p.read.EMV_VESSEL_STATE;
_pSTATE_EMV_VESSEL:      NOP 0;

      A "alwaysHigh";
      JCN _pSTATE_EMX_DRAIN;
      L "idbEMX4".f[#p.child.EMX_DRAIN].p.read.mc.STATE;
      T #p.read.EMX_DRAIN_STATE;
_pSTATE_EMX_DRAIN:      NOP 0;

      A #selected_FILL_FLZ.FL1;
      JCN _pSTATE_EMX_FILL1;
      L "idbEMX5".f[#p.child.EMX_FILL1].p.read.mc.STATE;
      T #p.read.EMX_FILL1_STATE;
_pSTATE_EMX_FILL1:      NOP 0;

      A #selected_FILL_FLZ.FL2;
      JCN _pSTATE_EMX_FILL2;
      L "idbEMX5".f[#p.child.EMX_FILL2].p.read.mc.STATE;
      T #p.read.EMX_FILL2_STATE;
_pSTATE_EMX_FILL2:      NOP 0;

      A "alwaysHigh";
      JCN _pSTATE_EMX_MMFL;
      L "idbEMX1".f[#p.child.EMX_MMFL].p.read.mc.STATE;
      T #p.read.EMX_MMFL_STATE;
_pSTATE_EMX_MMFL:      NOP 0;

      O #selected_FILL_FLZ.FL1;
      O #selected_FILL_FLZ.FL2;
      O #selected_VESSEL_SY.S1;
      O #selected_VESSEL_SY.S2;
      JCN _pSTATE_EMX_SMFL;
      L "idbEMX6".f[#p.child.EMX_SMFL].p.read.mc.STATE;
      T #p.read.EMX_SMFL_STATE;
_pSTATE_EMX_SMFL:      NOP 0;

      O #selected_FILL_FLZ.FL1;
      O #selected_FILL_FLZ.FL2;
      O #selected_VESSEL_SY.S1;
      O #selected_VESSEL_SY.S2;
      JCN _pSTATE_EMX_SMFLDRN;
      L "idbEMX4".f[#p.child.EMX_SMFLDRN].p.read.mc.STATE;
      T #p.read.EMX_SMFLDRN_STATE;
_pSTATE_EMX_SMFLDRN:      NOP 0;

      A #selected_VESSEL_SY.S1;
      JCN _pSTATE_EMX_TRANSFER1;
      L "idbEMX2".f[#p.child.EMX_TRANSFER1].p.read.mc.STATE;
      T #p.read.EMX_TRANSFER1_STATE;
_pSTATE_EMX_TRANSFER1:      NOP 0;

      A #selected_VESSEL_SY.S2;
      JCN _pSTATE_EMX_TRANSFER2;
      L "idbEMX2".f[#p.child.EMX_TRANSFER2].p.read.mc.STATE;
      T #p.read.EMX_TRANSFER2_STATE;
_pSTATE_EMX_TRANSFER2:      NOP 0;



NETWORK
TITLE = Set child commands
  //------------------------------------------------------------------------//
  // Set the child substate if no child mismatch:                           //
  //------------------------------------------------------------------------//
      AN #timeCheckChildStateExpired;
      A(;
      O #p.read.bmc.stateRUNNING;
      O #flags.substateCompleted;
      );
      JCN _noCommandOnChildMismatch;

      A "idbEMA1".f[#p.child.EMA_VESSEL].p.read.mc.modeAUTO;
      A "alwaysHigh";
      JCN _pSUBS_EMA_VESSEL;
      L #p.write.EMA_VESSEL_SUBS;
      T "idbEMA1".f[#p.child.EMA_VESSEL].p.write.mc.SUBS;
_pSUBS_EMA_VESSEL:      NOP 0;

      A "idbEMC1".f[#p.child.EMC_GAS].p.read.mc.modeAUTO;
      A "alwaysHigh";
      JCN _pSUBS_EMC_GAS;
      L #p.write.EMC_GAS_SUBS;
      T "idbEMC1".f[#p.child.EMC_GAS].p.write.mc.SUBS;
_pSUBS_EMC_GAS:      NOP 0;

      A "idbEMC2".f[#p.child.EMC_WATER].p.read.mc.modeAUTO;
      A "alwaysHigh";
      JCN _pSUBS_EMC_WATER;
      L #p.write.EMC_WATER_SUBS;
      T "idbEMC2".f[#p.child.EMC_WATER].p.write.mc.SUBS;
_pSUBS_EMC_WATER:      NOP 0;

      A "idbEMG1".f[#p.child.EMG_FILTER].p.read.mc.modeAUTO;
      A "alwaysHigh";
      JCN _pSUBS_EMG_FILTER;
      L #p.write.EMG_FILTER_SUBS;
      T "idbEMG1".f[#p.child.EMG_FILTER].p.write.mc.SUBS;
_pSUBS_EMG_FILTER:      NOP 0;

      A "idbEMM1".f[#p.child.EMM_VESSEL].p.read.mc.modeAUTO;
      A "alwaysHigh";
      JCN _pSUBS_EMM_VESSEL;
      L #p.write.EMM_VESSEL_SUBS;
      T "idbEMM1".f[#p.child.EMM_VESSEL].p.write.mc.SUBS;
_pSUBS_EMM_VESSEL:      NOP 0;

      A "idbEMT1".f[#p.child.EMT_HEX].p.read.mc.modeAUTO;
      A "alwaysHigh";
      JCN _pSUBS_EMT_HEX;
      L #p.write.EMT_HEX_SUBS;
      T "idbEMT1".f[#p.child.EMT_HEX].p.write.mc.SUBS;
_pSUBS_EMT_HEX:      NOP 0;

      A "idbEMV2".f[#p.child.EMV_INLET].p.read.mc.modeAUTO;
      A "alwaysHigh";
      JCN _pSUBS_EMV_INLET;
      L #p.write.EMV_INLET_SUBS;
      T "idbEMV2".f[#p.child.EMV_INLET].p.write.mc.SUBS;
_pSUBS_EMV_INLET:      NOP 0;

      A "idbEMV1".f[#p.child.EMV_VESSEL].p.read.mc.modeAUTO;
      A "alwaysHigh";
      JCN _pSUBS_EMV_VESSEL;
      L #p.write.EMV_VESSEL_SUBS;
      T "idbEMV1".f[#p.child.EMV_VESSEL].p.write.mc.SUBS;
_pSUBS_EMV_VESSEL:      NOP 0;

      A "idbEMX4".f[#p.child.EMX_DRAIN].p.read.mc.modeAUTO;
      A "alwaysHigh";
      JCN _pSUBS_EMX_DRAIN;
      L #p.write.EMX_DRAIN_SUBS;
      T "idbEMX4".f[#p.child.EMX_DRAIN].p.write.mc.SUBS;
_pSUBS_EMX_DRAIN:      NOP 0;

      A "idbEMX5".f[#p.child.EMX_FILL1].p.read.mc.modeAUTO;
      A #selected_FILL_FLZ.FL1;
      JCN _pSUBS_EMX_FILL1;
      L #p.write.EMX_FILL1_SUBS;
      T "idbEMX5".f[#p.child.EMX_FILL1].p.write.mc.SUBS;
_pSUBS_EMX_FILL1:      NOP 0;

      A "idbEMX5".f[#p.child.EMX_FILL2].p.read.mc.modeAUTO;
      A #selected_FILL_FLZ.FL2;
      JCN _pSUBS_EMX_FILL2;
      L #p.write.EMX_FILL2_SUBS;
      T "idbEMX5".f[#p.child.EMX_FILL2].p.write.mc.SUBS;
_pSUBS_EMX_FILL2:      NOP 0;

      A "idbEMX1".f[#p.child.EMX_MMFL].p.read.mc.modeAUTO;
      A "alwaysHigh";
      JCN _pSUBS_EMX_MMFL;
      L #p.write.EMX_MMFL_SUBS;
      T "idbEMX1".f[#p.child.EMX_MMFL].p.write.mc.SUBS;
_pSUBS_EMX_MMFL:      NOP 0;

      A "idbEMX6".f[#p.child.EMX_SMFL].p.read.mc.modeAUTO;
      O #selected_FILL_FLZ.FL1;
      O #selected_FILL_FLZ.FL2;
      O #selected_VESSEL_SY.S1;
      O #selected_VESSEL_SY.S2;
      JCN _pSUBS_EMX_SMFL;
      L #p.write.EMX_SMFL_SUBS;
      T "idbEMX6".f[#p.child.EMX_SMFL].p.write.mc.SUBS;
_pSUBS_EMX_SMFL:      NOP 0;

      A "idbEMX4".f[#p.child.EMX_SMFLDRN].p.read.mc.modeAUTO;
      O #selected_FILL_FLZ.FL1;
      O #selected_FILL_FLZ.FL2;
      O #selected_VESSEL_SY.S1;
      O #selected_VESSEL_SY.S2;
      JCN _pSUBS_EMX_SMFLDRN;
      L #p.write.EMX_SMFLDRN_SUBS;
      T "idbEMX4".f[#p.child.EMX_SMFLDRN].p.write.mc.SUBS;
_pSUBS_EMX_SMFLDRN:      NOP 0;

      A "idbEMX2".f[#p.child.EMX_TRANSFER1].p.read.mc.modeAUTO;
      A #selected_VESSEL_SY.S1;
      JCN _pSUBS_EMX_TRANSFER1;
      L #p.write.EMX_TRANSFER1_SUBS;
      T "idbEMX2".f[#p.child.EMX_TRANSFER1].p.write.mc.SUBS;
_pSUBS_EMX_TRANSFER1:      NOP 0;

      A "idbEMX2".f[#p.child.EMX_TRANSFER2].p.read.mc.modeAUTO;
      A #selected_VESSEL_SY.S2;
      JCN _pSUBS_EMX_TRANSFER2;
      L #p.write.EMX_TRANSFER2_SUBS;
      T "idbEMX2".f[#p.child.EMX_TRANSFER2].p.write.mc.SUBS;
_pSUBS_EMX_TRANSFER2:      NOP 0;


  //------------------------------------------------------------------------//
  // Set the child command if no child mismatch:                            //
  //------------------------------------------------------------------------//
      A "idbEMA1".f[#p.child.EMA_VESSEL].p.read.mc.modeAUTO;
      A "alwaysHigh";
      JCN _pCMD_EMA_VESSEL;
      L #p.write.EMA_VESSEL_CMD;
      T "idbEMA1".f[#p.child.EMA_VESSEL].p.write.mc.CMD;
      T #childReqCMD.EMA_VESSEL;
_pCMD_EMA_VESSEL:      NOP 0;

      A "idbEMC1".f[#p.child.EMC_GAS].p.read.mc.modeAUTO;
      A "alwaysHigh";
      JCN _pCMD_EMC_GAS;
      L #p.write.EMC_GAS_CMD;
      T "idbEMC1".f[#p.child.EMC_GAS].p.write.mc.CMD;
      T #childReqCMD.EMC_GAS;
_pCMD_EMC_GAS:      NOP 0;

      A "idbEMC2".f[#p.child.EMC_WATER].p.read.mc.modeAUTO;
      A "alwaysHigh";
      JCN _pCMD_EMC_WATER;
      L #p.write.EMC_WATER_CMD;
      T "idbEMC2".f[#p.child.EMC_WATER].p.write.mc.CMD;
      T #childReqCMD.EMC_WATER;
_pCMD_EMC_WATER:      NOP 0;

      A "idbEMG1".f[#p.child.EMG_FILTER].p.read.mc.modeAUTO;
      A "alwaysHigh";
      JCN _pCMD_EMG_FILTER;
      L #p.write.EMG_FILTER_CMD;
      T "idbEMG1".f[#p.child.EMG_FILTER].p.write.mc.CMD;
      T #childReqCMD.EMG_FILTER;
_pCMD_EMG_FILTER:      NOP 0;

      A "idbEMM1".f[#p.child.EMM_VESSEL].p.read.mc.modeAUTO;
      A "alwaysHigh";
      JCN _pCMD_EMM_VESSEL;
      L #p.write.EMM_VESSEL_CMD;
      T "idbEMM1".f[#p.child.EMM_VESSEL].p.write.mc.CMD;
      T #childReqCMD.EMM_VESSEL;
_pCMD_EMM_VESSEL:      NOP 0;

      A "idbEMT1".f[#p.child.EMT_HEX].p.read.mc.modeAUTO;
      A "alwaysHigh";
      JCN _pCMD_EMT_HEX;
      L #p.write.EMT_HEX_CMD;
      T "idbEMT1".f[#p.child.EMT_HEX].p.write.mc.CMD;
      T #childReqCMD.EMT_HEX;
_pCMD_EMT_HEX:      NOP 0;

      A "idbEMV2".f[#p.child.EMV_INLET].p.read.mc.modeAUTO;
      A "alwaysHigh";
      JCN _pCMD_EMV_INLET;
      L #p.write.EMV_INLET_CMD;
      T "idbEMV2".f[#p.child.EMV_INLET].p.write.mc.CMD;
      T #childReqCMD.EMV_INLET;
_pCMD_EMV_INLET:      NOP 0;

      A "idbEMV1".f[#p.child.EMV_VESSEL].p.read.mc.modeAUTO;
      A "alwaysHigh";
      JCN _pCMD_EMV_VESSEL;
      L #p.write.EMV_VESSEL_CMD;
      T "idbEMV1".f[#p.child.EMV_VESSEL].p.write.mc.CMD;
      T #childReqCMD.EMV_VESSEL;
_pCMD_EMV_VESSEL:      NOP 0;

      A "idbEMX4".f[#p.child.EMX_DRAIN].p.read.mc.modeAUTO;
      A "alwaysHigh";
      JCN _pCMD_EMX_DRAIN;
      L #p.write.EMX_DRAIN_CMD;
      T "idbEMX4".f[#p.child.EMX_DRAIN].p.write.mc.CMD;
      T #childReqCMD.EMX_DRAIN;
_pCMD_EMX_DRAIN:      NOP 0;

      A "idbEMX5".f[#p.child.EMX_FILL1].p.read.mc.modeAUTO;
      A #selected_FILL_FLZ.FL1;
      JCN _pCMD_EMX_FILL1;
      L #p.write.EMX_FILL1_CMD;
      T "idbEMX5".f[#p.child.EMX_FILL1].p.write.mc.CMD;
      T #childReqCMD.EMX_FILL1;
_pCMD_EMX_FILL1:      NOP 0;

      A "idbEMX5".f[#p.child.EMX_FILL2].p.read.mc.modeAUTO;
      A #selected_FILL_FLZ.FL2;
      JCN _pCMD_EMX_FILL2;
      L #p.write.EMX_FILL2_CMD;
      T "idbEMX5".f[#p.child.EMX_FILL2].p.write.mc.CMD;
      T #childReqCMD.EMX_FILL2;
_pCMD_EMX_FILL2:      NOP 0;

      A "idbEMX1".f[#p.child.EMX_MMFL].p.read.mc.modeAUTO;
      A "alwaysHigh";
      JCN _pCMD_EMX_MMFL;
      L #p.write.EMX_MMFL_CMD;
      T "idbEMX1".f[#p.child.EMX_MMFL].p.write.mc.CMD;
      T #childReqCMD.EMX_MMFL;
_pCMD_EMX_MMFL:      NOP 0;

      A "idbEMX6".f[#p.child.EMX_SMFL].p.read.mc.modeAUTO;
      O #selected_FILL_FLZ.FL1;
      O #selected_FILL_FLZ.FL2;
      O #selected_VESSEL_SY.S1;
      O #selected_VESSEL_SY.S2;
      JCN _pCMD_EMX_SMFL;
      L #p.write.EMX_SMFL_CMD;
      T "idbEMX6".f[#p.child.EMX_SMFL].p.write.mc.CMD;
      T #childReqCMD.EMX_SMFL;
_pCMD_EMX_SMFL:      NOP 0;

      A "idbEMX4".f[#p.child.EMX_SMFLDRN].p.read.mc.modeAUTO;
      O #selected_FILL_FLZ.FL1;
      O #selected_FILL_FLZ.FL2;
      O #selected_VESSEL_SY.S1;
      O #selected_VESSEL_SY.S2;
      JCN _pCMD_EMX_SMFLDRN;
      L #p.write.EMX_SMFLDRN_CMD;
      T "idbEMX4".f[#p.child.EMX_SMFLDRN].p.write.mc.CMD;
      T #childReqCMD.EMX_SMFLDRN;
_pCMD_EMX_SMFLDRN:      NOP 0;

      A "idbEMX2".f[#p.child.EMX_TRANSFER1].p.read.mc.modeAUTO;
      A #selected_VESSEL_SY.S1;
      JCN _pCMD_EMX_TRANSFER1;
      L #p.write.EMX_TRANSFER1_CMD;
      T "idbEMX2".f[#p.child.EMX_TRANSFER1].p.write.mc.CMD;
      T #childReqCMD.EMX_TRANSFER1;
_pCMD_EMX_TRANSFER1:      NOP 0;

      A "idbEMX2".f[#p.child.EMX_TRANSFER2].p.read.mc.modeAUTO;
      A #selected_VESSEL_SY.S2;
      JCN _pCMD_EMX_TRANSFER2;
      L #p.write.EMX_TRANSFER2_CMD;
      T "idbEMX2".f[#p.child.EMX_TRANSFER2].p.write.mc.CMD;
      T #childReqCMD.EMX_TRANSFER2;
_pCMD_EMX_TRANSFER2:      NOP 0;


  //------------------------------------------------------------------------//
  // Write the non-boolean child parameters if no child mismatch:           //
  //------------------------------------------------------------------------//
      A "idbEMX4".f[#p.child.EMX_DRAIN].p.read.mc.modeAUTO;
      JCN _pSFCChildWrite_EMX_DRAIN_CLOSED_TIME;
      L #p.write.EMX_DRAIN_CLOSED_TIME;
      T "idbEMX4".f[#p.child.EMX_DRAIN].p.write.CLOSED_TIME;
_pSFCChildWrite_EMX_DRAIN_CLOSED_TIME:      NOP 0;

      A "idbEMX4".f[#p.child.EMX_DRAIN].p.read.mc.modeAUTO;
      JCN _pSFCChildWrite_EMX_DRAIN_OPENED_TIME;
      L #p.write.EMX_DRAIN_OPENED_TIME;
      T "idbEMX4".f[#p.child.EMX_DRAIN].p.write.OPENED_TIME;
_pSFCChildWrite_EMX_DRAIN_OPENED_TIME:      NOP 0;

      A "idbEMX4".f[#p.child.EMX_SMFLDRN].p.read.mc.modeAUTO;
      JCN _pSFCChildWrite_EMX_SMFLDRN_CLOSED_TIME;
      L #p.write.EMX_SMFLDRN_CLOSED_TIME;
      T "idbEMX4".f[#p.child.EMX_SMFLDRN].p.write.CLOSED_TIME;
_pSFCChildWrite_EMX_SMFLDRN_CLOSED_TIME:      NOP 0;

      A "idbEMX4".f[#p.child.EMX_SMFLDRN].p.read.mc.modeAUTO;
      JCN _pSFCChildWrite_EMX_SMFLDRN_OPENED_TIME;
      L #p.write.EMX_SMFLDRN_OPENED_TIME;
      T "idbEMX4".f[#p.child.EMX_SMFLDRN].p.write.OPENED_TIME;
_pSFCChildWrite_EMX_SMFLDRN_OPENED_TIME:      NOP 0;

      A "idbEMX2".f[#p.child.EMX_TRANSFER1].p.read.mc.modeAUTO;
      JCN _pSFCChildWrite_EMX_TRANSFER1_FILL_FLZ;
      L #p.write.EMX_TRANSFER1_FILL_FLZ;
      T "idbEMX2".f[#p.child.EMX_TRANSFER1].p.write.FILL_FLZ;
_pSFCChildWrite_EMX_TRANSFER1_FILL_FLZ:      NOP 0;

      A "idbEMX2".f[#p.child.EMX_TRANSFER1].p.read.mc.modeAUTO;
      JCN _pSFCChildWrite_EMX_TRANSFER1_VESSEL_MX;
      L #p.write.EMX_TRANSFER1_VESSEL_MX;
      T "idbEMX2".f[#p.child.EMX_TRANSFER1].p.write.VESSEL_MX;
_pSFCChildWrite_EMX_TRANSFER1_VESSEL_MX:      NOP 0;

      A "idbEMX2".f[#p.child.EMX_TRANSFER2].p.read.mc.modeAUTO;
      JCN _pSFCChildWrite_EMX_TRANSFER2_FILL_FLZ;
      L #p.write.EMX_TRANSFER2_FILL_FLZ;
      T "idbEMX2".f[#p.child.EMX_TRANSFER2].p.write.FILL_FLZ;
_pSFCChildWrite_EMX_TRANSFER2_FILL_FLZ:      NOP 0;

      A "idbEMX2".f[#p.child.EMX_TRANSFER2].p.read.mc.modeAUTO;
      JCN _pSFCChildWrite_EMX_TRANSFER2_VESSEL_MX;
      L #p.write.EMX_TRANSFER2_VESSEL_MX;
      T "idbEMX2".f[#p.child.EMX_TRANSFER2].p.write.VESSEL_MX;
_pSFCChildWrite_EMX_TRANSFER2_VESSEL_MX:      NOP 0;

      A "idbEMA1".f[#p.child.EMA_VESSEL].p.read.mc.modeAUTO;
      JCN _pSFCChildWrite_EMA_VESSEL_RUNTIME_H;
      L #p.write.EMA_VESSEL_RUNTIME_H;
      T "idbEMA1".f[#p.child.EMA_VESSEL].p.write.RUNTIME_H;
_pSFCChildWrite_EMA_VESSEL_RUNTIME_H:      NOP 0;

      A "idbEMA1".f[#p.child.EMA_VESSEL].p.read.mc.modeAUTO;
      JCN _pSFCChildWrite_EMA_VESSEL_RUNTIME_M;
      L #p.write.EMA_VESSEL_RUNTIME_M;
      T "idbEMA1".f[#p.child.EMA_VESSEL].p.write.RUNTIME_M;
_pSFCChildWrite_EMA_VESSEL_RUNTIME_M:      NOP 0;

      A "idbEMA1".f[#p.child.EMA_VESSEL].p.read.mc.modeAUTO;
      JCN _pSFCChildWrite_EMA_VESSEL_RUNTIME_S;
      L #p.write.EMA_VESSEL_RUNTIME_S;
      T "idbEMA1".f[#p.child.EMA_VESSEL].p.write.RUNTIME_S;
_pSFCChildWrite_EMA_VESSEL_RUNTIME_S:      NOP 0;

      A "idbEMA1".f[#p.child.EMA_VESSEL].p.read.mc.modeAUTO;
      JCN _pSFCChildWrite_EMA_VESSEL_SETPOINT;
      L #p.write.EMA_VESSEL_SETPOINT;
      T "idbEMA1".f[#p.child.EMA_VESSEL].p.write.SETPOINT;
_pSFCChildWrite_EMA_VESSEL_SETPOINT:      NOP 0;

      A "idbEMC1".f[#p.child.EMC_GAS].p.read.mc.modeAUTO;
      JCN _pSFCChildWrite_EMC_GAS_MEDIUM_GAS;
      L #p.write.EMC_GAS_MEDIUM_GAS;
      T "idbEMC1".f[#p.child.EMC_GAS].p.write.MEDIUM_GAS;
_pSFCChildWrite_EMC_GAS_MEDIUM_GAS:      NOP 0;

      A "idbEMC1".f[#p.child.EMC_GAS].p.read.mc.modeAUTO;
      JCN _pSFCChildWrite_EMC_GAS_SETPOINT;
      L #p.write.EMC_GAS_SETPOINT;
      T "idbEMC1".f[#p.child.EMC_GAS].p.write.SETPOINT;
_pSFCChildWrite_EMC_GAS_SETPOINT:      NOP 0;

      A "idbEMC2".f[#p.child.EMC_WATER].p.read.mc.modeAUTO;
      JCN _pSFCChildWrite_EMC_WATER_MASS_CHARGE;
      L #p.write.EMC_WATER_MASS_CHARGE;
      T "idbEMC2".f[#p.child.EMC_WATER].p.write.MASS_CHARGE;
_pSFCChildWrite_EMC_WATER_MASS_CHARGE:      NOP 0;

      A "idbEMC2".f[#p.child.EMC_WATER].p.read.mc.modeAUTO;
      JCN _pSFCChildWrite_EMC_WATER_MEDIUM_LIQUID;
      L #p.write.EMC_WATER_MEDIUM_LIQUID;
      T "idbEMC2".f[#p.child.EMC_WATER].p.write.MEDIUM_LIQUID;
_pSFCChildWrite_EMC_WATER_MEDIUM_LIQUID:      NOP 0;

      A "idbEMC2".f[#p.child.EMC_WATER].p.read.mc.modeAUTO;
      JCN _pSFCChildWrite_EMC_WATER_RUNTIME;
      L #p.write.EMC_WATER_RUNTIME;
      T "idbEMC2".f[#p.child.EMC_WATER].p.write.RUNTIME;
_pSFCChildWrite_EMC_WATER_RUNTIME:      NOP 0;

      A "idbEMC2".f[#p.child.EMC_WATER].p.read.mc.modeAUTO;
      JCN _pSFCChildWrite_EMC_WATER_TIMEOUT;
      L #p.write.EMC_WATER_TIMEOUT;
      T "idbEMC2".f[#p.child.EMC_WATER].p.write.TIMEOUT;
_pSFCChildWrite_EMC_WATER_TIMEOUT:      NOP 0;

      A "idbEMM1".f[#p.child.EMM_VESSEL].p.read.mc.modeAUTO;
      JCN _pSFCChildWrite_EMM_VESSEL_SETTLING_TIME;
      L #p.write.EMM_VESSEL_SETTLING_TIME;
      T "idbEMM1".f[#p.child.EMM_VESSEL].p.write.SETTLING_TIME;
_pSFCChildWrite_EMM_VESSEL_SETTLING_TIME:      NOP 0;

      A "idbEMV2".f[#p.child.EMV_INLET].p.read.mc.modeAUTO;
      JCN _pSFCChildWrite_EMV_INLET_OPENED_TIME;
      L #p.write.EMV_INLET_OPENED_TIME;
      T "idbEMV2".f[#p.child.EMV_INLET].p.write.OPENED_TIME;
_pSFCChildWrite_EMV_INLET_OPENED_TIME:      NOP 0;

      A "idbEMT1".f[#p.child.EMT_HEX].p.read.mc.modeAUTO;
      JCN _pSFCChildWrite_EMT_HEX_SETPOINT;
      L #p.write.EMT_HEX_SETPOINT;
      T "idbEMT1".f[#p.child.EMT_HEX].p.write.SETPOINT;
_pSFCChildWrite_EMT_HEX_SETPOINT:      NOP 0;

      A "idbEMT1".f[#p.child.EMT_HEX].p.read.mc.modeAUTO;
      JCN _pSFCChildWrite_EMT_HEX_DRAIN_TIME;
      L #p.write.EMT_HEX_DRAIN_TIME;
      T "idbEMT1".f[#p.child.EMT_HEX].p.write.DRAIN_TIME;
_pSFCChildWrite_EMT_HEX_DRAIN_TIME:      NOP 0;


  //------------------------------------------------------------------------//
  // Write the boolean child parameters if no child mismatch:               //
  //------------------------------------------------------------------------//

_noCommandOnChildMismatch:      NOP 0;


NETWORK
TITLE = CALL SFC UO_MX_CIP if CIP running
//------------------------------------------------------------------------//
// SFC CALL   SFC CALL   SFC CALL   SFC CALL   SFC CALL   SFC CALL   SFC  //
//                                                                        //
// Call the SFC function if this is the running substate. This has to be  //
// called even if the block is not running so the SFC can process all     //
// commmands:                                                             //
//------------------------------------------------------------------------//
      A #subsRunning.CIP;
      JCN _notSFC_1_CIP;
      CALL #UO_MX_CIP
      (  _emx_drain_state            := "idbEMX4".f[#p.child.EMX_DRAIN].p.read.mc.STATE , 
         _emv_inlet_state            := "idbEMV2".f[#p.child.EMV_INLET].p.read.mc.STATE , 
         _emc_gas_setpoint           := #p.write.EMC_GAS_SETPOINT , 
         _emm_vessel_settling_time   := #p.write.EMM_VESSEL_SETTLING_TIME , 
         _vessel_mx                  := #p.write.VESSEL_MX , 
         _emm_vessel_mass_tare       := "idbEMM1".f[#p.child.EMM_VESSEL].p.read.MASS_TARE , 
         _emm_vessel_state           := "idbEMM1".f[#p.child.EMM_VESSEL].p.read.mc.STATE , 
         _emx_mmfl_state             := "idbEMX1".f[#p.child.EMX_MMFL].p.read.mc.STATE , 
         _emv_vessel_state           := "idbEMV1".f[#p.child.EMV_VESSEL].p.read.mc.STATE , 
         _emc_water_state            := "idbEMC2".f[#p.child.EMC_WATER].p.read.mc.STATE , 
         _emc_gas_state              := "idbEMC1".f[#p.child.EMC_GAS].p.read.mc.STATE , 
         _ema_vessel_state           := "idbEMA1".f[#p.child.EMA_VESSEL].p.read.mc.STATE , 
         _emx_drain_subs             := #p.write.EMX_DRAIN_SUBS , 
         _emx_drain_cmd              := #p.write.EMX_DRAIN_CMD , 
         _emv_inlet_opened_time      := #p.write.EMV_INLET_OPENED_TIME , 
         _emv_inlet_cmd              := #p.write.EMV_INLET_CMD , 
         _emv_inlet_subs             := #p.write.EMV_INLET_SUBS , 
         _emc_water_mass_charge      := #p.write.EMC_WATER_MASS_CHARGE , 
         _emc_water_timeout          := #p.write.EMC_WATER_TIMEOUT , 
         _emm_vessel_subs            := #p.write.EMM_VESSEL_SUBS , 
         _emm_vessel_cmd             := #p.write.EMM_VESSEL_CMD , 
         _emc_water_runtime          := #p.write.EMC_WATER_RUNTIME , 
         _emx_mmfl_subs              := #p.write.EMX_MMFL_SUBS , 
         _emx_mmfl_cmd               := #p.write.EMX_MMFL_CMD , 
         _ema_vessel_runtime_s       := #p.write.EMA_VESSEL_RUNTIME_S , 
         _ema_vessel_runtime_m       := #p.write.EMA_VESSEL_RUNTIME_M , 
         _ema_vessel_runtime_h       := #p.write.EMA_VESSEL_RUNTIME_H , 
         _ema_vessel_setpoint        := #p.write.EMA_VESSEL_SETPOINT , 
         _emc_gas_medium_gas         := #p.write.EMC_GAS_MEDIUM_GAS , 
         _emc_water_medium_liquid    := #p.write.EMC_WATER_MEDIUM_LIQUID , 
         _emv_vessel_subs            := #p.write.EMV_VESSEL_SUBS , 
         _emv_vessel_cmd             := #p.write.EMV_VESSEL_CMD , 
         _emc_water_subs             := #p.write.EMC_WATER_SUBS , 
         _emc_water_cmd              := #p.write.EMC_WATER_CMD , 
         _emc_gas_subs               := #p.write.EMC_GAS_SUBS , 
         _emc_gas_cmd                := #p.write.EMC_GAS_CMD , 
         _ema_vessel_subs            := #p.write.EMA_VESSEL_SUBS , 
         _ema_vessel_cmd             := #p.write.EMA_VESSEL_CMD , 
         dummy                       := #dummy
      );
_notSFC_1_CIP:      NOP 0;
NETWORK
TITLE = CALL SFC UO_MX_FILL if FILL running
//------------------------------------------------------------------------//
// SFC CALL   SFC CALL   SFC CALL   SFC CALL   SFC CALL   SFC CALL   SFC  //
//                                                                        //
// Call the SFC function if this is the running substate. This has to be  //
// called even if the block is not running so the SFC can process all     //
// commmands:                                                             //
//------------------------------------------------------------------------//
      A #subsRunning.FILL;
      JCN _notSFC_5_FILL;
      CALL #UO_MX_FILL
      (  _emx_fill_state             := "idbEMX5".f[#p.select.EMX_FILL].p.read.mc.STATE , 
         _vessel_mx                  := #p.write.VESSEL_MX , 
         _fill_flz                   := #p.write.FILL_FLZ , 
         _vessel_sy                  := #p.write.VESSEL_SY , 
         _emm_vessel_mass_nett       := "idbEMM1".f[#p.child.EMM_VESSEL].p.read.MASS_NETT , 
         _emv_vessel_state           := "idbEMV1".f[#p.child.EMV_VESSEL].p.read.mc.STATE , 
         _emt_hex_state              := "idbEMT1".f[#p.child.EMT_HEX].p.read.mc.STATE , 
         _emx_smfl_state             := "idbEMX6".f[#p.child.EMX_SMFL].p.read.mc.STATE , 
         _emx_transfer_state         := "idbEMX2".f[#p.select.EMX_TRANSFER].p.read.mc.STATE , 
         _emc_gas_state              := "idbEMC1".f[#p.child.EMC_GAS].p.read.mc.STATE , 
         _emc_water_state            := "idbEMC2".f[#p.child.EMC_WATER].p.read.mc.STATE , 
         _emx_mmfl_state             := "idbEMX1".f[#p.child.EMX_MMFL].p.read.mc.STATE , 
         _ema_vessel_state           := "idbEMA1".f[#p.child.EMA_VESSEL].p.read.mc.STATE , 
         _emx_fill_cmd               := #p.select.EMX_FILL_CMD , 
         _emx_fill_subs              := #p.select.EMX_FILL_SUBS , 
         _emt_hex_setpoint           := #p.write.EMT_HEX_SETPOINT , 
         _emv_vessel_subs            := #p.write.EMV_VESSEL_SUBS , 
         _emv_vessel_cmd             := #p.write.EMV_VESSEL_CMD , 
         _emt_hex_subs               := #p.write.EMT_HEX_SUBS , 
         _emt_hex_cmd                := #p.write.EMT_HEX_CMD , 
         _emx_smfl_cmd               := #p.write.EMX_SMFL_CMD , 
         _emx_smfl_subs              := #p.write.EMX_SMFL_SUBS , 
         _emx_transfer_cmd           := #p.select.EMX_TRANSFER_CMD , 
         _emx_transfer_subs          := #p.select.EMX_TRANSFER_SUBS , 
         _emx_mmfl_cmd               := #p.write.EMX_MMFL_CMD , 
         _emx_mmfl_subs              := #p.write.EMX_MMFL_SUBS , 
         _emc_gas_subs               := #p.write.EMC_GAS_SUBS , 
         _emc_water_subs             := #p.write.EMC_WATER_SUBS , 
         _emc_gas_setpoint           := #p.write.EMC_GAS_SETPOINT , 
         _emc_water_cmd              := #p.write.EMC_WATER_CMD , 
         _emc_gas_cmd                := #p.write.EMC_GAS_CMD , 
         _emc_gas_medium_gas         := #p.write.EMC_GAS_MEDIUM_GAS , 
         _ema_vessel_subs            := #p.write.EMA_VESSEL_SUBS , 
         _ema_vessel_cmd             := #p.write.EMA_VESSEL_CMD , 
         _emx_smfldrn_hygiene        := "idbEMX4".f[#p.child.EMX_SMFLDRN].p.read.mc.HYGIENE , 
         _emx_smfl_hygiene           := "idbEMX6".f[#p.child.EMX_SMFL].p.read.mc.HYGIENE , 
         _emx_transfer_hygiene       := "idbEMX2".f[#p.select.EMX_TRANSFER].p.read.mc.HYGIENE , 
         _emx_fill_hygiene           := "idbEMX5".f[#p.select.EMX_FILL].p.read.mc.HYGIENE , 
         dummy                       := #dummy
      );
_notSFC_5_FILL:      NOP 0;
NETWORK
TITLE = CALL SFC UO_MX_FILTER if FILTER running
//------------------------------------------------------------------------//
// SFC CALL   SFC CALL   SFC CALL   SFC CALL   SFC CALL   SFC CALL   SFC  //
//                                                                        //
// Call the SFC function if this is the running substate. This has to be  //
// called even if the block is not running so the SFC can process all     //
// commmands:                                                             //
//------------------------------------------------------------------------//
      A #subsRunning.FILTER;
      JCN _notSFC_3_FILTER;
      CALL #UO_MX_FILTER
      (  _vessel_mx                  := #p.write.VESSEL_MX , 
         _vessel_sy                  := #p.write.VESSEL_SY , 
         _emv_vessel_ti_vessel_pv    := "idbEMV1".f[#p.child.EMV_VESSEL].p.read.TI_VESSEL_PV , 
         _emm_vessel_mass_nett       := "idbEMM1".f[#p.child.EMM_VESSEL].p.read.MASS_NETT , 
         _emv_vessel_state           := "idbEMV1".f[#p.child.EMV_VESSEL].p.read.mc.STATE , 
         _emt_hex_state              := "idbEMT1".f[#p.child.EMT_HEX].p.read.mc.STATE , 
         _temp_filt                  := #p.write.TEMP_FILT , 
         _emx_smfl_state             := "idbEMX6".f[#p.child.EMX_SMFL].p.read.mc.STATE , 
         _emx_transfer_state         := "idbEMX2".f[#p.select.EMX_TRANSFER].p.read.mc.STATE , 
         _sync_read_start_hpca       := #p.read.SYNC_READ_START_HPCA , 
         _emc_gas_state              := "idbEMC1".f[#p.child.EMC_GAS].p.read.mc.STATE , 
         _emc_water_state            := "idbEMC2".f[#p.child.EMC_WATER].p.read.mc.STATE , 
         _emx_mmfl_state             := "idbEMX1".f[#p.child.EMX_MMFL].p.read.mc.STATE , 
         _ema_vessel_state           := "idbEMA1".f[#p.child.EMA_VESSEL].p.read.mc.STATE , 
         _sync_read_filtration_complete:= #p.read.SYNC_READ_FILTRATION_COMPLETE , 
         _emt_hex_setpoint           := #p.write.EMT_HEX_SETPOINT , 
         _emv_vessel_subs            := #p.write.EMV_VESSEL_SUBS , 
         _emv_vessel_cmd             := #p.write.EMV_VESSEL_CMD , 
         _emt_hex_subs               := #p.write.EMT_HEX_SUBS , 
         _emt_hex_cmd                := #p.write.EMT_HEX_CMD , 
         _emx_smfl_cmd               := #p.write.EMX_SMFL_CMD , 
         _emx_smfl_subs              := #p.write.EMX_SMFL_SUBS , 
         _emx_transfer_cmd           := #p.select.EMX_TRANSFER_CMD , 
         _emx_transfer_subs          := #p.select.EMX_TRANSFER_SUBS , 
         _emx_mmfl_cmd               := #p.write.EMX_MMFL_CMD , 
         _emx_mmfl_subs              := #p.write.EMX_MMFL_SUBS , 
         _emc_gas_subs               := #p.write.EMC_GAS_SUBS , 
         _emc_water_subs             := #p.write.EMC_WATER_SUBS , 
         _emc_gas_setpoint           := #p.write.EMC_GAS_SETPOINT , 
         _emc_water_cmd              := #p.write.EMC_WATER_CMD , 
         _emc_gas_cmd                := #p.write.EMC_GAS_CMD , 
         _emc_gas_medium_gas         := #p.write.EMC_GAS_MEDIUM_GAS , 
         _ema_vessel_subs            := #p.write.EMA_VESSEL_SUBS , 
         _ema_vessel_cmd             := #p.write.EMA_VESSEL_CMD , 
         _sync_write_ready_hpca      := #p.write.SYNC_WRITE_READY_HPCA , 
         _emx_smfldrn_hygiene        := "idbEMX4".f[#p.child.EMX_SMFLDRN].p.read.mc.HYGIENE , 
         _emx_smfl_hygiene           := "idbEMX6".f[#p.child.EMX_SMFL].p.read.mc.HYGIENE , 
         _emx_transfer_hygiene       := "idbEMX2".f[#p.select.EMX_TRANSFER].p.read.mc.HYGIENE , 
         dummy                       := #dummy
      );
_notSFC_3_FILTER:      NOP 0;
NETWORK
TITLE = CALL SFC UO_MX_MAKE if MAKE running
//------------------------------------------------------------------------//
// SFC CALL   SFC CALL   SFC CALL   SFC CALL   SFC CALL   SFC CALL   SFC  //
//                                                                        //
// Call the SFC function if this is the running substate. This has to be  //
// called even if the block is not running so the SFC can process all     //
// commmands:                                                             //
//------------------------------------------------------------------------//
      A #subsRunning.MAKE;
      JCN _notSFC_1_MAKE;
      CALL #UO_MX_MAKE
      (  _emv_inlet_state            := "idbEMV2".f[#p.child.EMV_INLET].p.read.mc.STATE , 
         _emm_vessel_settling_time   := #p.write.EMM_VESSEL_SETTLING_TIME , 
         _emm_vessel_mass_nett       := "idbEMM1".f[#p.child.EMM_VESSEL].p.read.MASS_NETT , 
         _vessel_mx                  := #p.write.VESSEL_MX , 
         _emm_vessel_state           := "idbEMM1".f[#p.child.EMM_VESSEL].p.read.mc.STATE , 
         _ema_vessel_state           := "idbEMA1".f[#p.child.EMA_VESSEL].p.read.mc.STATE , 
         _emv_vessel_state           := "idbEMV1".f[#p.child.EMV_VESSEL].p.read.mc.STATE , 
         _fp_time_make_agit_h        := #p.write.FP_TIME_MAKE_AGIT_H , 
         _fp_time_make_agit_m        := #p.write.FP_TIME_MAKE_AGIT_M , 
         _fp_time_make_agit_s        := #p.write.FP_TIME_MAKE_AGIT_S , 
         _fp_speed_setpoint          := #p.write.FP_SPEED_SETPOINT , 
         _fp_charge_wfi_make         := #p.write.FP_CHARGE_WFI_MAKE , 
         _emc_water_state            := "idbEMC2".f[#p.child.EMC_WATER].p.read.mc.STATE , 
         _emc_gas_state              := "idbEMC1".f[#p.child.EMC_GAS].p.read.mc.STATE , 
         _emv_inlet_subs             := #p.write.EMV_INLET_SUBS , 
         _emv_inlet_cmd              := #p.write.EMV_INLET_CMD , 
         _make_active                := #p.write.MAKE_ACTIVE , 
         _emc_gas_setpoint           := #p.write.EMC_GAS_SETPOINT , 
         _emc_water_timeout          := #p.write.EMC_WATER_TIMEOUT , 
         _emm_vessel_subs            := #p.write.EMM_VESSEL_SUBS , 
         _emm_vessel_cmd             := #p.write.EMM_VESSEL_CMD , 
         _ema_vessel_subs            := #p.write.EMA_VESSEL_SUBS , 
         _ema_vessel_cmd             := #p.write.EMA_VESSEL_CMD , 
         _emv_vessel_subs            := #p.write.EMV_VESSEL_SUBS , 
         _emv_vessel_cmd             := #p.write.EMV_VESSEL_CMD , 
         _ema_vessel_runtime_h       := #p.write.EMA_VESSEL_RUNTIME_H , 
         _ema_vessel_runtime_s       := #p.write.EMA_VESSEL_RUNTIME_S , 
         _ema_vessel_runtime_m       := #p.write.EMA_VESSEL_RUNTIME_M , 
         _ema_vessel_setpoint        := #p.write.EMA_VESSEL_SETPOINT , 
         _emc_water_mass_charge      := #p.write.EMC_WATER_MASS_CHARGE , 
         _emc_water_medium_liquid    := #p.write.EMC_WATER_MEDIUM_LIQUID , 
         _emc_water_subs             := #p.write.EMC_WATER_SUBS , 
         _emc_water_cmd              := #p.write.EMC_WATER_CMD , 
         _emc_gas_medium_gas         := #p.write.EMC_GAS_MEDIUM_GAS , 
         _emc_gas_subs               := #p.write.EMC_GAS_SUBS , 
         _emc_gas_cmd                := #p.write.EMC_GAS_CMD , 
         _cmd_complete               := #p.write.CMD_COMPLETE , 
         _cmd_manway                 := #p.write.CMD_MANWAY , 
         _wfi_added                  := #p.write.WFI_ADDED , 
         _cmd_charge                 := #p.write.CMD_CHARGE , 
         _cmd_mix                    := #p.write.CMD_MIX , 
         _cmd_measure                := #p.write.CMD_MEASURE , 
         dummy                       := #dummy
      );
_notSFC_1_MAKE:      NOP 0;
NETWORK
TITLE = CALL SFC UO_MX_SETUP if SETUP running
//------------------------------------------------------------------------//
// SFC CALL   SFC CALL   SFC CALL   SFC CALL   SFC CALL   SFC CALL   SFC  //
//                                                                        //
// Call the SFC function if this is the running substate. This has to be  //
// called even if the block is not running so the SFC can process all     //
// commmands:                                                             //
//------------------------------------------------------------------------//
      A #subsRunning.SETUP;
      JCN _notSFC_3_SETUP;
      CALL #UO_MX_SETUP
      (  _emm_vessel_mi_vessel_pv    := "idbEMM1".f[#p.child.EMM_VESSEL].p.read.MI_VESSEL_PV , 
         _emx_drain_state            := "idbEMX4".f[#p.child.EMX_DRAIN].p.read.mc.STATE , 
         _emv_inlet_state            := "idbEMV2".f[#p.child.EMV_INLET].p.read.mc.STATE , 
         _emt_hex_state              := "idbEMT1".f[#p.child.EMT_HEX].p.read.mc.STATE , 
         _vessel_mx                  := #p.write.VESSEL_MX , 
         _emc_gas_pi_vessel_pv       := "idbEMC1".f[#p.child.EMC_GAS].p.read.PI_VESSEL_PV , 
         _vacuum_hold_test           := #p.write.VACUUM_HOLD_TEST , 
         _emm_vessel_state           := "idbEMM1".f[#p.child.EMM_VESSEL].p.read.mc.STATE , 
         _emc_water_state            := "idbEMC2".f[#p.child.EMC_WATER].p.read.mc.STATE , 
         _emx_mmfl_state             := "idbEMX1".f[#p.child.EMX_MMFL].p.read.mc.STATE , 
         _emv_vessel_state           := "idbEMV1".f[#p.child.EMV_VESSEL].p.read.mc.STATE , 
         _emg_filter_state           := "idbEMG1".f[#p.child.EMG_FILTER].p.read.mc.STATE , 
         _emx_transfer_state         := "idbEMX2".f[#p.select.EMX_TRANSFER].p.read.mc.STATE , 
         _emc_gas_state              := "idbEMC1".f[#p.child.EMC_GAS].p.read.mc.STATE , 
         _emx_drain_subs             := #p.write.EMX_DRAIN_SUBS , 
         _emx_drain_cmd              := #p.write.EMX_DRAIN_CMD , 
         _emv_inlet_subs             := #p.write.EMV_INLET_SUBS , 
         _emv_inlet_cmd              := #p.write.EMV_INLET_CMD , 
         _emt_hex_cmd                := #p.write.EMT_HEX_CMD , 
         _emt_hex_subs               := #p.write.EMT_HEX_SUBS , 
         _emt_hex_drain_time         := #p.write.EMT_HEX_DRAIN_TIME , 
         _emc_gas_medium_gas         := #p.write.EMC_GAS_MEDIUM_GAS , 
         _emm_vessel_cmd             := #p.write.EMM_VESSEL_CMD , 
         _emm_vessel_subs            := #p.write.EMM_VESSEL_SUBS , 
         _emc_water_cmd              := #p.write.EMC_WATER_CMD , 
         _emc_water_subs             := #p.write.EMC_WATER_SUBS , 
         _emc_water_medium_liquid    := #p.write.EMC_WATER_MEDIUM_LIQUID , 
         _emx_mmfl_cmd               := #p.write.EMX_MMFL_CMD , 
         _emv_vessel_subs            := #p.write.EMV_VESSEL_SUBS , 
         _emx_mmfl_subs              := #p.write.EMX_MMFL_SUBS , 
         _emv_vessel_cmd             := #p.write.EMV_VESSEL_CMD , 
         _emx_transfer_cmd           := #p.select.EMX_TRANSFER_CMD , 
         _emg_filter_cmd             := #p.write.EMG_FILTER_CMD , 
         _emx_transfer_subs          := #p.select.EMX_TRANSFER_SUBS , 
         _emg_filter_subs            := #p.write.EMG_FILTER_SUBS , 
         _emc_gas_cmd                := #p.write.EMC_GAS_CMD , 
         _emc_gas_subs               := #p.write.EMC_GAS_SUBS , 
         dummy                       := #dummy
      );
_notSFC_3_SETUP:      NOP 0;
NETWORK
TITLE = CALL SFC UO_MX_SIP if SIP running
//------------------------------------------------------------------------//
// SFC CALL   SFC CALL   SFC CALL   SFC CALL   SFC CALL   SFC CALL   SFC  //
//                                                                        //
// Call the SFC function if this is the running substate. This has to be  //
// called even if the block is not running so the SFC can process all     //
// commmands:                                                             //
//------------------------------------------------------------------------//
      A #subsRunning.SIP;
      JCN _notSFC_1_SIP;
      CALL #UO_MX_SIP
      (  _emv_inlet_state            := "idbEMV2".f[#p.child.EMV_INLET].p.read.mc.STATE , 
         _vessel_mx                  := #p.write.VESSEL_MX , 
         _emc_gas_pi_vessel_pv       := "idbEMC1".f[#p.child.EMC_GAS].p.read.PI_VESSEL_PV , 
         _emx_drain_state            := "idbEMX4".f[#p.child.EMX_DRAIN].p.read.mc.STATE , 
         _ema_vessel_state           := "idbEMA1".f[#p.child.EMA_VESSEL].p.read.mc.STATE , 
         _emx_mmfl_state             := "idbEMX1".f[#p.child.EMX_MMFL].p.read.mc.STATE , 
         _emv_vessel_ti_vessel_pv    := "idbEMV1".f[#p.child.EMV_VESSEL].p.read.TI_VESSEL_PV , 
         _emg_filter_ti_drain_pv     := "idbEMG1".f[#p.child.EMG_FILTER].p.read.TI_DRAIN_PV , 
         _emg_filter_ti_vent_pv      := "idbEMG1".f[#p.child.EMG_FILTER].p.read.TI_VENT_PV , 
         _emx_drain_ti_drain_pv      := "idbEMX4".f[#p.child.EMX_DRAIN].p.read.TI_DRAIN_PV , 
         _emg_filter_state           := "idbEMG1".f[#p.child.EMG_FILTER].p.read.mc.STATE , 
         _emc_water_state            := "idbEMC2".f[#p.child.EMC_WATER].p.read.mc.STATE , 
         _emc_gas_state              := "idbEMC1".f[#p.child.EMC_GAS].p.read.mc.STATE , 
         _emv_vessel_state           := "idbEMV1".f[#p.child.EMV_VESSEL].p.read.mc.STATE , 
         _emv_inlet_cmd              := #p.write.EMV_INLET_CMD , 
         _emv_inlet_subs             := #p.write.EMV_INLET_SUBS , 
         _emx_drain_cmd              := #p.write.EMX_DRAIN_CMD , 
         _emx_drain_subs             := #p.write.EMX_DRAIN_SUBS , 
         _ema_vessel_cmd             := #p.write.EMA_VESSEL_CMD , 
         _ema_vessel_subs            := #p.write.EMA_VESSEL_SUBS , 
         _emx_mmfl_cmd               := #p.write.EMX_MMFL_CMD , 
         _emx_mmfl_subs              := #p.write.EMX_MMFL_SUBS , 
         _emc_water_cmd              := #p.write.EMC_WATER_CMD , 
         _emc_water_subs             := #p.write.EMC_WATER_SUBS , 
         _emc_water_medium_liquid    := #p.write.EMC_WATER_MEDIUM_LIQUID , 
         _emc_gas_setpoint           := #p.write.EMC_GAS_SETPOINT , 
         _emg_filter_subs            := #p.write.EMG_FILTER_SUBS , 
         _emg_filter_cmd             := #p.write.EMG_FILTER_CMD , 
         _emc_gas_medium_gas         := #p.write.EMC_GAS_MEDIUM_GAS , 
         _emc_gas_subs               := #p.write.EMC_GAS_SUBS , 
         _emv_vessel_subs            := #p.write.EMV_VESSEL_SUBS , 
         _emv_vessel_cmd             := #p.write.EMV_VESSEL_CMD , 
         _emc_gas_cmd                := #p.write.EMC_GAS_CMD , 
         dummy                       := #dummy
      );
_notSFC_1_SIP:      NOP 0;

NETWORK
TITLE = Check if any Child state does not match the command
//------------------------------------------------------------------------//
// CHILD FLOWPATH STATE MISMATCH   CHILD FLOWPATH STATE MISMATCH   CHILD  //
//                                                                        //
// Check if any child flowpath device state does not match the command    //
// from this parent block if the child state grace period timer has       //
// expired. Stop checking if the first child state mismatch found:        //
//------------------------------------------------------------------------//
      A(;
      O(;
      A "alwaysHigh";
      A "idbEMA1".f[#p.child.EMA_VESSEL].p.write.mc.ARMED;
      A "idbEMA1".f[#p.child.EMA_VESSEL].p.read.mc.FLOWPATH;
      A(;
      L "idbEMA1".f[#p.child.EMA_VESSEL].p.read.mc.STATE;
      L #childReqCMD.EMA_VESSEL;
      <>I;
      );
      A(;
      L "idbEMA1".f[#p.child.EMA_VESSEL].p.read.mc.STATE;
      L "dbCONST".BLK.STATE.COMPLETED;
      <>I;
      );
      AN(;
      A(;
      L "dbCONST".BLK.CMD.START;
      L #childReqCMD.EMA_VESSEL;
      ==I;
      );
      A(;
      L "idbEMA1".f[#p.child.EMA_VESSEL].p.read.mc.STATE;
      L "idbEMA1".f[#p.child.EMA_VESSEL].p.write.mc.SUBS;
      ==I;
      );
      );
      );
      O(;
      A "alwaysHigh";
      A "idbEMC1".f[#p.child.EMC_GAS].p.write.mc.ARMED;
      A "idbEMC1".f[#p.child.EMC_GAS].p.read.mc.FLOWPATH;
      A(;
      L "idbEMC1".f[#p.child.EMC_GAS].p.read.mc.STATE;
      L #childReqCMD.EMC_GAS;
      <>I;
      );
      A(;
      L "idbEMC1".f[#p.child.EMC_GAS].p.read.mc.STATE;
      L "dbCONST".BLK.STATE.COMPLETED;
      <>I;
      );
      AN(;
      A(;
      L "dbCONST".BLK.CMD.START;
      L #childReqCMD.EMC_GAS;
      ==I;
      );
      A(;
      L "idbEMC1".f[#p.child.EMC_GAS].p.read.mc.STATE;
      L "idbEMC1".f[#p.child.EMC_GAS].p.write.mc.SUBS;
      ==I;
      );
      );
      );
      O(;
      A "alwaysHigh";
      A "idbEMC2".f[#p.child.EMC_WATER].p.write.mc.ARMED;
      A "idbEMC2".f[#p.child.EMC_WATER].p.read.mc.FLOWPATH;
      A(;
      L "idbEMC2".f[#p.child.EMC_WATER].p.read.mc.STATE;
      L #childReqCMD.EMC_WATER;
      <>I;
      );
      A(;
      L "idbEMC2".f[#p.child.EMC_WATER].p.read.mc.STATE;
      L "dbCONST".BLK.STATE.COMPLETED;
      <>I;
      );
      AN(;
      A(;
      L "dbCONST".BLK.CMD.START;
      L #childReqCMD.EMC_WATER;
      ==I;
      );
      A(;
      L "idbEMC2".f[#p.child.EMC_WATER].p.read.mc.STATE;
      L "idbEMC2".f[#p.child.EMC_WATER].p.write.mc.SUBS;
      ==I;
      );
      );
      );
      O(;
      A "alwaysHigh";
      A "idbEMG1".f[#p.child.EMG_FILTER].p.write.mc.ARMED;
      A "idbEMG1".f[#p.child.EMG_FILTER].p.read.mc.FLOWPATH;
      A(;
      L "idbEMG1".f[#p.child.EMG_FILTER].p.read.mc.STATE;
      L #childReqCMD.EMG_FILTER;
      <>I;
      );
      A(;
      L "idbEMG1".f[#p.child.EMG_FILTER].p.read.mc.STATE;
      L "dbCONST".BLK.STATE.COMPLETED;
      <>I;
      );
      AN(;
      A(;
      L "dbCONST".BLK.CMD.START;
      L #childReqCMD.EMG_FILTER;
      ==I;
      );
      A(;
      L "idbEMG1".f[#p.child.EMG_FILTER].p.read.mc.STATE;
      L "idbEMG1".f[#p.child.EMG_FILTER].p.write.mc.SUBS;
      ==I;
      );
      );
      );
      O(;
      A "alwaysHigh";
      A "idbEMM1".f[#p.child.EMM_VESSEL].p.write.mc.ARMED;
      A "idbEMM1".f[#p.child.EMM_VESSEL].p.read.mc.FLOWPATH;
      A(;
      L "idbEMM1".f[#p.child.EMM_VESSEL].p.read.mc.STATE;
      L #childReqCMD.EMM_VESSEL;
      <>I;
      );
      A(;
      L "idbEMM1".f[#p.child.EMM_VESSEL].p.read.mc.STATE;
      L "dbCONST".BLK.STATE.COMPLETED;
      <>I;
      );
      AN(;
      A(;
      L "dbCONST".BLK.CMD.START;
      L #childReqCMD.EMM_VESSEL;
      ==I;
      );
      A(;
      L "idbEMM1".f[#p.child.EMM_VESSEL].p.read.mc.STATE;
      L "idbEMM1".f[#p.child.EMM_VESSEL].p.write.mc.SUBS;
      ==I;
      );
      );
      );
      O(;
      A "alwaysHigh";
      A "idbEMT1".f[#p.child.EMT_HEX].p.write.mc.ARMED;
      A "idbEMT1".f[#p.child.EMT_HEX].p.read.mc.FLOWPATH;
      A(;
      L "idbEMT1".f[#p.child.EMT_HEX].p.read.mc.STATE;
      L #childReqCMD.EMT_HEX;
      <>I;
      );
      A(;
      L "idbEMT1".f[#p.child.EMT_HEX].p.read.mc.STATE;
      L "dbCONST".BLK.STATE.COMPLETED;
      <>I;
      );
      AN(;
      A(;
      L "dbCONST".BLK.CMD.START;
      L #childReqCMD.EMT_HEX;
      ==I;
      );
      A(;
      L "idbEMT1".f[#p.child.EMT_HEX].p.read.mc.STATE;
      L "idbEMT1".f[#p.child.EMT_HEX].p.write.mc.SUBS;
      ==I;
      );
      );
      );
      O(;
      A "alwaysHigh";
      A "idbEMV2".f[#p.child.EMV_INLET].p.write.mc.ARMED;
      A "idbEMV2".f[#p.child.EMV_INLET].p.read.mc.FLOWPATH;
      A(;
      L "idbEMV2".f[#p.child.EMV_INLET].p.read.mc.STATE;
      L #childReqCMD.EMV_INLET;
      <>I;
      );
      A(;
      L "idbEMV2".f[#p.child.EMV_INLET].p.read.mc.STATE;
      L "dbCONST".BLK.STATE.COMPLETED;
      <>I;
      );
      AN(;
      A(;
      L "dbCONST".BLK.CMD.START;
      L #childReqCMD.EMV_INLET;
      ==I;
      );
      A(;
      L "idbEMV2".f[#p.child.EMV_INLET].p.read.mc.STATE;
      L "idbEMV2".f[#p.child.EMV_INLET].p.write.mc.SUBS;
      ==I;
      );
      );
      );
      O(;
      A "alwaysHigh";
      A "idbEMV1".f[#p.child.EMV_VESSEL].p.write.mc.ARMED;
      A "idbEMV1".f[#p.child.EMV_VESSEL].p.read.mc.FLOWPATH;
      A(;
      L "idbEMV1".f[#p.child.EMV_VESSEL].p.read.mc.STATE;
      L #childReqCMD.EMV_VESSEL;
      <>I;
      );
      A(;
      L "idbEMV1".f[#p.child.EMV_VESSEL].p.read.mc.STATE;
      L "dbCONST".BLK.STATE.COMPLETED;
      <>I;
      );
      AN(;
      A(;
      L "dbCONST".BLK.CMD.START;
      L #childReqCMD.EMV_VESSEL;
      ==I;
      );
      A(;
      L "idbEMV1".f[#p.child.EMV_VESSEL].p.read.mc.STATE;
      L "idbEMV1".f[#p.child.EMV_VESSEL].p.write.mc.SUBS;
      ==I;
      );
      );
      );
      O(;
      A "alwaysHigh";
      A "idbEMX4".f[#p.child.EMX_DRAIN].p.write.mc.ARMED;
      A "idbEMX4".f[#p.child.EMX_DRAIN].p.read.mc.FLOWPATH;
      A(;
      L "idbEMX4".f[#p.child.EMX_DRAIN].p.read.mc.STATE;
      L #childReqCMD.EMX_DRAIN;
      <>I;
      );
      A(;
      L "idbEMX4".f[#p.child.EMX_DRAIN].p.read.mc.STATE;
      L "dbCONST".BLK.STATE.COMPLETED;
      <>I;
      );
      AN(;
      A(;
      L "dbCONST".BLK.CMD.START;
      L #childReqCMD.EMX_DRAIN;
      ==I;
      );
      A(;
      L "idbEMX4".f[#p.child.EMX_DRAIN].p.read.mc.STATE;
      L "idbEMX4".f[#p.child.EMX_DRAIN].p.write.mc.SUBS;
      ==I;
      );
      );
      );
      O(;
      A #selected_FILL_FLZ.FL1;
      A "idbEMX5".f[#p.child.EMX_FILL1].p.write.mc.ARMED;
      A "idbEMX5".f[#p.child.EMX_FILL1].p.read.mc.FLOWPATH;
      A(;
      L "idbEMX5".f[#p.child.EMX_FILL1].p.read.mc.STATE;
      L #childReqCMD.EMX_FILL1;
      <>I;
      );
      A(;
      L "idbEMX5".f[#p.child.EMX_FILL1].p.read.mc.STATE;
      L "dbCONST".BLK.STATE.COMPLETED;
      <>I;
      );
      AN(;
      A(;
      L "dbCONST".BLK.CMD.START;
      L #childReqCMD.EMX_FILL1;
      ==I;
      );
      A(;
      L "idbEMX5".f[#p.child.EMX_FILL1].p.read.mc.STATE;
      L "idbEMX5".f[#p.child.EMX_FILL1].p.write.mc.SUBS;
      ==I;
      );
      );
      );
      O(;
      A #selected_FILL_FLZ.FL2;
      A "idbEMX5".f[#p.child.EMX_FILL2].p.write.mc.ARMED;
      A "idbEMX5".f[#p.child.EMX_FILL2].p.read.mc.FLOWPATH;
      A(;
      L "idbEMX5".f[#p.child.EMX_FILL2].p.read.mc.STATE;
      L #childReqCMD.EMX_FILL2;
      <>I;
      );
      A(;
      L "idbEMX5".f[#p.child.EMX_FILL2].p.read.mc.STATE;
      L "dbCONST".BLK.STATE.COMPLETED;
      <>I;
      );
      AN(;
      A(;
      L "dbCONST".BLK.CMD.START;
      L #childReqCMD.EMX_FILL2;
      ==I;
      );
      A(;
      L "idbEMX5".f[#p.child.EMX_FILL2].p.read.mc.STATE;
      L "idbEMX5".f[#p.child.EMX_FILL2].p.write.mc.SUBS;
      ==I;
      );
      );
      );
      O(;
      A "alwaysHigh";
      A "idbEMX1".f[#p.child.EMX_MMFL].p.write.mc.ARMED;
      A "idbEMX1".f[#p.child.EMX_MMFL].p.read.mc.FLOWPATH;
      A(;
      L "idbEMX1".f[#p.child.EMX_MMFL].p.read.mc.STATE;
      L #childReqCMD.EMX_MMFL;
      <>I;
      );
      A(;
      L "idbEMX1".f[#p.child.EMX_MMFL].p.read.mc.STATE;
      L "dbCONST".BLK.STATE.COMPLETED;
      <>I;
      );
      AN(;
      A(;
      L "dbCONST".BLK.CMD.START;
      L #childReqCMD.EMX_MMFL;
      ==I;
      );
      A(;
      L "idbEMX1".f[#p.child.EMX_MMFL].p.read.mc.STATE;
      L "idbEMX1".f[#p.child.EMX_MMFL].p.write.mc.SUBS;
      ==I;
      );
      );
      );
      O(;
      O #selected_FILL_FLZ.FL1;
      O #selected_FILL_FLZ.FL2;
      O #selected_VESSEL_SY.S1;
      O #selected_VESSEL_SY.S2;
      A "idbEMX6".f[#p.child.EMX_SMFL].p.write.mc.ARMED;
      A "idbEMX6".f[#p.child.EMX_SMFL].p.read.mc.FLOWPATH;
      A(;
      L "idbEMX6".f[#p.child.EMX_SMFL].p.read.mc.STATE;
      L #childReqCMD.EMX_SMFL;
      <>I;
      );
      A(;
      L "idbEMX6".f[#p.child.EMX_SMFL].p.read.mc.STATE;
      L "dbCONST".BLK.STATE.COMPLETED;
      <>I;
      );
      AN(;
      A(;
      L "dbCONST".BLK.CMD.START;
      L #childReqCMD.EMX_SMFL;
      ==I;
      );
      A(;
      L "idbEMX6".f[#p.child.EMX_SMFL].p.read.mc.STATE;
      L "idbEMX6".f[#p.child.EMX_SMFL].p.write.mc.SUBS;
      ==I;
      );
      );
      );
      O(;
      O #selected_FILL_FLZ.FL1;
      O #selected_FILL_FLZ.FL2;
      O #selected_VESSEL_SY.S1;
      O #selected_VESSEL_SY.S2;
      A "idbEMX4".f[#p.child.EMX_SMFLDRN].p.write.mc.ARMED;
      A "idbEMX4".f[#p.child.EMX_SMFLDRN].p.read.mc.FLOWPATH;
      A(;
      L "idbEMX4".f[#p.child.EMX_SMFLDRN].p.read.mc.STATE;
      L #childReqCMD.EMX_SMFLDRN;
      <>I;
      );
      A(;
      L "idbEMX4".f[#p.child.EMX_SMFLDRN].p.read.mc.STATE;
      L "dbCONST".BLK.STATE.COMPLETED;
      <>I;
      );
      AN(;
      A(;
      L "dbCONST".BLK.CMD.START;
      L #childReqCMD.EMX_SMFLDRN;
      ==I;
      );
      A(;
      L "idbEMX4".f[#p.child.EMX_SMFLDRN].p.read.mc.STATE;
      L "idbEMX4".f[#p.child.EMX_SMFLDRN].p.write.mc.SUBS;
      ==I;
      );
      );
      );
      O(;
      A #selected_VESSEL_SY.S1;
      A "idbEMX2".f[#p.child.EMX_TRANSFER1].p.write.mc.ARMED;
      A "idbEMX2".f[#p.child.EMX_TRANSFER1].p.read.mc.FLOWPATH;
      A(;
      L "idbEMX2".f[#p.child.EMX_TRANSFER1].p.read.mc.STATE;
      L #childReqCMD.EMX_TRANSFER1;
      <>I;
      );
      A(;
      L "idbEMX2".f[#p.child.EMX_TRANSFER1].p.read.mc.STATE;
      L "dbCONST".BLK.STATE.COMPLETED;
      <>I;
      );
      AN(;
      A(;
      L "dbCONST".BLK.CMD.START;
      L #childReqCMD.EMX_TRANSFER1;
      ==I;
      );
      A(;
      L "idbEMX2".f[#p.child.EMX_TRANSFER1].p.read.mc.STATE;
      L "idbEMX2".f[#p.child.EMX_TRANSFER1].p.write.mc.SUBS;
      ==I;
      );
      );
      );
      O(;
      A #selected_VESSEL_SY.S2;
      A "idbEMX2".f[#p.child.EMX_TRANSFER2].p.write.mc.ARMED;
      A "idbEMX2".f[#p.child.EMX_TRANSFER2].p.read.mc.FLOWPATH;
      A(;
      L "idbEMX2".f[#p.child.EMX_TRANSFER2].p.read.mc.STATE;
      L #childReqCMD.EMX_TRANSFER2;
      <>I;
      );
      A(;
      L "idbEMX2".f[#p.child.EMX_TRANSFER2].p.read.mc.STATE;
      L "dbCONST".BLK.STATE.COMPLETED;
      <>I;
      );
      AN(;
      A(;
      L "dbCONST".BLK.CMD.START;
      L #childReqCMD.EMX_TRANSFER2;
      ==I;
      );
      A(;
      L "idbEMX2".f[#p.child.EMX_TRANSFER2].p.read.mc.STATE;
      L "idbEMX2".f[#p.child.EMX_TRANSFER2].p.write.mc.SUBS;
      ==I;
      );
      );
      );
      );
      JCN _noMismatch;

      S #flags.childMismatch;
      JC _noResetMismatch;

_noMismatch:      NOP 0;
      R #flags.childMismatch;
      R #p.read.mc.INTIL;

_noResetMismatch:      NOP 0;

NETWORK
TITLE = If child command changed, start timer to wait for child state
//------------------------------------------------------------------------//
// CHILD STATE TIMER   CHILD STATE TIMER   CHILD STATE TIMER   CHILD STAT //
//                                                                        //
// If any child command changed then start a timer to provide a grace     //
// period to allow the child device state to match the command (e.g. to   //
// allow a valve to move from closed to opened position).                 //
// Start the child state check timer if a command changed:                //
//------------------------------------------------------------------------//
      CALL #timeCheckChildState
      {time_type := 'Time'}
      (  IN                          := #flags.childMismatch , 
         PT                          := #p.read.bmc.transTime , 
         Q                           := #timeCheckChildStateExpired , 
         ET                          := #timeCheckChildStateElapsed
      );
      NOP 0;

NETWORK
TITLE = Block errors
//------------------------------------------------------------------------//
// Set the block start perimt error status if active:                     //
//------------------------------------------------------------------------//
      AN #p.read.bmc.permitStart;
      = #p.read.err.permitStart;

  //------------------------------------------------------------------------//
  // Set the child error status if active:                                  //
  //------------------------------------------------------------------------//
      A #flags.childInterlock;
      = #p.read.err.childInterlock;

  //------------------------------------------------------------------------//
  // Set the child unavailable error status if active:                      //
  //------------------------------------------------------------------------//
      A #flags.childUnavailable;
      = #p.read.err.childUnavailable;

  //------------------------------------------------------------------------//
  // Set the child state mismatch error status if active:                   //
  //------------------------------------------------------------------------//
      A #timeCheckChildStateExpired;
      = #p.read.err.childMismatch;
      JCN _noInternalIL;
      S #p.read.mc.INTIL;
_noInternalIL:      NOP 0;

  //------------------------------------------------------------------------//
  // Set the block error flag if anything gone wrong:                       //
  //------------------------------------------------------------------------//
      O #p.read.err.childInterlock;
      O #p.read.err.childMismatch;
      O #p.read.err.childSafeState;
      O #p.read.err.childUnavailable;
      O #p.read.err.permitStart;
      = #p.read.mc.ERROR;

NETWORK
TITLE = Pack the general block alarm bits
//------------------------------------------------------------------------//
// Pack the alarm bits into an integer for the HMI to read:               //
// Alarms are arranged in the following Little Endian order...            //
// Word   1                                0                              //
// Bit    0   1   2   3   4   5   6   7    8   9  10  11  12  13  14  15  //
// Order  9  10  11  12  13  14  15  16    1   2   3   4   5   6   7   8  //
//------------------------------------------------------------------------//
//    A #p.read.err.childInterlock;
//    = #b[8];
      A #p.read.err.childMismatch;
      = #b[9];
//    A #p.read.err.childSafeState;
//    = #b[10];
      A #p.read.err.childUnavailable;
      = #b[11];
      A #p.read.err.permitStart;
      = #b[12];
      L #w;
      T #p.read.mc.ALARM;

NETWORK
TITLE = Pack the prompt event confirm No message event alarm bits
//------------------------------------------------------------------------//
// Pack the eventPrompt confirm No alarm bits into an integer for the     //
// HMI to read:                                                           //
//------------------------------------------------------------------------//
      L #wEventConfirmNo[0];
      T #p.read.eventConfirmNo_0;

NETWORK
TITLE = Pack the prompt event confirm Yes message event alarm bits
//------------------------------------------------------------------------//
// Pack the eventPrompt confirm Yes alarm bits into an integer for the    //
// HMI to read:                                                           //
//------------------------------------------------------------------------//
      L #wEventConfirmYes[0];
      T #p.read.eventConfirmYes_0;

NETWORK
TITLE = Pack the log message event alarm bits
//------------------------------------------------------------------------//
// Pack the eventLogMsg alarm bits into an integer for the HMI to read:   //
//------------------------------------------------------------------------//
      L #wEventLogMsg[0];
      T #p.read.eventLogMsg_0;
      L #wEventLogMsg[1];
      T #p.read.eventLogMsg_1;
      L #wEventLogMsg[2];
      T #p.read.eventLogMsg_2;
      L #wEventLogMsg[3];
      T #p.read.eventLogMsg_3;

NETWORK
TITLE = Pack the log real data event alarm bits
//------------------------------------------------------------------------//
// Pack the eventLogReal alarm bits into an integer for the HMI to read:  //
//------------------------------------------------------------------------//
      L #wEventLogReal[0];
      T #p.read.eventLogReal_0;

NETWORK
TITLE = Pack the log time data event alarm bits
//------------------------------------------------------------------------//
// Pack the eventLogTime alarm bits into an integer for the HMI to read:  //
//------------------------------------------------------------------------//
      L #wEventLogTime[0];
      T #p.read.eventLogTime_0;

END_FUNCTION_BLOCK

