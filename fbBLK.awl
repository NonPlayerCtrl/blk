@@TEMPLATE_BEGIN|createClass@@
//----------------------------------------------------------------------------//
//            Copyright 2018 Rieckermann Engineering Operations               //
//                Automatically Generated File - Do Not Edit                  //
//----------------------------------------------------------------------------//
// Title:       @@CLASS@@
// Description: @@CLASSDESCRIPTION@@
//                                                                            //
// This is the main function block for all higher level S88 blocks, including //
// EMs, Units and Process Cells. The block is generic and any heirarchical    //
// structure can be supported.                                                //
//----------------------------------------------------------------------------//
// Revision history:                                                          //
// Rev By               Date        CC        Note                            //
// 2.0 David Paspa      30-Jan-2018 NA        Reboot for S7-1500.             //
// 1.0 Gerald Kontriner 10-Oct-2009 CC-09/023 Added Alarm flag MON_MISMATCH.  //
// 0.9 Khairul Basar    04-Oct-2009 CC-09/023 SHARED_BY  changed to OWNER int.//
// 0.8 Khairul Basar    02-Oct-2009 CC-09/023 SQ_STATE, ERR flag reset if SQ  //
//                                            off.                            //
// 0.7 Khoon            01-Oct-2009 CC-09/016 Mode=2 init,'Substate change'   //
//                                            added to STOP input of Subs.    //
// 0.6 Khairul Basar    30-Sep-2009 CC-09/023 EM Mode var changed to IN_OUT.  //
// 0.5 Khairul Basar    25-Sep-2009 CC-09/016 Ref2.                           //
// 0.4 Khairul Basar    21-Sep-2009 CC-09/016 Ref1.                           //
// 0.3 Khairul Basar    17-Sep-2009 CC-09/016 Duplicate command/SP parameters //
//                                            deleted auto/manual both now    //
//                                            using same parameters.          //
// 0.2 Khairul Basar    27-Aug-2009 CC-09/023 Path_IL added, Phase updated.   //
// 0.1 Khairul Basar    03-Aug-2009           Initial design.                 //
// Ref2:                                                                      //
// SQ_ACK,SQ_RESUME,SQ_ERROR,CURSTEP,SQ_STATE variables are added as to       //
// control from HMI faceplate.                                                //
// Ref1:                                                                      //
// Phases are updated.Flush & Charge Syncronised for valve commands.SQ_stop   //
// command is passed when CALL flag is OFF(previously there was error).PULSE  //
// timer is created as multiple instance of a standard FB, no more hard coded //
// S5 timer. ERR_FLT is changed to TIMEOUT_VER, PATH_IL to FLOWPATH.Shared    //
// Equipment availability flag programmed,BatchCycle variable added.          //
//----------------------------------------------------------------------------//
FUNCTION_BLOCK "fb@@CLASS@@"
TITLE = @@CLASSDESCRIPTION@@
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : REO
NAME : fb@@CLASS@@
VERSION : 2.0

//----------------------------------------------------------------------------//
// Declare interface and variables:                                           //
//----------------------------------------------------------------------------//
VAR
    p : "udt@@CLASS@@";            // Block data interface
    RUNTMR : "fbRunTimer";
@@ATTR_BEGIN|SFC@@
    @@SFC@@ : "fb@@SFC@@";       // @@STATEDESCRIPTION@@
@@ATTR_END|SFC@@
    timeCheckChildState {ReadalPartName := 'IEC_TIMER'; LibVersion := '1.0'} : TON;
    timeCheckChildStateExpired : Bool;
    timeCheckChildStateElapsed : Time;
    flags : Struct
        childError : Bool;
        childFailed : Bool;
        childMismatch : Bool;
        childUnavailable : Bool;
        sfcCompleted : Bool;
    END_STRUCT;
    acquire : Struct
@@ATTR_BEGIN|CHILD@@
        @@CHILDPARAMETERALIAS@@ : Bool;       // @@CHILDPARAMETERALIAS@@
@@ATTR_END|CHILD@@
    END_STRUCT;
    alreadyOwned : Struct
@@ATTR_BEGIN|CHILD@@
        @@CHILDPARAMETERALIAS@@ : Bool;       // @@CHILDPARAMETERALIAS@@
@@ATTR_END|CHILD@@
    END_STRUCT;
@@ATTR_BEGIN|SELECT@@
    selected_@@PARAMETER@@_@@SELECTION@@ : Struct
@@ATTR_BEGIN|SELVALUE@@
        @@SELECTIONVALUE@@ : Bool;
@@ATTR_END|SELVALUE@@
    END_STRUCT;
@@ATTR_END|SELECT@@
    subsHasSFC : Struct
@@ATTR_BEGIN|STATE@@
        @@STATE@@ : Bool := @@HASSFC@@;       // @@STATEDESCRIPTION@@
@@ATTR_END|STATE@@
    END_STRUCT;
    subsRunning : Struct
@@ATTR_BEGIN|STATE@@
        @@STATE@@ : Bool;       // @@STATEDESCRIPTION@@
@@ATTR_END|STATE@@
    END_STRUCT;
    subsStart : Struct
@@ATTR_BEGIN|STATE@@
        @@STATE@@ : Bool;       // @@STATEDESCRIPTION@@
@@ATTR_END|STATE@@
    END_STRUCT;
END_VAR

VAR DB_SPECIFIC
    w { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;
    b { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} AT w : Array[0..15] of Bool;

@@ATTR_BEGIN|pEventConfirmNoExists@@
@@ATTR_BEGIN|pEventConfirmNoNumWords@@
    wEventConfirmNo { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..@@CWORDMAX@@] of Word;
@@ATTR_END|pEventConfirmNoNumWords@@
@@ATTR_BEGIN|pEventConfirmNoNum@@
    bEventConfirmNo { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} AT wEventConfirmNo : Array[0..@@IDXEVENTMAX@@] of Bool;
@@ATTR_END|pEventConfirmNoNum@@
@@ATTR_END|pEventConfirmNoExists@@

@@ATTR_BEGIN|pEventConfirmYesExists@@
@@ATTR_BEGIN|pEventConfirmYesNumWords@@
    wEventConfirmYes { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..@@CWORDMAX@@] of Word;
@@ATTR_END|pEventConfirmYesNumWords@@
@@ATTR_BEGIN|pEventConfirmYesNum@@
    bEventConfirmYes { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} AT wEventConfirmYes : Array[0..@@IDXEVENTMAX@@] of Bool;
@@ATTR_END|pEventConfirmYesNum@@
@@ATTR_END|pEventConfirmYesExists@@

@@ATTR_BEGIN|pEventLogMsgExists@@
@@ATTR_BEGIN|pEventLogMsgNumWords@@
    wEventLogMsg { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..@@CWORDMAX@@] of Word;
@@ATTR_END|pEventLogMsgNumWords@@
@@ATTR_BEGIN|pEventLogMsgNum@@
    bEventLogMsg { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} AT wEventLogMsg : Array[0..@@IDXEVENTMAX@@] of Bool;
@@ATTR_END|pEventLogMsgNum@@
@@ATTR_END|pEventLogMsgExists@@

@@ATTR_BEGIN|pEventLogRealExists@@
@@ATTR_BEGIN|pEventLogRealNumWords@@
    wEventLogReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..@@CWORDMAX@@] of Word;
@@ATTR_END|pEventLogRealNumWords@@
@@ATTR_BEGIN|pEventLogRealNum@@
    bEventLogReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} AT wEventLogReal : Array[0..@@IDXEVENTMAX@@] of Bool;
@@ATTR_END|pEventLogRealNum@@
@@ATTR_END|pEventLogRealExists@@

@@ATTR_BEGIN|pEventLogTimeExists@@
@@ATTR_BEGIN|pEventLogTimeNumWords@@
    wEventLogTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..@@CWORDMAX@@] of Word;
@@ATTR_END|pEventLogTimeNumWords@@
@@ATTR_BEGIN|pEventLogTimeNum@@
    bEventLogTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} AT wEventLogTime : Array[0..@@IDXEVENTMAX@@] of Bool;
@@ATTR_END|pEventLogTimeNum@@
@@ATTR_END|pEventLogTimeExists@@
END_VAR

VAR_TEMP
    sq_finished : Bool;
@@ATTR_BEGIN|TIMER@@
    tTime : Time;
    dTime : DInt;
@@ATTR_END|TIMER@@
    returnValue : Int;
    dummy : Bool;
END_VAR

BEGIN
NETWORK
TITLE = Safe Command as STOPPED on restart
    //------------------------------------------------------------------------//
    // Set the safe command if restarting the PLC:                            //
    //------------------------------------------------------------------------//
    A "flagFirstScanRestart";
    JCN _noRestart;
    L "dbCONST".BLK.SAFE.CMD;
    T #p.write.mc.CMD;
    T #p.read.mc.CMD_SAFE;
_noRestart:   NOP 0;

NETWORK
TITLE = Check if any child is in error
    //------------------------------------------------------------------------//
    // CHILD ERROR   CHILD ERROR   CHILD ERROR   CHILD ERROR   CHILD ERROR    //
    //                                                                        //
    // Check the child devices to see if any is in error:                     //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|CHILD_COMMAND@@
    O(;
    @@CHILDCOMMANDSTATEMENT@@
    A "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.read.mc.ERROR;
    );
@@ATTR_END|CHILD_COMMAND@@
    = #flags.childError;

@@ATTR_BEGIN|CHILD_ACQUIRE_EXISTS@@
NETWORK
TITLE = Check if any shared Child is not Owned or not Available
    //------------------------------------------------------------------------//
    // CHILD UNAVAILABLE   CHILD UNAVAILABLE   CHILD UNAVAILABLE   CHILD UNAV //
    //                                                                        //
    // Check any shared child devices are Available. If Available they will   //
    // be acquired if needed later to execute a command:                      //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|CHILD_ACQUIRE@@
    O(;
    @@CHILDACQUIRESTATEMENT@@
    AN "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.read.mc.isAvailable;
    AN(;
    L "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.write.mc.OWNER;
    L #p.read.mc.ME;
    ==I;
    );
    );
@@ATTR_END|CHILD_ACQUIRE@@
    = #flags.childUnavailable;
@@ATTR_END|CHILD_ACQUIRE_EXISTS@@

NETWORK
TITLE = Check if any Child has Failed
    //------------------------------------------------------------------------//
    // CHILD FAILED   CHILD FAILED   CHILD FAILED   CHILD FAILED   CHILD FAIL //
    //                                                                        //
    // Check if any child cannot be controlled by this parent block in which  //
    // case this block will fail and so operation at this level should be     //
    // inhibited:                                                             //
    //------------------------------------------------------------------------//
    O #flags.childError;
    O #flags.childUnavailable;
    O(;
    A #flags.childMismatch;
    A #timeCheckChildStateExpired;
    );
    = #flags.childFailed;

NETWORK
TITLE = Call General Mode and Command handling block
    //------------------------------------------------------------------------//
    // COMMAND PROCESSOR   COMMAND PROCESSOR   COMMAND PROCESSOR   COMMAND    //
    //                                                                        //
    // Process the standard block functions for command, mode, interlock and  //
    // state:                                                                 //
    //------------------------------------------------------------------------//
    CALL "fcModeCmd"
    (   mcRead             := #p.read.mc ,
        mcWrite              := #p.write.mc
    );

NETWORK
TITLE = Set Start command permitted flag if all okay
    //------------------------------------------------------------------------//
    // PERMIT START   PERMIT START   PERMIT START   PERMIT START   PERMIT ST  //
    //                                                                        //
    // If no interlock and all calling parameters and child devices are okay  //
    // then a Start is permitted:                                             //
    //------------------------------------------------------------------------//
    AN #p.read.mc.INTERLOCK;
    AN #flags.childFailed;
    = #p.read.bmc.permitStart;

NETWORK
TITLE = Operator Attention Flag
    //------------------------------------------------------------------------//
    // If not in Auto or any interlock or inhibit condition then the block    //
    // needs operator attention:                                              //
    //------------------------------------------------------------------------//
    O #p.read.mc.modeMANUAL;
    O #p.read.mc.modeOOS;
    ON #p.read.bmc.permitStart;
    = #p.read.mc.needAttention;

NETWORK
TITLE = Call BLOCK Mode and Command handling block
    //------------------------------------------------------------------------//
    // Process the stackable block functions for mode and command change      //
    // events:                                                                //
    //------------------------------------------------------------------------//
    CALL "fcModeCmdBLK"
    (   mcRead             := #p.read.mc ,
        mcWrite              := #p.write.mc ,
        bmc                  := #p.read.bmc
    );

NETWORK
TITLE = Reset substate running flags on PLC restart
    //------------------------------------------------------------------------//
    // Reset all states running flags on PLC restart:                         //
    //------------------------------------------------------------------------//
    A "flagFirstScanRestart";
@@ATTR_BEGIN|STATE@@
    R #subsRunning.@@STATE@@;
@@ATTR_END|STATE@@

@@ATTR_BEGIN|CHILD_SELECT@@
NETWORK
TITLE = Set selected child @@CHILDPARAMETERALIAS@@ index value
    //------------------------------------------------------------------------//
    // CHILD SELECT   CHILD SELECT   CHILD SELECT   CHILD SELECT   CHILD SEL  //
    //                                                                        //
    // Set the index value for the selected child:                            //
    //------------------------------------------------------------------------//
    @@CHILDACQUIRESTATEMENT@@
    JCN _childSelect_@@COUNTERATTR|1@@;
    L #p.child.@@CHILDPARAMETERALIAS@@;
    T #p.select.@@CHILDLINKALIAS@@;
_childSelect_@@COUNTERATTR|1@@:   NOP 0;

@@ATTR_END|CHILD_SELECT@@

@@ATTR_BEGIN|CHILD_ACQUIRE@@
NETWORK
TITLE = Release child @@CHILDPARAMETERALIAS@@ if acquired and command completed
    //------------------------------------------------------------------------//
    // RELEASE CHILD   RELEASE CHILD   RELEASE CHILD   RELEASE CHILD   RELE   //
    //                                                                        //
    // Release the child device if acquired earlier to run the command:       //
    //------------------------------------------------------------------------//
    A #flags.sfcCompleted;
    A #acquire.@@CHILDPARAMETERALIAS@@;
    JCN _notOwn@@COUNTERATTR|1@@;
    L "dbCONST".BLK.ID.AVAILABLE;
    T "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.write.mc.OWNER;
    R #acquire.@@CHILDPARAMETERALIAS@@;
_notOwn@@COUNTERATTR@@:   NOP 0;

@@ATTR_END|CHILD_ACQUIRE@@

NETWORK
TITLE = Set child devices to safe state if any interlock or child failure
    //------------------------------------------------------------------------//
    // SAFE STATE   SAFE STATE   SAFE STATE   SAFE STATE  SAFE STATE  SAFE ST //
    //                                                                        //
    // Set the child device to the safe state on any interlock condition or   //
    // child failure:                                                         //
    //------------------------------------------------------------------------//
    O(;
    O #p.read.bmc.stateSTOPPED;
    ON #p.read.bmc.permitStart;
    );
@@ATTR_BEGIN|SFCExists@@
    O(;
    A #p.read.bmc.permitStart;
    A(;
@@ATTR_BEGIN|SFC@@
    O(;
    A #subsRunning.@@STATE@@;
    A(;
    O #@@SFC@@.smc.PAUSED;
    O #@@SFC@@.smc.ERR_FAULT;
    );
    );
@@ATTR_END|SFC@@
    );
    );
@@ATTR_END|SFCExists@@
    = #p.read.err.childSafeState;
    JCN _notChildSafe;

    //------------------------------------------------------------------------//
    // Set all child devices to safe state due to block stop or problem:      //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|CHILD_COMMAND@@
    @@CHILDCOMMANDSTATEMENT@@
    A "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.read.mc.modeAUTO;
    JCN _blkSafe_@@CHILDPARAMETERALIAS@@;
    L "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.read.mc.CMD_SAFE;
    T "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.write.mc.CMD;
_blkSafe_@@CHILDPARAMETERALIAS@@:   NOP 0;

@@ATTR_END|CHILD_COMMAND@@

_notChildSafe:   NOP 0;

NETWORK
TITLE = Flag SFC finished if none exist
    //------------------------------------------------------------------------//
    // Flag SFC completed if there aren't any:                                //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|STATE@@
    AN #subsHasSFC.@@STATE@@;
@@ATTR_END|STATE@@
    S #flags.sfcCompleted;

@@ATTR_BEGIN|SFCExists@@
NETWORK
TITLE = All SQ are in Auto mode when EM in Auto
    //------------------------------------------------------------------------//
    // SFC AUTO   SFC AUTO   SFC AUTO   SFC AUTO   SFC AUTO   SFC AUTO   SFC  //
    //                                                                        //
    // Set all SFCs to AUTO mode if the block is in AUTO:                     //
    //------------------------------------------------------------------------//
    A #p.read.bmc.eventModeAUTO;
    JCN _nomcAuto;
    L #p.write.mc.MODE;
@@ATTR_BEGIN|SFC@@
    T #@@SFC@@.smc.MODE;
@@ATTR_END|SFC@@
_nomcAuto:   NOP 0;

@@ATTR_END|SFCExists@@

NETWORK
TITLE = Cascade Auto or OOS Mode to children
    //------------------------------------------------------------------------//
    // MODE CASCADE   MODE CASCADE   MODE CASCADE   MODE CASCADE   MODE CASC  //
    //                                                                        //
    // Switch child mode to Auto or OOS when parent mode transitions:         //
    //------------------------------------------------------------------------//
    A(;
    O #p.read.bmc.eventModeAUTO;
    O #p.read.bmc.eventModeOOS;
    );
    JCN _nomcAutoOOS;

@@ATTR_BEGIN|CHILD_COMMAND@@
    @@CHILDCOMMANDSTATEMENT@@
    JCN _cascMode@@COUNTERATTR|1@@;
    L #p.write.mc.MODE;
    T "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.write.mc.MODE;
_cascMode@@COUNTERATTR|1@@:   NOP 0;

@@ATTR_END|CHILD_COMMAND@@
_nomcAutoOOS:   NOP 0;

@@ATTR_BEGIN|pChildReadExists@@
NETWORK
TITLE = Upload non-boolean child parameter values
    //------------------------------------------------------------------------//
    // CHILD PARAMETER   CHILD PARAMETER   CHILD PARAMETER   CHILD PARAMETER  //
    //                                                                        //
    // Get the initial input non-boolean value for the child parameter:       //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|CHILD_COMMAND@@
@@ATTR_BEGIN|pChildRead@@
    L "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.@@OPERATION@@.@@CHILDPARAMETERATTRIBUTE@@;
    T #p.@@OPERATION@@.@@CHILDPARAMETERALIAS@@_@@CHILDPARAMETERATTRIBUTE@@;
@@ATTR_END|pChildRead@@
@@ATTR_END|CHILD_COMMAND@@

@@ATTR_END|pChildReadExists@@

@@ATTR_BEGIN|pChildReadBoolExists@@
NETWORK
TITLE = Upload boolean child parameter values
    //------------------------------------------------------------------------//
    // CHILD PARAMETER   CHILD PARAMETER   CHILD PARAMETER   CHILD PARAMETER  //
    //                                                                        //
    // Get the initial boolean input value for the child parameter:           //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|CHILD_COMMAND@@
@@ATTR_BEGIN|pChildReadBool@@
    A "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.@@OPERATION@@.@@CHILDPARAMETERATTRIBUTE@@;
    = #p.@@OPERATION@@.@@CHILDPARAMETERALIAS@@_@@CHILDPARAMETERATTRIBUTE@@;
@@ATTR_END|pChildReadBool@@
@@ATTR_END|CHILD_COMMAND@@

@@ATTR_END|pChildReadBoolExists@@

@@ATTR_BEGIN|CHILD_COMMAND@@
@@ATTR_BEGIN|pParentWrite@@
NETWORK
TITLE = Set parent parameter @@CHILDPARAMETERATTRIBUTE@@ value for child device @@CHILDPARAMETERALIAS@@
    //------------------------------------------------------------------------//
    // PARENT PARAMETER   PARENT PARAMETER   PARENT PARAMETER   PARENT PARAM  //
    //                                                                        //
    // Set the initial input value for the child calling parameter:           //
    //------------------------------------------------------------------------//
    A "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.read.mc.modeAUTO;
    @@CHILDCOMMANDSTATEMENT@@
    JCN _parentWrite_@@COUNTERATTR|1@@_@@CHILDPARAMETERALIAS@@_@@CHILDPARAMETERATTRIBUTE@@;
    L #p.@@OPERATION@@.@@CHILDPARAMETERATTRIBUTE@@;
    T #p.@@OPERATION@@.@@CHILDPARAMETERALIAS@@_@@CHILDPARAMETERATTRIBUTE@@;

_parentWrite_@@COUNTERATTR@@_@@CHILDPARAMETERALIAS@@_@@CHILDPARAMETERATTRIBUTE@@:   NOP 0;

@@ATTR_END|pParentWrite@@
@@ATTR_END|CHILD_COMMAND@@

@@ATTR_BEGIN|CHILD_COMMAND@@
@@ATTR_BEGIN|pParentWriteBool@@
NETWORK
TITLE = Set parent parameter @@CHILDPARAMETERATTRIBUTE@@ value for child device @@CHILDPARAMETERALIAS@@
    //------------------------------------------------------------------------//
    // PARENT PARAMETER   PARENT PARAMETER   PARENT PARAMETER   PARENT PARAM  //
    //                                                                        //
    // Set the initial input value for the child calling parameter:           //
    //------------------------------------------------------------------------//
    A "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.read.mc.modeAUTO;
    @@CHILDCOMMANDSTATEMENT@@
    JCN _parentWriteBool_@@COUNTERATTR|1@@_@@CHILDPARAMETERALIAS@@_@@CHILDPARAMETERATTRIBUTE@@;
    A #p.@@OPERATION@@.@@CHILDPARAMETERATTRIBUTE@@;
    = #p.@@OPERATION@@.@@CHILDPARAMETERALIAS@@_@@CHILDPARAMETERATTRIBUTE@@;

_parentWriteBool_@@COUNTERATTR@@_@@CHILDPARAMETERALIAS@@_@@CHILDPARAMETERATTRIBUTE@@:   NOP 0;

@@ATTR_END|pParentWriteBool@@
@@ATTR_END|CHILD_COMMAND@@

@@ATTR_BEGIN|HYGIENE@@
NETWORK
TITLE = Hygiene Status Calculation
    //------------------------------------------------------------------------//
    // HYGIENE   HYGIENE   HYGIENE   HYGIENE   HYGIENE   HYGIENE   HYGIENE    //
    //                                                                        //
    // Calculate the hygiene status of the block:                             //
    //------------------------------------------------------------------------//
    CALL "fcHygiene"
    (   hs                   := #p.read.hs
    );
@@ATTR_END|HYGIENE@@

NETWORK
TITLE = Switch command and state
    //------------------------------------------------------------------------//
    // SWITCH   SWITCH   SWITCH   SWITCH   SWITCH   SWITCH   SWITCH   SWITCH  //
    //                                                                        //
    // Switch statement for block command and state:
    //------------------------------------------------------------------------//
    A #p.read.bmc.eventCmdStart;
    JC _state_STARTING;

    A #p.read.bmc.eventCmdStop;
    JC _state_STOPPING;

    A #p.read.bmc.stateRUNNING;
    JC _state_RUNNING;

    A #p.read.bmc.stateSTOPPED;
    JC _state_STOPPED;

NETWORK
TITLE = Reset running substate if block stopped
    //------------------------------------------------------------------------//
    // All running substates must stop if the block is STOPPED:               //
    //------------------------------------------------------------------------//
_state_STOPPED:      NOP 0;
@@ATTR_BEGIN|SFC@@
    A(;
    L #@@SFC@@.smc.SQ_STATE;
    L "dbCONST".SEQ.STATE.OFF_IDLE;
    ==I;
    );
@@ATTR_END|SFC@@
    A(;
    L #p.read.mc.STATE;
    L "dbCONST".BLK.STATE.STOPPED;
    ==I;
    );
    AN #p.read.bmc.eventCmdStart;
@@ATTR_BEGIN|STATE@@
    R #subsRunning.@@STATE@@;
@@ATTR_END|STATE@@

_state_STARTING: NOP 0;

@@ATTR_BEGIN|STATE@@
NETWORK
TITLE = Substate selected flags
    //------------------------------------------------------------------------//
    // RUNNING SUBSTATE FLAG   RUNNING SUBSTATE FLAG   RUNNING SUBSTATE FLAG  //
    //                                                                        //
    // Convert running substate values into boolean flags for ease of use in  //
    // boolean logic:                                                         //
    //------------------------------------------------------------------------//
	A #p.read.bmc.eventCmdStart;
    A(;
    L #p.write.mc.SUBS;
    L "dbCONST".BLK.@@CLASS@@.SUBS.@@STATE@@;
    ==I;
    );
    = #subsStart.@@STATE@@;


NETWORK
TITLE = Set substate running flags and running SUBSTATE
    //------------------------------------------------------------------------//
    // The STATE is running in the selected substate. Propogate the Substate: //
    //------------------------------------------------------------------------//
    A #subsStart.@@STATE@@;
    JCN _noSubsRun_@@STATE@@;
    S #subsRunning.@@STATE@@;
    L #p.write.mc.SUBS;
    T #p.read.mc.STATE;

_noSubsRun_@@STATE@@:   NOP 0;

@@ATTR_END|STATE@@

@@ATTR_BEGIN|SFC@@
@@ATTR_BEGIN|STATE_DISARM@@
    //------------------------------------------------------------------------//
    // Disarm the flowpath child devices:                                     //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|CHILD_COMMAND@@
    A #subsStart.@@STATE@@;
    @@CHILDCOMMANDSTATEMENT@@
    R "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.write.mc.ARMED;
@@ATTR_END|CHILD_COMMAND@@

@@ATTR_END|STATE_DISARM@@
@@ATTR_END|SFC@@

@@ATTR_BEGIN|SELECT@@
@@ATTR_BEGIN|SELVALUE@@
NETWORK
TITLE = Reset Calling Parameter Selection flags
    //------------------------------------------------------------------------//
    // Reset Calling Parameter selection flags:                               //
    //------------------------------------------------------------------------//
    A #p.read.bmc.eventCmdStart;
    R #selected_@@PARAMETER@@_@@SELECTION@@.@@SELECTIONVALUE@@;
@@ATTR_END|SELVALUE@@
@@ATTR_END|SELECT@@

@@ATTR_BEGIN|SELECT@@
@@ATTR_BEGIN|SELVALUE@@
NETWORK
TITLE = Calling Parameter Selection flags
    //------------------------------------------------------------------------//
    // CALLING PARAMETER SELECTION FLAG   CALLING PARAMETER SELECTION FLAG    //
    //                                                                        //
    // Convert calling parameter selections into the boolean flags for ease   //
    // of use in boolean logic if starting a new substate:                    //
    //------------------------------------------------------------------------//
    A #p.read.bmc.eventCmdStart;
    A(;
    L #p.write.@@PARAMETER@@_@@SELECTION@@;
    L "dbCONST".SEL.@@SELECTION@@.@@SELECTIONVALUE@@;
    ==I;
    );
    S #selected_@@PARAMETER@@_@@SELECTION@@.@@SELECTIONVALUE@@;

@@ATTR_END|SELVALUE@@
@@ATTR_END|SELECT@@

@@ATTR_BEGIN|CHILD_ACQUIRE@@
NETWORK
TITLE = Acquire child @@CHILDPARAMETERALIAS@@
    //------------------------------------------------------------------------//
    // ACQUIRE CHILDREN   ACQUIRE CHILDREN   ACQUIRE CHILDREN   ACQUIRE CHILD //
    //                                                                        //
    // Flag to take writeship of the child now and release at the end if      //
    // the child is available as it would be a child unavailabile failure     //
    // above if not available at this point:                                  //
    //------------------------------------------------------------------------//
    A #p.read.bmc.eventCmdStart;
    @@CHILDACQUIRESTATEMENT@@
    A "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.read.mc.isAvailable;
    JCN _childAvail_@@COUNTERATTR|1@@;
    S #acquire.@@CHILDPARAMETERALIAS@@;
    L #p.read.mc.ME;
    T "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.write.mc.OWNER;

_childAvail_@@COUNTERATTR@@:   NOP 0;

@@ATTR_END|CHILD_ACQUIRE@@

NETWORK
TITLE = Cascade Batch Serial Number to all children
    //------------------------------------------------------------------------//
    // RECIPE AND BATCH ID    RECIPE AND BATCH ID    RECIPE AND BATCH ID      //
    //                                                                        //
    // Cascade this block's Batch Number and Recipe ID to all child devices:  //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|CHILD_COMMAND@@
    A #p.read.bmc.eventCmdStart;
    @@CHILDCOMMANDSTATEMENT@@
    JCN _childBatch_@@COUNTERATTR|1@@;
    L #p.write.mc.SERIALNUM;
    T "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.write.mc.SERIALNUM;
    L #p.write.mc.RECIPE;
    T "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.write.mc.RECIPE;
_childBatch_@@COUNTERATTR|1@@:   NOP 0;

@@ATTR_END|CHILD_COMMAND@@

@@ATTR_BEGIN|STATE@@
@@ATTR_BEGIN|CHILD_INIT_COMMAND_TRUE@@
NETWORK
TITLE = Command child device @@CHILDPARAMETERALIAS@@ for state @@STATE@@ to its initial TRUE condition command
    //------------------------------------------------------------------------//
    // CHILD INITIAL TRUE COMMAND   CHILD INITIAL TRUE COMMAND   CHILD INITIA //
    //                                                                        //
    // Set the initial command values for the child devices.                  //
    // Command the child device to its initial command if condition is true:  //
    //------------------------------------------------------------------------//
    A #subsStart.@@STATE@@;
	A "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.read.mc.modeAUTO;
    @@CHILDCOMMANDSTATEMENT@@
    @@CONDITIONSTATEMENT@@
    JCN _childInitTrue_@@COUNTERATTR|1@@_@@STATE@@_@@CHILDPARAMETERALIAS@@;
    @@TRUESTATEMENT@@

_childInitTrue_@@COUNTERATTR@@_@@STATE@@_@@CHILDPARAMETERALIAS@@:   NOP 0;

@@ATTR_END|CHILD_INIT_COMMAND_TRUE@@
@@ATTR_END|STATE@@

@@ATTR_BEGIN|STATE@@
@@ATTR_BEGIN|CHILD_INIT_COMMAND_FALSE@@
NETWORK
TITLE = Command child device @@CHILDPARAMETERALIAS@@ for state @@STATE@@ to its initial FALSE condition command
    //------------------------------------------------------------------------//
    // CHILD INITIAL FALSE COMMAND   CHILD INITIAL FALSE COMMAND   CHILD INIT //
    //                                                                        //
    // Set the initial command values for the child devices.                  //
    // Command the child device to its initial command:                       //
    //------------------------------------------------------------------------//
    A #subsStart.@@STATE@@;
	A "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.read.mc.modeAUTO;
    A(;
    @@CHILDCOMMANDSTATEMENT@@
    );
    AN(;
    @@CONDITIONSTATEMENT@@
    );
    JCN _childInitFalse_@@COUNTERATTR|1@@_@@STATE@@_@@CHILDPARAMETERALIAS@@;
    @@FALSESTATEMENT@@

_childInitFalse_@@COUNTERATTR@@_@@STATE@@_@@CHILDPARAMETERALIAS@@:   NOP 0;

@@ATTR_END|CHILD_INIT_COMMAND_FALSE@@
@@ATTR_END|STATE@@



@@ATTR_BEGIN|pEventPromptExists@@
NETWORK
TITLE = Clear the operator prompt flags
    //------------------------------------------------------------------------//
    // CLEAR OPERATOR PROMPT   CLEAR OPERATOR PROMPT   CLEAR OPERATOR PROMPT  //
    //                                                                        //
    // Clear the SFC prompt and confirm bits and the global shared event bits://
    //------------------------------------------------------------------------//
    A #p.read.bmc.eventCmdStart;
    JCN _clrPrompt;
@@ATTR_BEGIN|pEventPrompt@@
    R #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;
    R #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@_confirm_yes;
@@ATTR_BEGIN|pEventPromptConfirmNo@@
    R #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@_confirm_no;
@@ATTR_END|pEventPromptConfirmNo@@
    R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_@@NUMEVENT@@].trigger;
    R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_@@NUMEVENT@@].confirmYes;
    R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_@@NUMEVENT@@].confirmNo;
    R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_@@NUMEVENT@@].active;
@@ATTR_END|pEventPrompt@@

_clrPrompt:   NOP 0;
@@ATTR_END|pEventPromptExists@@

@@ATTR_BEGIN|pEventConfirmNoExists@@
NETWORK
TITLE = Clear the event prompt confirm No message flags
    //------------------------------------------------------------------------//
    // CLEAR PROMPT NO   CLEAR PROMPT NO   CLEAR PROMPT NO   CLEAR PROMPT NO  //
    //                                                                        //
    // Clear the SFC event prompt confirm No  bits and the class bits:        //
    //------------------------------------------------------------------------//
    A #p.read.bmc.eventCmdStart;
    JCN _clrConfirmNo;
    L 0;
@@ATTR_BEGIN|pEventConfirmNoWordClass@@
    T #wEventConfirmNo[@@CWORD@@];
@@ATTR_END|pEventConfirmNoWordClass@@

_clrConfirmNo:   NOP 0;
@@ATTR_END|pEventConfirmNoExists@@

@@ATTR_BEGIN|pEventConfirmYesExists@@
NETWORK
TITLE = Clear the event prompt confirm Yes message flags
    //------------------------------------------------------------------------//
    // CLEAR PROMPT YES   CLEAR PROMPT YES   CLEAR PROMPT YES   CLEAR PROMPT  //
    //                                                                        //
    // Clear the SFC event prompt confirm Yes  bits and the class bits:       //
    //------------------------------------------------------------------------//
    A #p.read.bmc.eventCmdStart;
    JCN _clrConfirmYes;
    L 0;
@@ATTR_BEGIN|pEventConfirmYesWordClass@@
    T #wEventConfirmYes[@@CWORD@@];
@@ATTR_END|pEventConfirmYesWordClass@@

_clrConfirmYes:   NOP 0;
@@ATTR_END|pEventConfirmYesExists@@

@@ATTR_BEGIN|pEventLogMsgExists@@
NETWORK
TITLE = Clear the log message flags
    //------------------------------------------------------------------------//
    // CLEAR LOG MESSAGE   CLEAR LOG MESSAGE   CLEAR LOG MESSAGE   CLEAR LOG  //
    //                                                                        //
    // Clear the SFC log message bits and the class bits:                     //
    //------------------------------------------------------------------------//
    A #p.read.bmc.eventCmdStart;
    JCN _clrLogMsg;
    L 0;
@@ATTR_BEGIN|pEventLogMsgWordClass@@
    T #wEventLogMsg[@@CWORD@@];
@@ATTR_END|pEventLogMsgWordClass@@
@@ATTR_BEGIN|pEventLogMsgClass@@
    R #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;
@@ATTR_END|pEventLogMsgClass@@

_clrLogMsg:   NOP 0;
@@ATTR_END|pEventLogMsgExists@@

@@ATTR_BEGIN|pEventLogRealExists@@
NETWORK
TITLE = Clear the log real data flags
    //------------------------------------------------------------------------//
    // CLEAR LOG REAL   CLEAR LOG REAL   CLEAR LOG REAL   CLEAR LOG REAL   CL //
    //                                                                        //
    // Clear the SFC log real data:                                           //
    //------------------------------------------------------------------------//
    A #p.read.bmc.eventCmdStart;
    JCN _clrLogReal;
    L 0;
@@ATTR_BEGIN|pEventLogRealWordClass@@
    T #wEventLogReal[@@CWORD@@];
@@ATTR_END|pEventLogRealWordClass@@
@@ATTR_BEGIN|pEventDataReal@@
    T "dbEVENT".eventDataReal[@@IDXEVENT@@];
@@ATTR_END|pEventDataReal@@
@@ATTR_BEGIN|pEventLogRealClass@@
    R #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;
@@ATTR_END|pEventLogRealClass@@

_clrLogReal:   NOP 0;
@@ATTR_END|pEventLogRealExists@@

@@ATTR_BEGIN|pEventLogTimeExists@@
NETWORK
TITLE = Clear the log time data flags
    //------------------------------------------------------------------------//
    // CLEAR LOG TIME   CLEAR LOG TIME   CLEAR LOG TIME   CLEAR LOG TIME   CL //
    //                                                                        //
    // Clear the SFC log time data:                                           //
    //------------------------------------------------------------------------//
    A #p.read.bmc.eventCmdStart;
    JCN _clrLogTime;
@@ATTR_BEGIN|pEventLogTimeWordClass@@
    T #wEventLogTime[@@CWORD@@];
@@ATTR_END|pEventLogTimeWordClass@@
@@ATTR_BEGIN|pEventDataTime@@
    T "dbEVENT".eventDataTime[@@IDXEVENT@@];
@@ATTR_END|pEventDataTime@@
@@ATTR_BEGIN|pEventLogTimeClass@@
    R #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;
@@ATTR_END|pEventLogTimeClass@@

_clrLogTime:   NOP 0;
@@ATTR_END|pEventLogTimeExists@@

@@ATTR_BEGIN|pEventLogRealExists@@
NETWORK
TITLE = Zero the real data values
    //------------------------------------------------------------------------//
    // ZERO DATA REAL   ZERO DATA REAL   ZERO DATA REAL   ZERO DATA REAL   ZE //
    //                                                                        //
    // Zero the SFC log real data parameter:                                  //
    //------------------------------------------------------------------------//
    A #p.read.bmc.eventCmdStart;
    JCN _clrDataReal;
    L 0;
@@ATTR_BEGIN|pEventDataReal@@
    T #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;
@@ATTR_END|pEventDataReal@@

_clrDataReal:   NOP 0;
@@ATTR_END|pEventLogRealExists@@

@@ATTR_BEGIN|pEventLogTimeExists@@
NETWORK
TITLE = Zero the log time data values
    //------------------------------------------------------------------------//
    // ZERO DATA TIME   ZERO DATA TIME   ZERO DATA TIME   ZERO DATA TIME   ZE //
    //                                                                        //
    // Zero the SFC log time data and the global shared event DB data:        //
    //------------------------------------------------------------------------//
    A #p.read.bmc.eventCmdStart;
    JCN _clrDataTime;
    L 0;
@@ATTR_BEGIN|pEventDataTime@@
    T #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;
@@ATTR_END|pEventDataTime@@

_clrDataTime:   NOP 0;
@@ATTR_END|pEventLogTimeExists@@


@@ATTR_BEGIN|SFC@@
@@ATTR_BEGIN|pSFCParametersRecipeExist@@
NETWORK
TITLE = Set recipe parameters if starting @@SFC@@ running SUBSTATE
    //------------------------------------------------------------------------//
    // Set recipe parameters:                                                 //
    //------------------------------------------------------------------------//
    A #subsStart.@@STATE@@;
    JCN _noStaticParms_@@STATE@@;
@@ATTR_BEGIN|pSFCParametersRecipe@@
    L #p.write.@@BLOCKPARAMETER@@;
    T #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;
@@ATTR_END|pSFCParametersRecipe@@

_noStaticParms_@@STATE@@:   NOP 0;

@@ATTR_END|pSFCParametersRecipeExist@@
@@ATTR_END|SFC@@

@@ATTR_BEGIN|SFC@@
NETWORK
TITLE = Start the SFC sequence @@SFC@@ in Auto for running substate @@STATE@@
    //------------------------------------------------------------------------//
    // START SFC   START SFC   START SFC   START SFC   START SFC   START SFC  //
    //                                                                        //
    // Start the running substate SFC.                                        //
    //                                                                        //
    // Set the running substate SFC to AUTO mode and start it:                //
    //------------------------------------------------------------------------//
    A #subsStart.@@STATE@@;
    JCN _notSFCStarting_@@STATE@@;
    L "dbCONST".SEQ.MODE.AUTO;
    T #@@SFC@@.smc.MODE;
    L "dbCONST".SEQ.CMD.START;
    T #@@SFC@@.smc.SQ_CMD;
    L 0;
    T #@@SFC@@.sqSequencer.CMD.Old;

_notSFCStarting_@@STATE@@:      NOP 0;
@@ATTR_END|SFC@@

_state_STOPPING: NOP 0;

@@ATTR_BEGIN|SFC@@
NETWORK
TITLE = Send SFC STOP command if block stop command given
    //------------------------------------------------------------------------//
    // If commanded to Stop then tell the SFC to go to the last step:         //
    //------------------------------------------------------------------------//
    A #p.read.bmc.eventCmdStop;
    JCN _noAbort_@@STATE@@;
    L "dbCONST".SEQ.CMD.STOP;
    T #@@SFC@@.smc.SQ_CMD;
    T #@@SFC@@.sqSequencer.CMD.New;

_noAbort_@@STATE@@:   NOP 0;

@@ATTR_END|SFC@@

NETWORK
TITLE = Set block state STOPPED if block stopped
    A #p.read.bmc.eventCmdStop;
	JCN _blkStopped;
	L "dbCONST".BLK.@@CLASS@@.STATE.STOPPED;
    T #p.read.mc.STATE;

_blkStopped: NOP 0;

_state_RUNNING: NOP 0;

@@ATTR_BEGIN|SFC@@
NETWORK
TITLE = Any Interlock must pause the running SFC
    //------------------------------------------------------------------------//
    // Pause the running SFC sequence if any interlock or failure condition:  //
    //------------------------------------------------------------------------//
	AN #p.read.bmc.permitStart;
    A #subsRunning.@@STATE@@;
    JCN _ilSFC_@@COUNTERATTR|1@@;
    L "dbCONST".SEQ.CMD.PAUSE;
    T #@@SFC@@.smc.SQ_CMD;
_ilSFC_@@COUNTERATTR@@:   NOP 0;

@@ATTR_END|SFC@@

NETWORK
TITLE = Block errors
    //------------------------------------------------------------------------//
    // Set the block start perimt error status if active:                     //
    //------------------------------------------------------------------------//
    AN #p.read.bmc.permitStart;
    = #p.read.err.permitStart;

    //------------------------------------------------------------------------//
    // Set the child error status if active:                                  //
    //------------------------------------------------------------------------//
    A #flags.childError;
    = #p.read.err.childError;

    //------------------------------------------------------------------------//
    // Set the child unavailable error status if active:                      //
    //------------------------------------------------------------------------//
    A #flags.childUnavailable;
    = #p.read.err.childUnavailable;

    //------------------------------------------------------------------------//
    // Set the child state mismatch error status if active:                   //
    //------------------------------------------------------------------------//
    A #flags.childMismatch;
    A #timeCheckChildStateExpired;
    = #p.read.err.childMismatch;

    //------------------------------------------------------------------------//
    // Set the block error flag if anything gone wrong:                       //
    //------------------------------------------------------------------------//
    O #p.read.err.childError;
    O #p.read.err.childMismatch;
    O #p.read.err.childSafeState;
    O #p.read.err.childUnavailable;
    O #p.read.err.permitStart;
    = #p.read.mc.ERROR;

NETWORK
TITLE = Interlocked condition cleared
    //------------------------------------------------------------------------//
    // Set the state stopped if the interlock condition just cleared:         //
    //------------------------------------------------------------------------//
    AN #p.read.mc.INTERLOCK;
    A(;
    L #p.read.mc.STATE;
    L "dbCONST".BLK.STATE.INTERLOCKED;
    ==I;
    );
    JCN _ilCleared;
    L #p.read.bmc.lastSTATE;
    T #p.read.mc.STATE;

_ilCleared:   NOP 0;

NETWORK
TITLE = Check if any Child state does not match the command
    //------------------------------------------------------------------------//
    // CHILD FLOWPATH STATE MISMATCH   CHILD FLOWPATH STATE MISMATCH   CHILD  //
    //                                                                        //
    // Check if any child flowpath device state does not match the command    //
    // from this parent block if the child state grace period timer has       //
    // expired. Stop checking if the first child state mismatch found:        //
    //------------------------------------------------------------------------//
    A(;
@@ATTR_BEGIN|CHILD_COMMAND@@
    O(;
    @@CHILDCOMMANDSTATEMENT@@
    A "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.write.mc.ARMED;
    A "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.read.mc.FLOWPATH;
    A(;
    L "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.read.mc.STATE;
    L "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.write.mc.CMD;
    <>I;
    );
    A(;
    L "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.read.mc.STATE;
    L "dbCONST".BLK.STATE.COMPLETED;
    <>I;
    );
    AN(;
    A(;
    L "dbCONST".BLK.CMD.START;
    L "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.write.mc.CMD;
    ==I;
    );
    A(;
    L "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.read.mc.STATE;
    L "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.write.mc.SUBS;
    ==I;
    );
    );

    );
@@ATTR_END|CHILD_COMMAND@@
    );
    JCN _noMismatch;

    S #flags.childMismatch;
    JCN _noResetMismatch;
    CLR;

_noMismatch:   NOP 0;
    R #flags.childMismatch;

_noResetMismatch:   NOP 0;

NETWORK
TITLE = If child command changed, start timer to wait for child state
    //------------------------------------------------------------------------//
    // CHILD STATE TIMER   CHILD STATE TIMER   CHILD STATE TIMER   CHILD STAT //
    //                                                                        //
    // If any child command changed then start a timer to provide a grace     //
    // period to allow the child device state to match the command (e.g. to   //
    // allow a valve to move from closed to opened position).                 //
    // Start the child state check timer if a command changed:                //
    //------------------------------------------------------------------------//
    CALL #timeCheckChildState
    {time_type := 'Time'}
    (   IN                          := #flags.childMismatch ,
        PT                          := #p.read.bmc.transTime ,
        Q                           := #timeCheckChildStateExpired ,
        ET                          := #timeCheckChildStateElapsed
    );
    NOP 0;

@@ATTR_BEGIN|SFC@@
NETWORK
TITLE = CALL SFC @@SFC@@ function block if substate @@STATE@@ running
    //------------------------------------------------------------------------//
    // SFC CALL   SFC CALL   SFC CALL   SFC CALL   SFC CALL   SFC CALL   SFC  //
    //                                                                        //
    // Call the SFC function if this is the running substate:                 //
    //------------------------------------------------------------------------//
    A #subsRunning.@@STATE@@;
    JCN _notSFC_@@COUNTERATTR|1@@_@@STATE@@;
    CALL #@@SFC@@
    (
@@ATTR_BEGIN|pSFCParametersBlock@@
        @@CHILDPARAMETER@@   := #p.@@OPERATION@@.@@BLOCKPARAMETER@@ ,
@@ATTR_END|pSFCParametersBlock@@
@@ATTR_BEGIN|pSFCLink@@
        @@CHILDPARAMETER@@   := "idb@@CHILDPARAMETERCLASS@@".f[#p.link.@@CHILDPARAMETERALIAS@@].p.@@OPERATION@@.@@CHILDPARAMETERATTRIBUTE@@ ,
@@ATTR_END|pSFCLink@@
@@ATTR_BEGIN|pSFCChildMCRead@@
        @@CHILDPARAMETER@@   := "idb@@CHILDPARAMETERCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.@@OPERATION@@.mc.@@CHILDPARAMETERATTRIBUTE@@ ,
@@ATTR_END|pSFCChildMCRead@@
@@ATTR_BEGIN|pSFCChildMCWrite@@
        @@CHILDPARAMETER@@   := #p.write.@@BLOCKPARAMETER@@ ,
@@ATTR_END|pSFCChildMCWrite@@
@@ATTR_BEGIN|pSFCChildRead@@
        @@CHILDPARAMETER@@   := "idb@@CHILDPARAMETERCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.@@OPERATION@@.@@CHILDPARAMETERATTRIBUTE@@ ,
@@ATTR_END|pSFCChildRead@@
@@ATTR_BEGIN|pSFCChildWrite@@
        @@CHILDPARAMETER@@   := #p.write.@@BLOCKPARAMETER@@ ,
@@ATTR_END|pSFCChildWrite@@
@@ATTR_BEGIN|pSFCChildWriteBool@@
        @@CHILDPARAMETER@@   := #p.write.@@BLOCKPARAMETER@@ ,
@@ATTR_END|pSFCChildWriteBool@@
@@ATTR_BEGIN|pSFCSelectMCRead@@
        @@CHILDPARAMETER@@   := "idb@@CHILDPARAMETERCLASS@@".f[#p.select.@@CHILDPARAMETERALIAS@@].p.@@OPERATION@@.mc.@@CHILDPARAMETERATTRIBUTE@@ ,
@@ATTR_END|pSFCSelectMCRead@@
@@ATTR_BEGIN|pSFCSelectMCWrite@@
        @@CHILDPARAMETER@@   := #p.select.@@BLOCKPARAMETER@@ ,
@@ATTR_END|pSFCSelectMCWrite@@
        dummy                := #dummy
    );
_notSFC_@@COUNTERATTR@@_@@STATE@@:   NOP 0;

@@ATTR_END|SFC@@

NETWORK
TITLE = Set the child attribute if it is in auto
    //------------------------------------------------------------------------//
    // Check if any state is running:                                         //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|STATE@@
    O #subsRunning.@@STATE@@;
@@ATTR_END|STATE@@
    JCN _noStateRunningForChildAttr;

    //------------------------------------------------------------------------//
    // Set the child substate:                                                //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|CHILD_COMMAND_BLK@@
    A "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.read.mc.modeAUTO;
    @@CHILDCOMMANDSTATEMENT@@
    JCN _pSUBS_@@CHILDPARAMETERALIAS@@;
    L #p.write.@@CHILDPARAMETERALIAS@@_SUBS;
    T "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.write.mc.SUBS;
_pSUBS_@@CHILDPARAMETERALIAS@@:   NOP 0;

@@ATTR_END|CHILD_COMMAND_BLK@@

    //------------------------------------------------------------------------//
    // Set the child command:                                                 //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|CHILD_COMMAND@@
    A "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.read.mc.modeAUTO;
    @@CHILDCOMMANDSTATEMENT@@
    JCN _pCMD_@@CHILDPARAMETERALIAS@@;
    L #p.write.@@CHILDPARAMETERALIAS@@_CMD;
    T "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.write.mc.CMD;
_pCMD_@@CHILDPARAMETERALIAS@@:   NOP 0;

@@ATTR_END|CHILD_COMMAND@@

    //------------------------------------------------------------------------//
    // Upload the child state:                                                //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|CHILD_COMMAND@@
    @@CHILDCOMMANDSTATEMENT@@
    JCN _pSTATE_@@CHILDPARAMETERALIAS@@;
    L "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.read.mc.STATE;
    T #p.read.@@CHILDPARAMETERALIAS@@_STATE;
_pSTATE_@@CHILDPARAMETERALIAS@@:   NOP 0;

@@ATTR_END|CHILD_COMMAND@@

    //------------------------------------------------------------------------//
    // Write the non-boolean child parameters:                                //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|pSFCChildWriteDefine@@
    A "idb@@CHILDPARAMETERCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.read.mc.modeAUTO;
    JCN _pSFCChildWrite_@@CHILDPARAMETERALIAS@@_@@CHILDPARAMETERATTRIBUTE@@;
    L #p.write.@@BLOCKPARAMETER@@;
    T "idb@@CHILDPARAMETERCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.@@OPERATION@@.@@CHILDPARAMETERATTRIBUTE@@;
_pSFCChildWrite_@@CHILDPARAMETERALIAS@@_@@CHILDPARAMETERATTRIBUTE@@: NOP 0;

@@ATTR_END|pSFCChildWriteDefine@@

    //------------------------------------------------------------------------//
    // Write the boolean child parameters:                                    //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|pSFCChildWriteBoolDefine@@
    A "idb@@CHILDPARAMETERCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.read.mc.modeAUTO;
    A #p.write.@@BLOCKPARAMETER@@;
    = "idb@@CHILDPARAMETERCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.@@OPERATION@@.@@CHILDPARAMETERATTRIBUTE@@;

@@ATTR_END|pSFCChildWriteBoolDefine@@

    //------------------------------------------------------------------------//
    // Write the child select parameters:                                     //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|pSFCSelectMCWriteDefine@@
    A "idb@@CHILDPARAMETERCLASS@@".f[#p.select.@@CHILDPARAMETERALIAS@@].p.read.mc.modeAUTO;
    JCN _pSFCSelectMCWrite_@@CHILDPARAMETERALIAS@@_@@CHILDPARAMETERATTRIBUTE@@;
    L #p.select.@@BLOCKPARAMETER@@;
    T "idb@@CHILDPARAMETERCLASS@@".f[#p.select.@@CHILDPARAMETERALIAS@@].p.@@OPERATION@@.mc.@@CHILDPARAMETERATTRIBUTE@@;
_pSFCSelectMCWrite_@@CHILDPARAMETERALIAS@@_@@CHILDPARAMETERATTRIBUTE@@: NOP 0;

@@ATTR_END|pSFCSelectMCWriteDefine@@

_noStateRunningForChildAttr:   NOP 0;

@@ATTR_BEGIN|pEventPromptExists@@
NETWORK
TITLE = Raise operator prompt if required
    //------------------------------------------------------------------------//
    // OPERATOR PROMPT   OPERATOR PROMPT   OPERATOR PROMPT   OPERATOR PROMPT  //
    //                                                                        //
    // Transfer the SFC eventPrompt bit to the global event datablock:        //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|SFC@@
    O #subsRunning.@@STATE@@;
@@ATTR_END|SFC@@
    JCN _noRunPrompt;
@@ATTR_BEGIN|pEventPrompt@@

    A #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;
    JCN _not_eventPrompt_@@IDXEVENT@@;
    L #p.write.mc.SERIALNUM;
    T "dbEVENT".eventPrompt.event[#p.link.eventPrompt_@@NUMEVENT@@].numSerial;
    R #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;
    R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_@@NUMEVENT@@].confirmYes;
@@ATTR_BEGIN|pEventConfirmNoExists@@
    R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_@@NUMEVENT@@].confirmNo;
@@ATTR_END|pEventConfirmNoExists@@
    S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_@@NUMEVENT@@].trigger;
_not_eventPrompt_@@IDXEVENT@@:   NOP 0;

@@ATTR_END|pEventPrompt@@

_noRunPrompt:   NOP 0;

NETWORK
TITLE = Return operator confirm bits if made
    //------------------------------------------------------------------------//
    // OPERATOR CONFIRM   OPERATOR CONFIRM   OPERATOR CONFIRM   OPERATOR CONF //
    //                                                                        //
    // Receive the eventPrompt confirm bits from the global event datablock:  //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|pEventPrompt@@

    A "dbEVENT".eventPrompt.event[#p.link.eventPrompt_@@NUMEVENT@@].confirmYes;
    JCN _not_eventPrompt_@@IDXEVENT@@_confirmYes;
    R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_@@NUMEVENT@@].trigger;
    S #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@_confirm_yes;
    R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_@@NUMEVENT@@].confirmYes;
@@ATTR_BEGIN|pEventConfirmNoExists@@
    R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_@@NUMEVENT@@].confirmNo;
@@ATTR_END|pEventConfirmNoExists@@
_not_eventPrompt_@@IDXEVENT@@_confirmYes:   NOP 0;
@@ATTR_BEGIN|pEventPromptConfirmNo@@
    A "dbEVENT".eventPrompt.event[#p.link.eventPrompt_@@NUMEVENT@@].confirmNo;
    JCN _not_eventPrompt_@@IDXEVENT@@_confirmNo;
    R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_@@NUMEVENT@@].trigger;
    S #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@_confirm_no;
    R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_@@NUMEVENT@@].confirmNo;
    R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_@@NUMEVENT@@].confirmYes;
_not_eventPrompt_@@IDXEVENT@@_confirmNo:   NOP 0;

@@ATTR_END|pEventPromptConfirmNo@@

@@ATTR_END|pEventPrompt@@

@@ATTR_END|pEventPromptExists@@

@@ATTR_BEGIN|pEventConfirmNoExists@@
NETWORK
TITLE = Log prompt confirm No if required
    //------------------------------------------------------------------------//
    // LOG PROMPT CONFIRM NO   LOG PROMPT CONFIRM NO   LOG PROMPT CONFIRM NO  //
    //                                                                        //
    // Set the eventPrompt confirm No message alarm bit if active:            //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|SFC@@
    O #subsRunning.@@STATE@@;
@@ATTR_END|SFC@@
    JCN _noRunConfirmNo;
@@ATTR_BEGIN|pEventConfirmNoClass@@
    A #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;
    = #bEventConfirmNo[@@COFFSET@@];
@@ATTR_END|pEventConfirmNoClass@@

_noRunConfirmNo:   NOP 0;

@@ATTR_END|pEventConfirmNoExists@@

@@ATTR_BEGIN|pEventConfirmYesExists@@
NETWORK
TITLE = Log prompt confirm Yes if required
    //------------------------------------------------------------------------//
    // LOG PROMPT CONFIRM YES   LOG PROMPT CONFIRM YES   LOG PROMPT CONFIRM   //
    //                                                                        //
    // Set the eventPrompt confirm Yes message alarm bit if active:           //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|SFC@@
    O #subsRunning.@@STATE@@;
@@ATTR_END|SFC@@
    JCN _noRunConfirmYes;
@@ATTR_BEGIN|pEventConfirmYesClass@@
    A #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;
    = #bEventConfirmYes[@@COFFSET@@];
@@ATTR_END|pEventConfirmYesClass@@

_noRunConfirmYes:   NOP 0;

@@ATTR_END|pEventConfirmYesExists@@

@@ATTR_BEGIN|pEventLogMsgExists@@
NETWORK
TITLE = Log message if required
    //------------------------------------------------------------------------//
    // LOG MSG   LOG MSG   LOG MSG   LOG MSG   LOG MSG   LOG MSG   LOG MSG    //
    //                                                                        //
    // Set the eventLogMsg message alarm bit if active:                       //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|SFC@@
    O #subsRunning.@@STATE@@;
@@ATTR_END|SFC@@
    JCN _noRunLogMsg;
@@ATTR_BEGIN|pEventLogMsgClass@@
    A #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;   // Bit @@CBIT@@
    = #bEventLogMsg[@@COFFSET@@];
    R #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;

@@ATTR_END|pEventLogMsgClass@@

_noRunLogMsg:   NOP 0;

@@ATTR_END|pEventLogMsgExists@@

@@ATTR_BEGIN|pEventLogRealExists@@
NETWORK
TITLE = Real data
    //------------------------------------------------------------------------//
    // REAL DATA   REAL DATA   REAL DATA   REAL DATA   REAL DATA   REAL DATA  //
    //                                                                        //
    // Transfer the SFC eventLogReal real data to the global event datablock: //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|SFC@@
    O #subsRunning.@@STATE@@;
@@ATTR_END|SFC@@
    JCN _noRunLogReal;
@@ATTR_BEGIN|pEventDataReal@@
    L #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;
    T "dbEVENT".eventDataReal[@@IDXOFFSET@@];
@@ATTR_END|pEventDataReal@@
_noRunLogReal:   NOP 0;

@@ATTR_END|pEventLogRealExists@@

@@ATTR_BEGIN|pEventLogRealExists@@
NETWORK
TITLE = Log real data if required
    //------------------------------------------------------------------------//
    // LOG REAL   LOG REAL   LOG REAL   LOG REAL   LOG REAL   LOG REAL   LOG  //
    //                                                                        //
    // Set the eventLogReal data alarm bit if active:                         //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|SFC@@
    O #subsRunning.@@STATE@@;
@@ATTR_END|SFC@@
    JCN _noRunLogRealData;
@@ATTR_BEGIN|pEventLogRealClass@@
    A #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;   // Bit @@CBIT@@
    = #bEventLogReal[@@COFFSET@@];
    R #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;

@@ATTR_END|pEventLogRealClass@@

_noRunLogRealData:   NOP 0;

@@ATTR_END|pEventLogRealExists@@

@@ATTR_BEGIN|pEventLogTimeExists@@
NETWORK
TITLE = Time data
    //------------------------------------------------------------------------//
    // TIME DATA   TIME DATA   TIME DATA   TIME DATA   TIME DATA   TIME DATA  //
    //                                                                        //
    // Transfer the SFC eventLogTime data to the global event datablock:      //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|SFC@@
    O #subsRunning.@@STATE@@;
@@ATTR_END|SFC@@
    JCN _noRunLogTime;
@@ATTR_BEGIN|pEventDataTime@@
    L #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;
    T "dbEVENT".eventDataTime[@@IDXOFFSET@@];
@@ATTR_END|pEventDataTime@@
_noRunLogTime:   NOP 0;

@@ATTR_END|pEventLogTimeExists@@

@@ATTR_BEGIN|pEventLogTimeExists@@
NETWORK
TITLE = Log time data if required
    //------------------------------------------------------------------------//
    // LOG TIME   LOG TIME   LOG TIME   LOG TIME   LOG TIME   LOG TIME   LOG  //
    //                                                                        //
    // Set the eventLogTime data alarm bit if active:                         //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|SFC@@
    O #subsRunning.@@STATE@@;
@@ATTR_END|SFC@@
    JCN _noRunLogTimeData;
@@ATTR_BEGIN|pEventLogTimeClass@@
    A #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;   // Bit @@CBIT@@
    = #bEventLogTime[@@COFFSET@@];
    R #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;
_not_@@PARAMETERSOURCE@@@@CHILDPARAMETER@@:   NOP 0;

@@ATTR_END|pEventLogTimeClass@@

_noRunLogTimeData:   NOP 0;

@@ATTR_END|pEventLogTimeExists@@

@@ATTR_BEGIN|SFC@@
NETWORK
TITLE = Flag SFC finished if successfully completed execution
    //------------------------------------------------------------------------//
    // SFC COMPLETE   SFC COMPLETE   SFC COMPLETE   SFC COMPLETE   SFC COMPL  //
    //                                                                        //
    // Flag SFC completed if the sequence has finished executing:             //
    //------------------------------------------------------------------------//
    A #subsRunning.@@STATE@@;
    A(;
    L #@@SFC@@.smc.SQ_STATE;
    L "dbCONST".SEQ.STATE.COMPLETED;
    ==I;
    );
    JCN _notFinSuc@@COUNTERATTR|1@@;
    S #flags.sfcCompleted;
_notFinSuc@@COUNTERATTR@@:   NOP 0;

@@ATTR_END|SFC@@

@@ATTR_BEGIN|SFC@@
NETWORK
TITLE = Flag SFC finished if unsuccessfully completed execution
    //------------------------------------------------------------------------//
    // Flag SFC completed if the sequence has been aborted:                   //
    //------------------------------------------------------------------------//
    A #subsRunning.@@STATE@@;
    A(;
    L #@@SFC@@.smc.SQ_STATE;
    L "dbCONST".SEQ.STATE.ABORTED;
    ==I;
    );
    JCN _notFin@@COUNTERATTR|1@@;
    S #flags.sfcCompleted;
    L "dbCONST".BLK.@@CLASS@@.STATE.ABORTED;
    T #p.read.mc.STATE;
_notFin@@COUNTERATTR@@:   NOP 0;

@@ATTR_END|SFC@@

@@ATTR_BEGIN|SFC@@
@@ATTR_BEGIN|STATE_ARM@@
    //------------------------------------------------------------------------//
    // Arm any flowpath child devices:                                        //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|CHILD_COMMAND@@
    A #subsRunning.@@STATE@@;
    @@CHILDCOMMANDSTATEMENT@@
    A(;
    O(;
    A subsHasSFC.@@STATE@@;
    A #flags.sfcCompleted;
    );
    ON subsHasSFC.@@STATE@@;
    );
    S "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.write.mc.ARMED;
@@ATTR_END|CHILD_COMMAND@@

@@ATTR_END|STATE_ARM@@
@@ATTR_END|SFC@@

@@ATTR_BEGIN|STATE@@
NETWORK
TITLE = Set block running substate completed if finished
    //------------------------------------------------------------------------//
    // BLOCK COMPLETE   BLOCK COMPLETE   BLOCK COMPLETE   BLOCK COMPLETE   BL //
    //                                                                        //
    // Set the block state to COMPLETED if no SFC or SFC completed:           //
    //------------------------------------------------------------------------//
    A #subsRunning.@@STATE@@;
    A(;
    O(;
    A subsHasSFC.@@STATE@@;
    A #flags.sfcCompleted;
    );
    ON subsHasSFC.@@STATE@@;
    );
    JCN _blkComplete@@COUNTERATTR|1@@;
    L "dbCONST".BLK.@@CLASS@@.STATE.COMPLETED;
    T #p.read.mc.STATE;
    L #p.write.mc.SUBS;
    T #p.read.bmc.lastSUBS;
    R #flags.sfcCompleted;
    R #subsRunning.@@STATE@@;

_blkComplete@@COUNTERATTR@@:   NOP 0;

@@ATTR_END|STATE@@

@@ATTR_BEGIN|SFC@@
NETWORK
TITLE = Reset block running substate if @@SFC@@ stopped
    //------------------------------------------------------------------------//
    // BLOCK STOPPED   BLOCK STOPPED   BLOCK STOPPED   BLOCK STOPPED   BLOCK  //
    //                                                                        //
    // Reset block running substate if SFC stopped:                               //
    //------------------------------------------------------------------------//
    A #subsRunning.@@STATE@@;
    A(;
    O(;
    A subsHasSFC.@@STATE@@;
    A(;
    L "dbCONST".SEQ.STATE.OFF_IDLE;
    L #@@SFC@@.smc.SQ_STATE;
    ==I;
    );
    );
    ON subsHasSFC.@@STATE@@;
    );
    JCN _sfcStopped_@@SFC@@_@@COUNTERATTR|1@@;
    L #p.write.mc.SUBS;
    T #p.read.bmc.lastSUBS;
    R #flags.sfcCompleted;
    R #subsRunning.@@STATE@@;

_sfcStopped_@@SFC@@_@@COUNTERATTR@@:   NOP 0;

@@ATTR_END|SFC@@


NETWORK
TITLE = Pack the general block alarm bits
    //------------------------------------------------------------------------//
    // Pack the alarm bits into an integer for the HMI to read:               //
    //------------------------------------------------------------------------//
    A #p.read.err.childError;
    = #b[0];
    A #p.read.err.childMismatch;
    = #b[1];
    A #p.read.err.childSafeState;
    = #b[2];
    A #p.read.err.childUnavailable;
    = #b[3];
    A #p.read.err.permitStart;
    = #b[4];
    L #w;
    T #p.read.mc.ALARM;

@@ATTR_BEGIN|pEventConfirmNoExists@@
NETWORK
TITLE = Pack the prompt event confirm No message event alarm bits
    //------------------------------------------------------------------------//
    // Pack the eventPrompt confirm No alarm bits into an integer for the     //
    // HMI to read:                                                           //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|pEventConfirmNoWordClass@@
    L #wEventConfirmNo[@@CWORD@@];
    T #p.read.eventConfirmNo_@@CWORD@@;
@@ATTR_END|pEventConfirmNoWordClass@@
@@ATTR_END|pEventConfirmNoExists@@

@@ATTR_BEGIN|pEventConfirmYesExists@@
NETWORK
TITLE = Pack the prompt event confirm Yes message event alarm bits
    //------------------------------------------------------------------------//
    // Pack the eventPrompt confirm Yes alarm bits into an integer for the    //
    // HMI to read:                                                           //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|pEventConfirmYesWordClass@@
    L #wEventConfirmYes[@@CWORD@@];
    T #p.read.eventConfirmYes_@@CWORD@@;
@@ATTR_END|pEventConfirmYesWordClass@@
@@ATTR_END|pEventConfirmYesExists@@

@@ATTR_BEGIN|pEventLogMsgExists@@
NETWORK
TITLE = Pack the log message event alarm bits
    //------------------------------------------------------------------------//
    // Pack the eventLogMsg alarm bits into an integer for the HMI to read:   //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|pEventLogMsgWordClass@@
    L #wEventLogMsg[@@CWORD@@];
    T #p.read.eventLogMsg_@@CWORD@@;
@@ATTR_END|pEventLogMsgWordClass@@
@@ATTR_END|pEventLogMsgExists@@

@@ATTR_BEGIN|pEventLogRealExists@@
NETWORK
TITLE = Pack the log real data event alarm bits
    //------------------------------------------------------------------------//
    // Pack the eventLogReal alarm bits into an integer for the HMI to read:  //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|pEventLogRealWordClass@@
    L #wEventLogReal[@@CWORD@@];
    T #p.read.eventLogReal_@@CWORD@@;
@@ATTR_END|pEventLogRealWordClass@@
@@ATTR_END|pEventLogRealExists@@

@@ATTR_BEGIN|pEventLogTimeExists@@
NETWORK
TITLE = Pack the log time data event alarm bits
    //------------------------------------------------------------------------//
    // Pack the eventLogTime alarm bits into an integer for the HMI to read:  //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|pEventLogTimeWordClass@@
    L #wEventLogTime[@@CWORD@@];
    T #p.read.eventLogTime_@@CWORD@@;
@@ATTR_END|pEventLogTimeWordClass@@
@@ATTR_END|pEventLogTimeExists@@

@@TEMPLATE_END@@
END_FUNCTION_BLOCK
