//----------------------------------------------------------------------------//
//            Copyright 2018 Rieckermann Engineering Operations               //
//                Automatically Generated File - Do Not Edit                  //
//----------------------------------------------------------------------------//
// Title:       @@CLASS@@
// Description: @@CLASSDESCRIPTION@@
//                                                                            //
// Block functional pseudocode:                                               //
//                                                                            //
// If any Calling Parameter invalid                                           //
//     Set flagBadParameter                                                   //
//                                                                            //
// If any Child not in AUTO mode                                              //
//     Set flagChildNotAuto                                                   //
//                                                                            //
// If any Child in INTERLOCKED state                                          //
//     Set flagChildInterlocked                                               //
//                                                                            //
// If any Child not Owned or not Available                                    //
//     Set flagChildUnavailable                                               //
//                                                                            //
// If flagChildNotAuto OR flagChildInterlocked OR                             //
//                       flagChildUnavailable OR flagChildMismatch            //
//     Set flagChildFailed                                                    //
//                                                                            //
// If no Interlock condition and flagBadParameter ok and flagChildFailed ok   //
//     Set permitStart                                                        //
//                                                                            //
// Call Mode and Command Handling Block                                       //
//                                                                            //
//     Set block to Auto Mode if restarting the PLC                           //
//                                                                            //
//     If permitStart and commanded to Start or running substate changed      //
//         Set one scan pulse eventCommandStart                               //
//                                                                            //
//     If commanded to Stop                                                   //
//         Set one scan pulse eventCommandStop                                //
//                                                                            //
//     If block changed to Auto Mode                                          //
//         Set one scan pulse eventModeAuto                                   //
//                                                                            //
//     If block changed to Manual Mode                                        //
//         Set one scan pulse eventModeManual                                 //
//                                                                            //
//     If block changed to OOS Mode                                           //
//         Set one scan pulse eventModeOOS                                    //
//                                                                            //
//     If any Interlock condition                                             //
//         Set block INTERLOCK flag                                           //
//                                                                            //
//     If block STATE is STOPPED and any Interlock or not permitted to Start  //
//         Set block state INTERLOCKED                                        //
//                                                                            //
//     If block STATE is RUNNING and any Interlock or not permitted to Start  //
//         Set block state PAUSED                                             //
//                                                                            //
//     If block state is INTERLOCKED                                          //
//         Command the block to STOP                                          //
//         Set the selected substate to the safe (stopped) command            //
//                                                                            //
// If eventCommandStart (means all conditions to start are met)               //
//     Convert substates to flags                                             //
//     Convert calling parameter selections to flags                          //
//     If child block Available                                               //
//         Take Ownership and record for later Release                        //
//     Cascade block Batch Serial Number to all children                      //
//     Command child devices to current commands                              //
//                                                                            //
// If eventCommandStart or flagSFCRunning                                     //
//     Write and read SFC commands and status                                 //
//                                                                            //
// If eventCommandStart                                                       //
//     Make sure all non-active SFCs are stopped                              //
//     Synchronise initial child commands to SFC child commands               //
//     Initiate SFC                                                           //
//     Set flagSFCRunning                                                     //
//                                                                            //
// If flagSFCRunning                                                          //
//     If any SFC child command changed then write to child device command    //
//     If any child command changes, start check timer for child state        //
//                     transition grace period                                //
//                                                                            //
// If child state transition check timer elapsed                              //
//     If any child state does not match command                              //
//         Set flagChildMismatch                                              //
//                                                                            //
// If flagSFCRunning and any interlock condition or child failure             //
//     Pause the running SFC                                                  //
//                                                                            //
// If any interlock condition or child failure or SFC problem                 //
//     Set child devices to their safe state (e.g. Closed for a valve)        //
//                                                                            //
// Set any sequence error to acknowledged if so                               //
//                                                                            //
// If the SFC was paused and the error acknowledged and resume command given  //
//     Resume the running SFC                                                 //
//                                                                            //
// Set all SFCs to Auto Mode if the Block changed to Auto                     //
//                                                                            //
// Set flagSFCCompleted if current SFC is Finished                            //
//                                                                            //
// If eventComplete                                                           //
//     Set block state COMPLETED                                              //
//                                                                            //
// If eventComplete and CHILD_RELEASE                                         //
//     Release any child devices taken Ownership                              //
//----------------------------------------------------------------------------//
// Revision history:                                                          //
// Rev By               Date        CC        Note                            //
// 2.0 David Paspa      30-Jan-2018 NA        Reboot for S7-1500.             //
// 1.0 Gerald Kontriner 10-Oct-2009 CC-09/023 Added Alarm flag MON_MISMATCH.  //
// 0.9 Khairul Basar    04-Oct-2009 CC-09/023 SHARED_BY  changed to OWNER int.//
// 0.8 Khairul Basar    02-Oct-2009 CC-09/023 SQ_STATE, ERR flag reset if SQ  //
//                                            off.                            //
// 0.7 Khoon            01-Oct-2009 CC-09/016 Mode=2 init,'Substate change'   //
//                                            added to STOP input of Subs.    //
// 0.6 Khairul Basar    30-Sep-2009 CC-09/023 EM Mode var changed to IN_OUT.  //
// 0.5 Khairul Basar    25-Sep-2009 CC-09/016 Ref2.                           //
// 0.4 Khairul Basar    21-Sep-2009 CC-09/016 Ref1.                           //
// 0.3 Khairul Basar    17-Sep-2009 CC-09/016 Duplicate command/SP parameters //
//                                            deleted auto/manual both now    //
//                                            using same parameters.          //
// 0.2 Khairul Basar    27-Aug-2009 CC-09/023 Path_IL added, Phase updated.   //
// 0.1 Khairul Basar    03-Aug-2009           Initial design.                 //
// Ref2:                                                                      //
// SQ_ACK,SQ_RESUME,SQ_ERROR,CURSTEP,SQ_STATE variables are added as to       //
// control from HMI faceplate.                                                //
// Ref1:                                                                      //
// Phases are updated.Flush & Charge Syncronised for valve commands.SQ_stop   //
// command is passed when CALL flag is OFF(previously there was error).PULSE  //
// timer is created as multiple instance of a standard FB, no more hard coded //
// S5 timer. ERR_FLT is changed to TIMEOUT_VER, PATH_IL to FLOWPATH.Shared    //
// Equipment availability flag programmed,BatchCycle variable added.          //
//----------------------------------------------------------------------------//
// Function definition:                                                       //
//----------------------------------------------------------------------------//
FUNCTION_BLOCK "fb@@CLASS@@"
TITLE = @@CLASSDESCRIPTION@@
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : REO
NAME : fb@@CLASS@@
VERSION : 2.0

//----------------------------------------------------------------------------//
// Declare variables:                                                         //
//----------------------------------------------------------------------------//
@@TEMPLATE_BEGIN@@
VAR_INPUT
    CHILD_RELEASE : Bool;              // Request to release children when complete
@@ATTR_BEGIN|TIMER@@
    TIME_H : Int;
    TIME_M : Int;
    TIME_S : Int;
@@ATTR_END|TIMER@@
END_VAR

VAR_OUTPUT
@@ATTR_BEGIN|TIMER@@
    REM_TIME_H : Int;
    REM_TIME_M : Int;
    REM_TIME_S : Int;
@@ATTR_END|TIMER@@
@@ATTR_BEGIN|pChildIN@@
    @@CHILDPARAMETER@@_@@CLASS@@ : @@PARAMETERDATATYPE@@;    // @@PARAMETERDESCRIPTION@@
@@ATTR_END|pChildIN@@
END_VAR

VAR_IN_OUT
@@ATTR_BEGIN|pBLK@@
    @@BLOCKPARAMETER@@ : @@PARAMETERDATATYPE@@;    // @@PARAMETERDESCRIPTION@@
@@ATTR_END|pBLK@@
@@ATTR_BEGIN|pEventPromptExists@@
    eventPrompt : Struct
@@ATTR_BEGIN|pEventPrompt@@
        @@PARAMETERSOURCE@@@@CHILDPARAMETER@@ : Real;      // @@PARAMETERDESCRIPTION@@
@@ATTR_END|pEventPrompt@@
    END_STRUCT;
@@ATTR_END|pEventPromptExists@@
@@ATTR_BEGIN|pEventConfirmExists@@
    eventConfirm : Struct
@@ATTR_BEGIN|pEventConfirm@@
        @@PARAMETERSOURCE@@@@CHILDPARAMETER@@ : Real;      // @@PARAMETERDESCRIPTION@@
@@ATTR_END|pEventConfirm@@
    END_STRUCT;
@@ATTR_END|pEventConfirmExists@@
@@ATTR_BEGIN|pEventLogMsgExists@@
    eventLogMsg : Struct
@@ATTR_BEGIN|pEventLogMsg@@
        @@PARAMETERSOURCE@@@@CHILDPARAMETER@@ : Real;      // @@PARAMETERDESCRIPTION@@
@@ATTR_END|pEventLogMsg@@
    END_STRUCT;
@@ATTR_END|pEventLogMsgExists@@
@@ATTR_BEGIN|pEventLogRealExists@@
    eventLogReal : Struct
@@ATTR_BEGIN|pEventLogReal@@
        @@PARAMETERSOURCE@@@@CHILDPARAMETER@@ : Real;      // @@PARAMETERDESCRIPTION@@
@@ATTR_END|pEventLogReal@@
    END_STRUCT;
@@ATTR_END|pEventLogRealExists@@
@@ATTR_BEGIN|pEventLogTimeExists@@
    eventLogTime : Struct
@@ATTR_BEGIN|pEventLogTime@@
        @@PARAMETERSOURCE@@@@CHILDPARAMETER@@ : Real;      // @@PARAMETERDESCRIPTION@@
@@ATTR_END|pEventLogTime@@
    END_STRUCT;
@@ATTR_END|pEventLogTimeExists@@
@@ATTR_BEGIN|pEventDataRealExists@@
    eventDataReal : Struct
@@ATTR_BEGIN|pEventDataReal@@
        @@PARAMETERSOURCE@@@@CHILDPARAMETER@@ : Real;      // @@PARAMETERDESCRIPTION@@
@@ATTR_END|pEventDataReal@@
    END_STRUCT;
@@ATTR_END|pEventDataRealExists@@
@@ATTR_BEGIN|pEventDataTimeExists@@
    eventDataTime : Struct
@@ATTR_BEGIN|pEventDataTime@@
        @@PARAMETERSOURCE@@@@CHILDPARAMETER@@ : Real;      // @@PARAMETERDESCRIPTION@@
@@ATTR_END|pEventDataTime@@
    END_STRUCT;
@@ATTR_END|pEventDataTimeExists@@
    DUMMY : Bool;                      // Dummy bit for last parameter without comma
END_VAR

VAR
    mc : "udtModeCommand";             // General mode and command
    mcb : "udtModeCommandBLK";         // Block mode and command
    mcs : "udtModeCommandSFC";         // SFC mode and command
@@ATTR_BEGIN|CHILD_INDEX_MAX@@
    cmc : Array[0..@@CHILDINDEXMAX@@] of "udtModeCommand";
@@ATTR_END|CHILD_INDEX_MAX@@
@@ATTR_BEGIN|HYGIENE@@
    hs : "udtHygiene";
@@ATTR_END|HYGIENE@@
    RUNTMR : "fbRunTimer";
@@ATTR_BEGIN|SFC@@
    @@SFC@@ : "fb@@SFC@@";       // @@STATEDESCRIPTION@@
@@ATTR_END|SFC@@
    timeCheckChildState {OriginalPartName := 'TON'; LibVersion := '1.0'} : TON;
    iErr : Int;                        // Block error flag
    flags : Struct
        badParameter: Bool;
        childCommandChange : Bool;
        childFailed : Bool;
        childInterlocked : Bool;
        childNotAuto : Bool;
        childMismatch : Bool; childUnavailable : Bool;
        sfcCompleted : Bool;
        sfcRunning : Bool;
    END_STRUCT;
    own : Struct
@@ATTR_BEGIN|CHILD@@
        @@CHILDALIASBLOCK@@ : Bool;       // @@CHILDALIASDESCRIPTION@@
@@ATTR_END|CHILD@@
    END_STRUCT;
@@ATTR_BEGIN|SELECT@@
    select@@PARAMETER@@_@@SELECTION@@ : Struct
@@ATTR_BEGIN|SELVALUE@@
        @@SELECTIONVALUE@@ : Bool;
@@ATTR_END|SELVALUE@@
    END_STRUCT;
@@ATTR_END|SELECT@@
    subs : Struct
@@ATTR_BEGIN|STATE@@
        @@STATE@@ : Bool;       // @@STATEDESCRIPTION@@
@@ATTR_END|STATE@@
    END_STRUCT;
    subsHasSFC : Struct
@@ATTR_BEGIN|STATE@@
        @@STATE@@ : Bool := @@HASSFC@@;       // @@STATEDESCRIPTION@@
@@ATTR_END|STATE@@
    END_STRUCT;
END_VAR

VAR_TEMP
    sq_finished : Bool;
//    subsChanged : Bool;
//    stateRunning : Bool;
//    tmpTimeExpired : Bool;
@@ATTR_BEGIN|TIMER@@
    tTime : Time;
    dTime : DInt;
@@ATTR_END|TIMER@@
    returnValue : Int;
END_VAR

BEGIN

//----------------------------------------------------------------------------//
// INPUTS    INPUTS    INPUTS    INPUTS    INPUTS    INPUTS    INPUTS    INPU //
// INPUTS    INPUTS    INPUTS    INPUTS    INPUTS    INPUTS    INPUTS    INPU //
// INPUTS    INPUTS    INPUTS    INPUTS    INPUTS    INPUTS    INPUTS    INPU //
//                                                                            //
// First process block input conditions to determine health and state.        //
//----------------------------------------------------------------------------//
NETWORK
TITLE = Check if calling parameters are valid
    //------------------------------------------------------------------------//
    // CALLING PARAMETERS   CALLING PARAMETERS   CALLING PARAMETERS   CALLING //
    //                                                                        //
    // TODO: Check each calling parameter to make sure it is valid:           //
    //------------------------------------------------------------------------//
    A "alwaysLow";
    = #flags.badParameter;
    = #mcb.BAD_PARAM;

@@ATTR_BEGIN|STATE@@
@@ATTR_BEGIN|CHILD_ACQUIRE@@
NETWORK
TITLE = Check if child @@CHILDALIAS@@ is not in AUTO mode
    //------------------------------------------------------------------------//
    // CHILD NOT AUTO   CHILD NOT AUTO   CHILD NOT AUTO   CHILD NOT AUTO   CH //
    //                                                                        //
    // Check the child device to see if it is not in Auto mode. Only need to  //
    // find the first one so bypass further checks if this child in Manual:   //
    //------------------------------------------------------------------------//
    A #mcb.eventCmdStart;
    A #subs.@@STATE@@;
    AN #cmc[@@CHILDINDEX@@].modeAUTO;
    = #flags.childNotAuto;
    JC _completedChildAutoChecks;

@@ATTR_END|CHILD_ACQUIRE@@
@@ATTR_END|STATE@@

_completedChildAutoChecks:      NOP 0;

@@ATTR_BEGIN|STATE@@
@@ATTR_BEGIN|CHILD_ACQUIRE@@
NETWORK
TITLE = Check if child @@CHILDALIAS@@ is Interlocked
    //------------------------------------------------------------------------//
    // CHILD INTERLOCK   CHILD INTERLOCK   CHILD INTERLOCK   CHILD INTERLOCK  //
    //                                                                        //
    // Check the child device to see if it is in the INTERLOCK state. Only    //
    // need to find the first one so bypass further checks if this child is   //
    // interlocked:                                                           //
    //------------------------------------------------------------------------//
    A #mcb.eventCmdStart;
    A #subs.@@STATE@@;
    A #cmc[@@CHILDINDEX@@].INTERLOCK;
    = #flags.childInterlocked;
    JC _completedChildInterlockChecks;

@@ATTR_END|CHILD_ACQUIRE@@
@@ATTR_END|STATE@@

_completedChildInterlockChecks:      NOP 0;

@@ATTR_BEGIN|STATE@@
@@ATTR_BEGIN|CHILD_ACQUIRE@@
NETWORK
TITLE = Check if Child @@CHILDALIAS@@ is not already Owned or not Available
    //------------------------------------------------------------------------//
    // CHILD UNAVAILABLE   CHILD UNAVAILABLE   CHILD UNAVAILABLE   CHILD UNAV //
    //                                                                        //
    // Check the child device to see if it is already owned by this parent    //
    // or else if it is Available. If Available it will be acquired if needed //
    // later to execute a command. Only need to find the first one so bypass  //
    // further checks if this child is unavailable:                           //
    //------------------------------------------------------------------------//
    A #mcb.eventCmdStart;
    A #subs.@@STATE@@;
    AN #cmc[@@CHILDINDEX@@].isAvailable;
    AN(;
    L #cmc[@@CHILDINDEX@@].OWNER;
    L #mc.ME;
    ==I;
    );
    = #flags.childUnavailable;
    JC _completedChildUnavailableChecks;

@@ATTR_END|CHILD_ACQUIRE@@
@@ATTR_END|STATE@@

_completedChildUnavailableChecks:      NOP 0;

NETWORK
TITLE = Check if any Child has Failed
    //------------------------------------------------------------------------//
    // CHILD FAILED   CHILD FAILED   CHILD FAILED   CHILD FAILED   CHILD FAIL //
    //                                                                        //
    // Check if any child cannot be controlled by this parent block in which  //
    // case this block will fail and so operation at this level should be     //
    // inhibited:                                                             //
    //------------------------------------------------------------------------//
    O #flags.childInterlocked;
    O #flags.childNotAuto;
    O #flags.childUnavailable;
    O #flags.childMismatch;
    = #flags.childFailed;
    = #mcb.CHILD_FAIL;

NETWORK
TITLE = Call General Mode and Command handling block
    //------------------------------------------------------------------------//
    // COMMAND PROCESSOR   COMMAND PROCESSOR   COMMAND PROCESSOR   COMMAND    //
    //                                                                        //
    // Process the standard block functions for command, mode, interlock and  //
    // state:                                                                 //
    //------------------------------------------------------------------------//
    CALL "fcModeCmd"
    (   mc                   := #mc
    );

NETWORK
TITLE = Set Start command permitted flag if all okay
    //------------------------------------------------------------------------//
    // PERMIT START   PERMIT START   PERMIT START   PERMIT START   PERMIT ST  //
    //                                                                        //
    // If no interlock and all calling parameters and child devices are okay  //
    // then a Start is permitted:                                             //
    //------------------------------------------------------------------------//
    AN #mc.INTERLOCK;
    AN #flags.childFailed;
    AN #flags.badParameter;
    = #mcb.permitStart;

NETWORK
TITLE = Call BLOCK Mode and Command handling block
    //------------------------------------------------------------------------//
    // Process the stackable block functions for mode and command change      //
    // events:                                                                //
    //------------------------------------------------------------------------//
    CALL "fcModeCmdBLK"
    (   mcb                  := #mcb
    );

NETWORK
TITLE = Flag SFC not running if a new running substate command issued
    //------------------------------------------------------------------------//
    // Flag SFC is not yet running if new start command:                      //
    //------------------------------------------------------------------------//
    A #mcb.eventCmdStart;
    JCN _notStart;
    R flags.sfcRunning;
_notStart:    NOP 0;

//----------------------------------------------------------------------------//
// RUNNING SUBSTATE    RUNNING SUBSTATE    RUNNING SUBSTATE    RUNNING SUBSTA //
// RUNNING SUBSTATE    RUNNING SUBSTATE    RUNNING SUBSTATE    RUNNING SUBSTA //
// RUNNING SUBSTATE    RUNNING SUBSTATE    RUNNING SUBSTATE    RUNNING SUBSTA //
//                                                                            //
// Process block running substate command.                                    //
//----------------------------------------------------------------------------//
@@ATTR_BEGIN|STATE@@
NETWORK
TITLE = Running Substate flags
    //------------------------------------------------------------------------//
    // RUNNING SUBSTATE FLAG   RUNNING SUBSTATE FLAG   RUNNING SUBSTATE FLAG  //
    //                                                                        //
    // Convert running substate values into boolean flags for ease of use in  //
    // boolean logic if starting a new substate:                              //
    //------------------------------------------------------------------------//
    A #mcb.eventCmdStart;
    A(;
    L #mcb.SUBSelected;
    L "dbCONST".BLK.@@CLASS@@.SUBS.@@STATE@@;
    ==I;
    );
    = #subs.@@STATE@@;

@@ATTR_END|STATE@@

@@ATTR_BEGIN|SELECT@@
@@ATTR_BEGIN|SELVALUE@@
NETWORK
TITLE = Calling Parameter Selection flags
    //------------------------------------------------------------------------//
    // CALLING PARAMETER SELECTION FLAG   CALLING PARAMETER SELECTION FLAG    //
    //                                                                        //
    // Convert calling parameter selections into the boolean flags for ease   //
    // of use in boolean logic if starting a new substate:                    //
    //------------------------------------------------------------------------//
    A #mcb.eventCmdStart;
    A(;
    L #@@PARAMETER@@;
    L "dbCONST".SEL.@@SELECTION@@.@@SELECTIONVALUE@@;
    ==I;
    );
    = #select_@@PARAMETER@@_@@SELECTION@@.@@SELECTIONVALUE@@;

@@ATTR_END|SELVALUE@@
@@ATTR_END|SELECT@@

@@ATTR_BEGIN|STATE@@
@@ATTR_BEGIN|CHILD_ACQUIRE@@
NETWORK
TITLE = Acquire child @@CHILDALIAS@@ for new command if required for the state
    //------------------------------------------------------------------------//
    // ACQUIRE CHILDREN   ACQUIRE CHILDREN   ACQUIRE CHILDREN   ACQUIRE CHILD //
    //                                                                        //
    // Aquire the available child devices.                                    //
    //                                                                        //
    // Flag to take ownership of the child now and release at the end if      //
    // the child is available as it would be a child unavailabile failure     //
    // already above if not available at this point:                          //
    //------------------------------------------------------------------------//
    A #mcb.eventCmdStart;
    A #subs.@@STATE@@;
    A #cmc[@@CHILDINDEX@@].isAvailable;
    = #own.@@CHILDALIASBLOCK@@;

NETWORK
TITLE = Acquire child @@CHILDALIAS@@ for new command
    //------------------------------------------------------------------------//
    // If the child is available take ownership by this block by writing to   //
    // the child owner variable:                                              //
    //------------------------------------------------------------------------//
    A #own.@@CHILDALIASBLOCK@@;
    JCN _childAvail_@@COUNTER|1@@_@@STATE@@;
    L #mc.ME;
    T #cmc[@@CHILDINDEX@@].OWNER;

_childAvail_@@COUNTER@@_@@STATE@@:   NOP 0;

@@ATTR_END|CHILD_ACQUIRE@@
@@ATTR_END|STATE@@

@@ATTR_BEGIN|STATE@@
@@ATTR_BEGIN|CHILD_ACQUIRE@@
NETWORK
TITLE = Cascade Batch Serial Number to children
    //------------------------------------------------------------------------//
    // CHILD BATCH SERIAL NUMBER   CHILD BATCH SERIAL NUMBER   CHILD BATCH SE //
    //                                                                        //
    // Cascade this block's Batch Serial Number to all child devices:         //
    //------------------------------------------------------------------------//
    A #mcb.eventCmdStart;
    A #subs.@@STATE@@;
    JCN _childBatch_@@COUNTER|1@@_@@STATE@@;
    L #mc.SERIALNUM;
    T #cmc[@@CHILDINDEX@@].SERIALNUM;

_childBatch_@@COUNTER@@_@@STATE@@:   NOP 0;

@@ATTR_END|CHILD_ACQUIRE@@
@@ATTR_END|STATE@@

@@ATTR_BEGIN|STATE@@
@@ATTR_BEGIN|pChildIN@@
NETWORK
TITLE = Download calling parameter @@PARAMETER@@ value to child device @@CHILDALIAS@@ for state @@STATE@@
    //------------------------------------------------------------------------//
    // CHILD PARAMETER   CHILD PARAMETER   CHILD PARAMETER   CHILD PARAMETER  //
    //                                                                        //
    // Set the initial input value for the child calling parameter:           //
    //------------------------------------------------------------------------//
    A #mcb.eventCmdStart;
    A #subs.@@STATE@@;
    JCN _childParmIN_@@COUNTER|1@@_@@STATE@@;
    L #@@BLOCKPARAMETER@@;
    T #cmc[@@CHILDINDEX@@].@@CHILDPARAMETER@@;

_childParmIN_@@COUNTER@@_@@STATE@@:   NOP 0;

@@ATTR_END|pChildIN@@
@@ATTR_END|STATE@@

@@ATTR_BEGIN|STATE@@
@@ATTR_BEGIN|CHILD_INIT_COMMAND@@
NETWORK
TITLE = Command child device @@CHILDALIAS@@ for state @@STATE@@ to its initial true condition command
    //------------------------------------------------------------------------//
    // CHILD INITIAL TRUE COMMAND   CHILD INITIAL TRUE COMMAND   CHILD INITIA //
    //                                                                        //
    // Set the initial command values for the child devices.                  //
    // Command the child device to its initial command if condition is true:  //
    //------------------------------------------------------------------------//
    A #mcb.eventCmdStart;
    A #subs.@@STATE@@;
    JCN _childInitTrue_@@COUNTER|1@@_@@STATE@@;
    @@TRUESTATEMENT@@

_childInitTrue_@@COUNTER@@_@@STATE@@:   NOP 0;

@@ATTR_END|CHILD_INIT_COMMAND@@
@@ATTR_END|STATE@@

@@ATTR_BEGIN|STATE@@
@@ATTR_BEGIN|CHILD_INIT_COMMAND@@
NETWORK
TITLE = Command child device @@CHILDALIAS@@ for state @@STATE@@ to its initial false condition command
    //------------------------------------------------------------------------//
    // CHILD INITIAL FALSE COMMAND   CHILD INITIAL FALSE COMMAND   CHILD INIT //
    //                                                                        //
    // Set the initial command values for the child devices.                  //
    // Command the child device to its initial command:                       //
    //------------------------------------------------------------------------//
    A #mcb.eventCmdStart;
    A #subs.@@STATE@@;
    JCN _childInitFalse_@@COUNTER|1@@_@@STATE@@;
    @@FALSESTATEMENT@@

_childInitFalse_@@COUNTER@@_@@STATE@@:   NOP 0;

@@ATTR_END|CHILD_INIT_COMMAND@@
@@ATTR_END|STATE@@

@@ATTR_BEGIN|SFC@@
NETWORK
TITLE = If substate @@STATE@@ is running then set the SFC calling parameters
    //------------------------------------------------------------------------//
    // SFC    SFC    SFC    SFC    SFC    SFC    SFC    SFC    SFC    SFC     //
    // SFC    SFC    SFC    SFC    SFC    SFC    SFC    SFC    SFC    SFC     //
    // SFC    SFC    SFC    SFC    SFC    SFC    SFC    SFC    SFC    SFC     //
    //                                                                        //
    // SFC PARAMETERS   SFC PARAMETERS   SFC PARAMETERS   SFC PARAMETERS   SF //
    //                                                                        //
    // Set the SFC calling parameters if this is the running substate:        //
    //------------------------------------------------------------------------//
    A(;
    O #mcb.eventCmdStart;
    O flags.sfcRunning;
    );
    A #subs.@@STATE@@;
    JCN _notSFC_@@COUNTER|1@@_@@STATE@@;
    CALL #@@SFC@@
    (
@@ATTR_BEGIN|pSFCChild@@
        @@CHILDPARAMETER@@   := #cmc[@@CHILDINDEX@@].@@CHILDPARAMETERATTRIBUTE@@ ,
@@ATTR_END|pSFCChild@@
        mcs                  := #mcs
    );

_notSFC_@@COUNTER@@_@@STATE@@:   NOP 0;

@@ATTR_END|SFC@@

@@ATTR_BEGIN|SFC@@
NETWORK
TITLE = Make sure any non-active SFCs are stopped
    //------------------------------------------------------------------------//
    // Stop any SFC if not the current running substate or if the stop        //
    // command has been issued:                                               //
    //------------------------------------------------------------------------//
    O #mcb.eventCmdStop;
    O(;
    A #mcb.eventCmdStart;
    AN #subs.@@STATE@@;
    );
    JCN _stopSFC_@@COUNTER|1@@_@@STATE@@;
    L "dbCONST".SEQ.CMD.STOP;
    T #@@SFC@@.SQ_CMD;

_stopSFC_@@COUNTER@@_@@STATE@@:   NOP 0;

@@ATTR_END|SFC@@

@@ATTR_BEGIN|pEventPrompt@@
NETWORK
TITLE = Clear the operator prompt flag
    //------------------------------------------------------------------------//
    // CLEAR OPERATOR PROMPT   CLEAR OPERATOR PROMPT   CLEAR OPERATOR PROMPT  //
    //                                                                        //
    // Clear the SFC prompt bit:                                              //
    //------------------------------------------------------------------------//
    A #mcb.eventCmdStart;
    JCN _evPrompt_@@COUNTER|1@@;
    R #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;
_evPrompt_@@COUNTER@@:   NOP 0;

NETWORK
TITLE = Clear the global event DB operator prompt flag
    //------------------------------------------------------------------------//
    // Clear the global shared event DB Prompt bit:                           //
    //------------------------------------------------------------------------//
    A #mcb.eventCmdStart;
    JCN _evgPrompt_@@COUNTER|1@@;
    R #eventPrompt.@@PARAMETERSOURCE@@@@CHILDPARAMETER@@;
_evgPrompt_@@COUNTER@@:   NOP 0;

@@ATTR_END|pEventPrompt@@

@@ATTR_BEGIN|pEventConfirm@@
NETWORK
TITLE = Clear the operator confirm flag
    //------------------------------------------------------------------------//
    // CLEAR OPERATOR CONFIRM   CLEAR OPERATOR CONFIRM   CLEAR OPERATOR CONFI //
    //                                                                        //
    // Clear the SFC confirm bit:                                             //
    //------------------------------------------------------------------------//
    A #mcb.eventCmdStart;
    JCN _evConfirm_@@COUNTER|1@@;
    R #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;
_evConfirm_@@COUNTER@@:   NOP 0;

NETWORK
TITLE = Clear the global event DB operator confirm flag
    //------------------------------------------------------------------------//
    // Clear the global shared event DB Confirm bit:                          //
    //------------------------------------------------------------------------//
    A #mcb.eventCmdStart;
    JCN _evgConfirm_@@COUNTER|1@@;
    R #eventConfirm.@@PARAMETERSOURCE@@@@CHILDPARAMETER@@;
_evgConfirm_@@COUNTER@@:   NOP 0;

@@ATTR_END|pEventConfirm@@

@@ATTR_BEGIN|pEventLogMsg@@
NETWORK
TITLE = Clear the log message flag
    //------------------------------------------------------------------------//
    // CLEAR LOG MESSAGE   CLEAR LOG MESSAGE   CLEAR LOG MESSAGE   CLEAR LOG  //
    //                                                                        //
    // Clear the SFC log message bit:                                         //
    //------------------------------------------------------------------------//
    A #mcb.eventCmdStart;
    JCN _evLogMsg_@@COUNTER|1@@;
    R #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;
_evLogMsg_@@COUNTER@@:   NOP 0;

NETWORK
TITLE = Clear the global event DB log message flag
    //------------------------------------------------------------------------//
    // Clear the global shared event DB Log Message bit:                      //
    //------------------------------------------------------------------------//
    A #mcb.eventCmdStart;
    JCN _evgLogMsg_@@COUNTER|1@@;
    R #eventLogMsg.@@PARAMETERSOURCE@@@@CHILDPARAMETER@@;
_evgLogMsg_@@COUNTER@@:   NOP 0;

@@ATTR_END|pEventLogMsg@@

@@ATTR_BEGIN|pEventLogReal@@
NETWORK
TITLE = Clear the log real data flag
    //------------------------------------------------------------------------//
    // CLEAR LOG REAL   CLEAR LOG REAL   CLEAR LOG REAL   CLEAR LOG REAL   CL //
    //                                                                        //
    // Clear the SFC log real bit:                                            //
    //------------------------------------------------------------------------//
    A #mcb.eventCmdStart;
    JCN _evLogReal_@@COUNTER|1@@;
    R #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;
_evLogReal_@@COUNTER@@:   NOP 0;

NETWORK
TITLE = Clear the global event DB log real data flag
    //------------------------------------------------------------------------//
    // Clear the global shared event DB Log Real data bit:                    //
    //------------------------------------------------------------------------//
    A #mcb.eventCmdStart;
    JCN _evgLogReal_@@COUNTER|1@@;
    R #eventLogReal.@@PARAMETERSOURCE@@@@CHILDPARAMETER@@;
_evgLogReal_@@COUNTER@@:   NOP 0;

@@ATTR_END|pEventLogReal@@

@@ATTR_BEGIN|pEventLogTime@@
NETWORK
TITLE = Clear the log message flag
    //------------------------------------------------------------------------//
    // CLEAR LOG TIME   CLEAR LOG TIME   CLEAR LOG TIME   CLEAR LOG TIME   CL //
    //                                                                        //
    // Clear the SFC log time bit:                                            //
    //------------------------------------------------------------------------//
    A #mcb.eventCmdStart;
    JCN _evLogTime_@@COUNTER|1@@;
    R #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;
_evLogTime_@@COUNTER@@:   NOP 0;

NETWORK
TITLE = Clear the global event DB log time data flag
    //------------------------------------------------------------------------//
    // Clear the global shared event DB Log Time data bit:                    //
    //------------------------------------------------------------------------//
    A #mcb.eventCmdStart;
    JCN _evgLogTime_@@COUNTER|1@@;
    R #eventLogTime.@@PARAMETERSOURCE@@@@CHILDPARAMETER@@;
_evgLogTime_@@COUNTER@@:   NOP 0;

@@ATTR_END|pEventLogTime@@

@@ATTR_BEGIN|pEventDataReal@@
NETWORK
TITLE = Zero the real data value
    //------------------------------------------------------------------------//
    // ZERO DATA REAL   ZERO DATA REAL   ZERO DATA REAL   ZERO DATA REAL   ZE //
    //                                                                        //
    // Zero the SFC log real data:                                            //
    //------------------------------------------------------------------------//
    A #mcb.eventCmdStart;
    JCN _evDataReal_@@COUNTER|1@@;
    L 0;
    T #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;
_evDataReal_@@COUNTER@@:   NOP 0;

NETWORK
TITLE = Zero the global event DB log real data
    //------------------------------------------------------------------------//
    // Clear the global shared event DB Data Real data bit:                    //
    //------------------------------------------------------------------------//
    A #mcb.eventCmdStart;
    JCN _evgDataReal_@@COUNTER|1@@;
    L 0;
    T #eventDataReal.@@PARAMETERSOURCE@@@@CHILDPARAMETER@@;
_evgDataReal_@@COUNTER@@:   NOP 0;

@@ATTR_END|pEventDataReal@@

@@ATTR_BEGIN|pEventDataTime@@
NETWORK
TITLE = Zero the log time data
    //------------------------------------------------------------------------//
    // ZERO DATA TIME   ZERO DATA TIME   ZERO DATA TIME   ZERO DATA TIME   ZE //
    //                                                                        //
    // Zero the SFC log time data:                                            //
    //------------------------------------------------------------------------//
    A #mcb.eventCmdStart;
    JCN _evDataTime_@@COUNTER|1@@;
    L 0;
    T #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;
_evDataTime_@@COUNTER@@:   NOP 0;

NETWORK
TITLE = Zero the global event DB log time data
    //------------------------------------------------------------------------//
    // Zero the global shared event DB Time data:                             //
    //------------------------------------------------------------------------//
    A #mcb.eventCmdStart;
    JCN _evgDataTime_@@COUNTER|1@@;
    L 0;
    T #eventDataTime.@@PARAMETERSOURCE@@@@CHILDPARAMETER@@;
_evgDataTime_@@COUNTER@@:   NOP 0;

@@ATTR_END|pEventDataTime@@

@@ATTR_BEGIN|SFC@@
@@ATTR_BEGIN|pSFCChildIN@@
NETWORK
TITLE = Synchronise SFC @@SFC@@ child state for child @@CHILDPARAMETER@@
    //------------------------------------------------------------------------//
    // SYNC SFC CHILD STATE    SYNC SFC CHILD STATE    SYNC SFC CHILD STATE   //
    //                                                                        //
    // Update the SFC child states if the SFC is about to start or already    //
    // running:                                                               //
    //------------------------------------------------------------------------//
    A(;
    O #mcb.eventCmdStart;
    O flags.sfcRunning;
    );
    A #subs.@@STATE@@;
    JCN _cState_@@COUNTER|1@@_@@STATE@@;
    L #cmc[@@CHILDINDEX@@].@@CHILDPARAMETERATTRIBUTE@@;
    T #@@SFC@@.@@CHILDPARAMETER@@;

_cState_@@COUNTER@@_@@STATE@@:   NOP 0;

@@ATTR_END|pSFCChildIN@@
@@ATTR_END|SFC@@

@@ATTR_BEGIN|SFC@@
@@ATTR_BEGIN|pSFCChildOUT@@
NETWORK
TITLE = Synchronise SFC @@SFC@@ child command for child @@CHILDPARAMETER@@
    //------------------------------------------------------------------------//
    // SYNC SFC CHILD COMMANDS    SYNC SFC CHILD COMMANDS    SYNC SFC CHILD   //
    //                                                                        //
    // Write the initial command to any SFC child commands to synchronise     //
    // them at the start of the SFC:                                          //
    //------------------------------------------------------------------------//
    A #mcb.eventCmdStart;
    A #subs.@@STATE@@;
    JCN _cCmd_@@COUNTER|1@@_@@STATE@@;
    L #cmc[@@CHILDINDEX@@].@@CHILDPARAMETERATTRIBUTE@@;
    T #@@SFC@@.@@CHILDPARAMETER@@;

_cCmd_@@COUNTER@@_@@STATE@@:   NOP 0;

@@ATTR_END|pSFCChildOUT@@
@@ATTR_END|SFC@@

@@ATTR_BEGIN|SFC@@
NETWORK
TITLE = Start the SFC sequence @@SFC@@ for running substate @@STATE@@
    //------------------------------------------------------------------------//
    // START SFC   START SFC   START SFC   START SFC   START SFC   START SFC  //
    //                                                                        //
    // Start the substate SFC.                                                //
    //                                                                        //
    // Bypass if not the current running substate:                            //
    //------------------------------------------------------------------------//
    A #mcb.eventCmdStart;
    A #subs.@@STATE@@;
    JCN _notSFCStarting_2_@@STATE@@;

    //------------------------------------------------------------------------//
    // Start the SFC for the running substate:                                //
    //------------------------------------------------------------------------//
    L "dbCONST".SEQ.CMD.START;
    T #@@SFC@@.SQ_CMD;
    S flags.sfcRunning;

_notSFCStarting_2_@@STATE@@:      NOP 0;
@@ATTR_END|SFC@@

@@ATTR_BEGIN|SFC@@
NETWORK
TITLE = Check if any new Child command if SFC @@SFC@@ is running
    //------------------------------------------------------------------------//
    // NEW CHILD COMMAND   NEW CHILD COMMAND   NEW CHILD COMMAND   NEW CHILD  //
    //                                                                        //
    // Check if the running SFC requests to change any child command. Check   //
    // this is the running SFC:                                               //
    //------------------------------------------------------------------------//
    A #subs.@@STATE@@;
    A flags.sfcRunning;
    AN #@@SFC@@.PAUSED;
    AN #@@SFC@@.ERR_FAULT;
    JCN _notSFCRunning_1_@@STATE@@;
    NOP 0;

@@ATTR_BEGIN|pSFCChildOUT@@
NETWORK
TITLE = Check if the SFC Child command has changed
    //------------------------------------------------------------------------//
    // Check if the running SFC requests to change this child command:        //
    //------------------------------------------------------------------------//
    L #cmc[@@CHILDINDEX@@].@@CHILDPARAMETERATTRIBUTE@@;
    L #@@SFC@@.@@CHILDPARAMETER@@;
    <>I;
    JCN _noCommandChange_@@COUNTER|1@@_@@STATE@@;

NETWORK
TITLE = Send the updated SFC Child command to the child
    //------------------------------------------------------------------------//
    // Send the udpated SFC child command to the child:                       //
    //------------------------------------------------------------------------//
    L #@@SFC@@.@@CHILDPARAMETER@@;
    T #cmc[@@CHILDINDEX@@].@@CHILDPARAMETERATTRIBUTE@@;
    S #flags.childCommandChange;

_noCommandChange_@@COUNTER@@_@@STATE@@:      NOP 0;

@@ATTR_END|pSFCChildOUT@@

_notSFCRunning_1_@@STATE@@:      NOP 0;

@@ATTR_END|SFC@@

NETWORK
TITLE = If child command changed, start timer to wait for child state
    //------------------------------------------------------------------------//
    // CHILD STATE TIMER   CHILD STATE TIMER   CHILD STATE TIMER   CHILD STAT //
    //                                                                        //
    // If any child command changed then start a timer to provide a grace     //
    // period to allow the child device state to match the command (e.g. to   //
    // allow a valve to move from closed to opened position).                 //
    // Start the child state check timer if a command changed:                //
    //------------------------------------------------------------------------//
    CALL #timeCheckChildState
    {time_type := 'Time'}
    (   IN                          := #flags.childCommandChange ,
        PT                          := T#10S ,
        Q                           := #timeCheckChildState.Q ,
        ET                          := #timeCheckChildState.ET
    );
    NOP 0;

@@ATTR_BEGIN|STATE@@
@@ATTR_BEGIN|CHILD_ACQUIRE@@
NETWORK
TITLE = Check if any Child state does not match the command
    //------------------------------------------------------------------------//
    // CHILD STATE MISMATCH   CHILD STATE MISMATCH   CHILD STATE MISMATCH     //
    //                                                                        //
    // Check if any child device state does not match the command from this   //
    // parent block if the child state grace period timer has expired. Stop   //
    // checking if the first child state mismatch found:                      //
    //------------------------------------------------------------------------//
    A #timeCheckChildState.Q;
    L #cmc[@@CHILDINDEX@@].STATE;
    L #cmc[@@CHILDINDEX@@].CMD;
    <>I;
    JCN _cNoMismatch_@@COUNTER|1@@_@@STATE@@;
    S #flags.childMismatch;

_cNoMismatch_@@COUNTER@@_@@STATE@@:   NOP 0;

@@ATTR_END|CHILD_ACQUIRE@@
@@ATTR_END|STATE@@

NETWORK
TITLE = Reset the new child command flag if a mismatch
    //------------------------------------------------------------------------//
    // Reset the child device command changed flag if a mismatch occurred:    //
    //------------------------------------------------------------------------//
    A #timeCheckChildState.Q;
    JCN _ccstate;
    R #flags.childCommandChange;
_ccstate:   NOP 0;

@@ATTR_BEGIN|pEventPrompt@@
NETWORK
TITLE = Raise operator prompt if required
    //------------------------------------------------------------------------//
    // OPERATOR PROMPT   OPERATOR PROMPT   OPERATOR PROMPT   OPERATOR PROMPT  //
    //                                                                        //
    // Transfer the SFC prompt bit to the global event datablock:             //
    //------------------------------------------------------------------------//
    A #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;
    = #eventPrompt.@@PARAMETERSOURCE@@@@CHILDPARAMETER@@;

@@ATTR_END|pEventPrompt@@

@@ATTR_BEGIN|pEventConfirm@@
NETWORK
TITLE = Return operator bit if made
    //------------------------------------------------------------------------//
    // OPERATOR CONFIRM   OPERATOR CONFIRM   OPERATOR CONFIRM   OPERATOR CONF //
    //                                                                        //
    // Receive the SFC confirm bit from the global event datablock:           //
    //------------------------------------------------------------------------//
    A #eventConfirm.@@PARAMETERSOURCE@@@@CHILDPARAMETER@@;
    = #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;

@@ATTR_END|pEventConfirm@@

@@ATTR_BEGIN|pEventLogMsg@@
NETWORK
TITLE = Log message if required
    //------------------------------------------------------------------------//
    // LOG MSG   LOG MSG   LOG MSG   LOG MSG   LOG MSG   LOG MSG   LOG MSG    //
    //                                                                        //
    // Transfer the SFC log data to the global event datablock:               //
    //------------------------------------------------------------------------//
    A #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;
    = #eventLogMsg.@@PARAMETERSOURCE@@@@CHILDPARAMETER@@;

@@ATTR_END|pEventLogMsg@@

@@ATTR_BEGIN|pEventLogReal@@
NETWORK
TITLE = Log real data if required
    //------------------------------------------------------------------------//
    // LOG REAL   LOG REAL   LOG REAL   LOG REAL   LOG REAL   LOG REAL   LOG  //
    //                                                                        //
    // Transfer the SFC log data to the global event datablock:               //
    //------------------------------------------------------------------------//
    A #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;
    = #eventLogReal.@@PARAMETERSOURCE@@@@CHILDPARAMETER@@;

@@ATTR_END|pEventLogReal@@

@@ATTR_BEGIN|pEventLogTime@@
NETWORK
TITLE = Log time data if required
    //------------------------------------------------------------------------//
    // LOG TIME   LOG TIME   LOG TIME   LOG TIME   LOG TIME   LOG TIME   LOG  //
    //                                                                        //
    // Transfer the SFC log data to the global event datablock:               //
    //------------------------------------------------------------------------//
    A #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;
    = #eventLogTime.@@PARAMETERSOURCE@@@@CHILDPARAMETER@@;

@@ATTR_END|pEventLogTime@@

@@ATTR_BEGIN|pEventDataReal@@
NETWORK
TITLE = Real data
    //------------------------------------------------------------------------//
    // REAL DATA   REAL DATA   REAL DATA   REAL DATA   REAL DATA   REAL DATA  //
    //                                                                        //
    // Transfer the SFC log data to the global event datablock:               //
    //------------------------------------------------------------------------//
    L #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;
    T #eventDataReal.@@PARAMETERSOURCE@@@@CHILDPARAMETER@@;

@@ATTR_END|pEventDataReal@@

@@ATTR_BEGIN|pEventDataTime@@
NETWORK
TITLE = Time data
    //------------------------------------------------------------------------//
    // TIME DATA   TIME DATA   TIME DATA   TIME DATA   TIME DATA   TIME DATA  //
    //                                                                        //
    // Transfer the SFC log data to the global event datablock:               //
    //------------------------------------------------------------------------//
    L #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;
    T #eventDataTime.@@PARAMETERSOURCE@@@@CHILDPARAMETER@@;

@@ATTR_END|pEventDataTime@@

@@ATTR_BEGIN|SFC@@
NETWORK
TITLE = Any Interlock must pause the running SFC
    //------------------------------------------------------------------------//
    // Pause the running SFC sequence if any interlock or failure condition:  //
    //------------------------------------------------------------------------//
    AN #mcb.permitStart;
    A flags.sfcRunning;
    A #subs.@@STATE@@;
    JCN _ilSFC_@@COUNTER|1@@;
    L "dbCONST".SEQ.CMD.PAUSE;
    T #@@SFC@@.SQ_CMD;
_ilSFC_@@COUNTER@@:   NOP 0;

@@ATTR_END|SFC@@

NETWORK
TITLE = Stop the module if any problem
    //------------------------------------------------------------------------//
    // STOP ON INTERLOCK   STOP ON INTERLOCK   STOP ON INTERLOCK   STOP ON IN //
    //                                                                        //
    // Stop the block if any interlock condition or not permitted to strat:   //
    //------------------------------------------------------------------------//
    O #mc.INTERLOCK;
    ON #mcb.permitStart;
    JCN _stopBlock;
    L "dbCONST".BLK.CMD.STOP;
    T #mc.CMD;
_stopBlock:   NOP 0;

@@ATTR_BEGIN|STATE@@
@@ATTR_BEGIN|CHILD_ACQUIRE@@
NETWORK
TITLE = Set child device @@CHILDALIAS@@ to safe state if any interlock or child failure
    //------------------------------------------------------------------------//
    // SAFE STATE   SAFE STATE   SAFE STATE   SAFE STATE  SAFE STATE  SAFE ST //
    //                                                                        //
    // Set the child device to the safe state on any interlock condition or   //
    // child failure:                                                         //
    //------------------------------------------------------------------------//
    O #mc.INTERLOCK;
    ON #mcb.permitStart;
    JCN _childSafe_@@COUNTER|1@@_@@STATE@@;
    L "dbCONST".BLK.@@CHILDCLASS@@.SAFE.CMD;
    T #cmc[@@CHILDINDEX@@].CMD;

_childSafe_@@COUNTER@@_@@STATE@@:   NOP 0;

@@ATTR_END|CHILD_ACQUIRE@@
@@ATTR_END|STATE@@

@@ATTR_BEGIN|SFC@@
@@ATTR_BEGIN|CHILD_ACQUIRE@@
NETWORK
TITLE = Set child devices to safe state if SFC @@SFC@@ Paused or Error
    //------------------------------------------------------------------------//
    // SAFE STATE ON SFC ERROR   SAFE STATE ON SFC ERROR   SAFE STATE ON SFC  //
    //                                                                        //
    // Bypass if the current SFC is running okay:                             //
    //------------------------------------------------------------------------//
    A #mcb.permitStart;
    A #subs.@@STATE@@;
    A #flags.sfcRunning;
    A(;
    O #@@SFC@@.PAUSED;
    O #@@SFC@@.ERR_FAULT;
    );
    JCN _safeSFC@@COUNTER|1@@_@@SFC@@;

    //------------------------------------------------------------------------//
    // Set all child devices to safe state due to sequence problem:           //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|CHILD@@
    L "dbCONST".BLK.@@CHILDALIASCLASS@@.SAFE.CMD;
    T #cmc[@@CHILDINDEX@@].CMD;
@@ATTR_END|CHILD@@

_safeSFC@@COUNTER@@_@@SFC@@:   NOP 0;

@@ATTR_END|CHILD_ACQUIRE@@
@@ATTR_END|SFC@@

@@ATTR_BEGIN|SFC@@
NETWORK
TITLE = Acknowlede Sequence Error Fault
    //------------------------------------------------------------------------//
    // SFC ERROR ACKNOWLDGE   SFC ERROR ACKNOWLDGE   SFC ERROR ACKNOWLDGE     //
    //                                                                        //
    // If the sequence error has been acknowledged, set the SFC command to    //
    // error acknowledged:                                                    //
    //------------------------------------------------------------------------//
    A #mcs.SQ_ACK;
    A #mcs.SQ_ERROR;
    A #subs.@@STATE@@;
    JCN _ackSFC@@COUNTER|1@@;
    L "dbCONST".SEQ.CMD.ACKNOWLEDGE_ERR;
    T #@@SFC@@.SQ_CMD;
_ackSFC@@COUNTER@@:   NOP 0;

@@ATTR_END|SFC@@

@@ATTR_BEGIN|SFC@@
NETWORK
TITLE = SQ Acknowlede Error Fault and Resume
    //------------------------------------------------------------------------//
    // Reset the sequence error acknowledge flag:                             //
    //------------------------------------------------------------------------//
    A #mcs.SQ_ACK;
    A #mcs.SQ_ERROR;
    A #subs.@@STATE@@;
    JCN _rAckSFC@@COUNTER|1@@;
    R #mcs.SQ_ACK;
_rAckSFC@@COUNTER@@:   NOP 0;

@@ATTR_END|SFC@@

@@ATTR_BEGIN|SFC@@
NETWORK
TITLE = SQ Acknowlede Error Fault and Resume
    //------------------------------------------------------------------------//
    // SFC RESUME   SFC RESUME   SFC RESUME   SFC RESUME   SFC RESUME   SFC R //
    //                                                                        //
    // Check if the sequence was paused or an error was acknowledged and the  //
    // SFC is to be resumed:                                                  //
    //------------------------------------------------------------------------//
    A #mcs.SQ_RESUME;
    A #subs.@@STATE@@;
    A(;
    O(;
    L #mcs.SQ_STATE;
    L "dbCONST".SEQ.CMD.PAUSE;
    ==I;
    );
    O(;
    L #mcs.SQ_STATE;
    L "dbCONST".SEQ.CMD.ACKNOWLEDGE_ERR;
    ==I;
    );
    );
    JCN _res1SFC@@COUNTER|1@@;
    L "dbCONST".SEQ.CMD.RESUME;
    T #@@SFC@@.SQ_CMD;
    R #mcs.SQ_RESUME;
_res1SFC@@COUNTER@@:   NOP 0;

@@ATTR_END|SFC@@

@@ATTR_BEGIN|SFC@@
NETWORK
TITLE = All SQ are in Auto mode when EM in Auto
    //------------------------------------------------------------------------//
    // SFC AUTO   SFC AUTO   SFC AUTO   SFC AUTO   SFC AUTO   SFC AUTO   SFC  //
    //                                                                        //
    // Set all SFCs to AUTO mode if the block is in AUTO:                     //
    //------------------------------------------------------------------------//
    A #mcb.eventModeAUTO;
    JCN _nomc@@COUNTER|1@@;
    L #mc.MODE;
    T #@@SFC@@.MODE;
_nomc@@COUNTER@@:   NOP 0;

@@ATTR_END|SFC@@

@@ATTR_BEGIN|SFC@@
NETWORK
TITLE = Flag SFC finished if completed execution
    //------------------------------------------------------------------------//
    // SFC COMPLETE   SFC COMPLETE   SFC COMPLETE   SFC COMPLETE   SFC COMPL  //
    //                                                                        //
    // Flag SFC completed if the sequence has finished executing:             //
    //------------------------------------------------------------------------//
    A #subs.@@STATE@@;
    A #@@SFC@@.SQ_FINISHED;
    JCN _notFin@@COUNTER|1@@;
    S #flags.sfcCompleted;
_notFin@@COUNTER@@:   NOP 0;

@@ATTR_END|SFC@@

@@ATTR_BEGIN|STATE@@
@@ATTR_BEGIN|CHILD_ACQUIRE@@
NETWORK
TITLE = Release child @@CHILDALIAS@@ if acquired and command completed
    //------------------------------------------------------------------------//
    // COMPLETE    COMPLETE    COMPLETE    COMPLETE    COMPLETE    COMPLETE   //
    // COMPLETE    COMPLETE    COMPLETE    COMPLETE    COMPLETE    COMPLETE   //
    // COMPLETE    COMPLETE    COMPLETE    COMPLETE    COMPLETE    COMPLETE   //
    //                                                                        //
    // RELEASE CHILD   RELEASE CHILD   RELEASE CHILD   RELEASE CHILD   RELE   //
    //                                                                        //
    // Release the child device if acquired earlier to run the command:       //
    //------------------------------------------------------------------------//
    A #flags.sfcCompleted;
    A #own.@@CHILDALIASBLOCK@@;
    A #CHILD_RELEASE;
    JCN _notOwn@@COUNTER|1@@_@@STATE@@;
    L "dbCONST".BLK.ID.AVAILABLE;
    T #cmc[@@CHILDINDEX@@].OWNER;
    R #own.@@CHILDALIASBLOCK@@;
_notOwn@@COUNTER@@_@@STATE@@:   NOP 0;

@@ATTR_END|CHILD_ACQUIRE@@
@@ATTR_END|STATE@@

@@ATTR_BEGIN|STATE@@
NETWORK
TITLE = Set block running substate completed if finished
    //------------------------------------------------------------------------//
    // BLOCK COMPLETE   BLOCK COMPLETE   BLOCK COMPLETE   BLOCK COMPLETE   BL //
    //                                                                        //
    // Set the block state to COMPLETED if no SFC or SFC completed:           //
    //------------------------------------------------------------------------//
    O(;
    A subsHasSFC.@@STATE@@;
    A #flags.sfcCompleted;
    );
    ON subsHasSFC.@@STATE@@;
    JCN _blkComplete@@COUNTER|1@@;
    L "dbCONST".BLK.@@CLASS@@.STATE.COMPLETED;
    T #mc.STATE;
    R #flags.sfcCompleted;
_blkComplete@@COUNTER@@   NOP 0;

@@ATTR_END|STATE@@

@@ATTR_BEGIN|SFC@@
NETWORK
TITLE = Clean up if SFC no longer running
    //------------------------------------------------------------------------//
    // SFC RESET   SFC RESET   SFC RESET   SFC RESET   SFC RESET   SFC RESET  //
    //                                                                        //
    // Clean up all flags if SFC is no longer running.                        //
    // Check if current SFC is aborted or completed successfully:             //
    //------------------------------------------------------------------------//
    A #subs.@@STATE@@;
    A(;
    O(;
    L #mcb.SUBSelected;
    L "dbCONST".BLK.@@CLASS@@.SAFE.CMD;
    ==I;
    );
    O(;
    L #mcs.SQ_STATE;
    L "dbCONST".SEQ.STATE.ABORTED;
    ==I;
    );
    O(;
    L #mcs.SQ_STATE;
    L "dbCONST".SEQ.STATE.COMPLETED;
    ==I;
    );
    );
    JCN sfcd@@COUNTER|1@@;

    //------------------------------------------------------------------------//
    // SFC is no longer running:                                              //
    //------------------------------------------------------------------------//
    L "dbCONST".SEQ.SAFE.CMD;
    T #mcs.SQ_STATE;

    L 0;
    T #mcs.CURSTEP;
    T #@@SFC@@.CURSTEP;
    T #@@SFC@@.SQ_STATE;

    R #mcs.SQ_ERROR;
    R #@@SFC@@.ERR_FAULT;
    R #@@SFC@@.PAUSED;

sfcd@@COUNTER@@:      NOP 0;

@@ATTR_END|SFC@@

@@ATTR_BEGIN|STATE@@
@@ATTR_BEGIN|CHILD_ACQUIRE@@
NETWORK
TITLE = Cascade Auto or OOS Mode to child @@CHILDALIAS@@
    //------------------------------------------------------------------------//
    // MODE CASCADE   MODE CASCADE   MODE CASCADE   MODE CASCADE   MODE CASC  //
    //                                                                        //
    // Switch child mode to Auto or OOS when parent mode transitions:         //
    //------------------------------------------------------------------------//
    O #mcb.eventModeAUTO;
    O #mcb.eventModeOOS;
    JCN _cascMode@@COUNTER|1@@_@@STATE@@;
    L #mc.MODE;
    T #cmc[@@CHILDINDEX@@].MODE;
_cascMode@@COUNTER|1@@_@@STATE@@   NOP 0;

@@ATTR_END|CHILD_ACQUIRE@@
@@ATTR_END|STATE@@

@@ATTR_BEGIN|HYGIENE@@
NETWORK
TITLE = HYGIENE STATE CALCULATION
    //------------------------------------------------------------------------//
    // HYGIENE   HYGIENE   HYGIENE   HYGIENE   HYGIENE   HYGIENE   HYGIENE    //
    //                                                                        //
    // Calculate the hygiene status of the block:                             //
    //------------------------------------------------------------------------//
    CALL "fcHygiene"
    (   hs                   := #hs
    );
@@ATTR_END|HYGIENE@@

@@ATTR_BEGIN|TIMER@@
NETWORK
TITLE = Hour Min & Sec to Time variable
    //------------------------------------------------------------------------//
    // TIMER   TIMER   TIMER   TIMER   TIMER   TIMER   TIMER   TIMER   TIMER  //
    //                                                                        //
    // Convert calling timer value to Time variable:                          //
    //------------------------------------------------------------------------//
    A #mcb.permitStart;
    CALL "fcHMS2Time"
    (
        H                           := #TIME_H ,
        M                           := #TIME_M ,
        S                           := #TIME_S ,
        TTIM_VAL                    := #tTime ,
        dTIM_VAL                    := #dTime
    );
    NOP 0;
@@ATTR_END|TIMER@@

@@TEMPLATE_END@@
END_FUNCTION_BLOCK
