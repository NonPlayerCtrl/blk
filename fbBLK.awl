@@TEMPLATE_BEGIN|createClass@@
//----------------------------------------------------------------------------//
//            Copyright 2018 Rieckermann Engineering Operations               //
//                Automatically Generated File - Do Not Edit                  //
//----------------------------------------------------------------------------//
// Title:       @@CLASS@@
// Description: @@CLASSDESCRIPTION@@
//                                                                            //
// Block functional pseudocode:                                               //
//                                                                            //
// If any Calling Parameter invalid                                           //
//     Set flagBadParameter                                                   //
//                                                                            //
// If any Child not in AUTO mode                                              //
//     Set flagChildNotAuto                                                   //
//                                                                            //
// If any Child in INTERLOCKED state                                          //
//     Set flagChildInterlocked                                               //
//                                                                            //
// If any Child not Owned or not Available                                    //
//     Set flagChildUnavailable                                               //
//                                                                            //
// If flagChildNotAuto OR flagChildInterlocked OR                             //
//                       flagChildUnavailable OR flagChildMismatch            //
//     Set flagChildFailed                                                    //
//                                                                            //
// If no Interlock condition and flagBadParameter ok and flagChildFailed ok   //
//     Set permitStart                                                        //
//                                                                            //
// Call Mode and Command Handling Block                                       //
//                                                                            //
//     Set block to Auto Mode if restarting the PLC                           //
//                                                                            //
//     If permitStart and commanded to Start or running substate changed      //
//         Set one scan pulse eventCommandStart                               //
//                                                                            //
//     If commanded to Stop                                                   //
//         Set one scan pulse eventCommandStop                                //
//                                                                            //
//     If block changed to Auto Mode                                          //
//         Set one scan pulse eventModeAuto                                   //
//                                                                            //
//     If block changed to Manual Mode                                        //
//         Set one scan pulse eventModeManual                                 //
//                                                                            //
//     If block changed to OOS Mode                                           //
//         Set one scan pulse eventModeOOS                                    //
//                                                                            //
//     If any Interlock condition                                             //
//         Set block INTERLOCK flag                                           //
//                                                                            //
//     If block STATE is STOPPED and any Interlock or not permitted to Start  //
//         Set block state INTERLOCKED                                        //
//                                                                            //
//     If block STATE is RUNNING and any Interlock or not permitted to Start  //
//         Set block state PAUSED                                             //
//                                                                            //
//     If block state is INTERLOCKED                                          //
//         Command the block to STOP                                          //
//         Set the selected substate to the safe (stopped) command            //
//                                                                            //
// If eventCommandStart (means all conditions to start are met)               //
//     Convert substates to flags                                             //
//     Convert calling parameter selections to flags                          //
//     If child block Available                                               //
//         Take Ownership and record for later Release                        //
//     Cascade block Batch Serial Number to all children                      //
//     Command child devices to current commands                              //
//                                                                            //
// If eventCommandStart or flagSFCRunning                                     //
//     Write and read SFC commands and status                                 //
//                                                                            //
// If eventCommandStart                                                       //
//     Make sure all non-active SFCs are stopped                              //
//     Synchronise initial child commands to SFC child commands               //
//     Initiate SFC                                                           //
//     Set flagSFCRunning                                                     //
//                                                                            //
// If flagSFCRunning                                                          //
//     If any SFC child command changed then write to child device command    //
//     If any child command changes, start check timer for child state        //
//                     transition grace period                                //
//                                                                            //
// If child state transition check timer elapsed                              //
//     If any child state does not match command                              //
//         Set flagChildMismatch                                              //
//                                                                            //
// If flagSFCRunning and any interlock condition or child failure             //
//     Pause the running SFC                                                  //
//                                                                            //
// If any interlock condition or child failure or SFC problem                 //
//     Set child devices to their safe state (e.g. Closed for a valve)        //
//                                                                            //
// Set any sequence error to acknowledged if so                               //
//                                                                            //
// If the SFC was paused and the error acknowledged and resume command given  //
//     Resume the running SFC                                                 //
//                                                                            //
// Set all SFCs to Auto Mode if the Block changed to Auto                     //
//                                                                            //
// Set flagSFCCompleted if current SFC is Finished                            //
//                                                                            //
// If eventComplete                                                           //
//     Set block state COMPLETED                                              //
//                                                                            //
// If eventComplete and CHILD_RELEASE                                         //
//     Release any child devices taken Ownership                              //
//----------------------------------------------------------------------------//
// Revision history:                                                          //
// Rev By               Date        CC        Note                            //
// 2.0 David Paspa      30-Jan-2018 NA        Reboot for S7-1500.             //
// 1.0 Gerald Kontriner 10-Oct-2009 CC-09/023 Added Alarm flag MON_MISMATCH.  //
// 0.9 Khairul Basar    04-Oct-2009 CC-09/023 SHARED_BY  changed to OWNER int.//
// 0.8 Khairul Basar    02-Oct-2009 CC-09/023 SQ_STATE, ERR flag reset if SQ  //
//                                            off.                            //
// 0.7 Khoon            01-Oct-2009 CC-09/016 Mode=2 init,'Substate change'   //
//                                            added to STOP input of Subs.    //
// 0.6 Khairul Basar    30-Sep-2009 CC-09/023 EM Mode var changed to IN_OUT.  //
// 0.5 Khairul Basar    25-Sep-2009 CC-09/016 Ref2.                           //
// 0.4 Khairul Basar    21-Sep-2009 CC-09/016 Ref1.                           //
// 0.3 Khairul Basar    17-Sep-2009 CC-09/016 Duplicate command/SP parameters //
//                                            deleted auto/manual both now    //
//                                            using same parameters.          //
// 0.2 Khairul Basar    27-Aug-2009 CC-09/023 Path_IL added, Phase updated.   //
// 0.1 Khairul Basar    03-Aug-2009           Initial design.                 //
// Ref2:                                                                      //
// SQ_ACK,SQ_RESUME,SQ_ERROR,CURSTEP,SQ_STATE variables are added as to       //
// control from HMI faceplate.                                                //
// Ref1:                                                                      //
// Phases are updated.Flush & Charge Syncronised for valve commands.SQ_stop   //
// command is passed when CALL flag is OFF(previously there was error).PULSE  //
// timer is created as multiple instance of a standard FB, no more hard coded //
// S5 timer. ERR_FLT is changed to TIMEOUT_VER, PATH_IL to FLOWPATH.Shared    //
// Equipment availability flag programmed,BatchCycle variable added.          //
//----------------------------------------------------------------------------//
FUNCTION_BLOCK "fb@@CLASS@@"
TITLE = @@CLASSDESCRIPTION@@
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : REO
NAME : fb@@CLASS@@
VERSION : 2.0

//----------------------------------------------------------------------------//
// Declare interface and variables:                                           //
//----------------------------------------------------------------------------//
VAR_IN_OUT
    p : "udt@@CLASS@@";            // Block data interface
END_VAR
VAR
    RUNTMR : "fbRunTimer";
@@ATTR_BEGIN|SFC@@
    @@SFC@@ : "fb@@SFC@@";       // @@STATEDESCRIPTION@@
@@ATTR_END|SFC@@
    timeCheckChildState {OriginalPartName := 'TON'; LibVersion := '1.0'} : TON;
    timeCheckChildStateExpired : Bool;
    timeCheckChildStateElapsed : Time;
    iErr : Int;                        // Block error flag
    flags : Struct
        badParameter: Bool;
        childCommandChange : Bool;
        childFailed : Bool;
        childInterlocked : Bool;
        childNotAuto : Bool;
        childMismatch : Bool;
        childUnavailable : Bool;
        sfcCompleted : Bool;
        sfcRunning : Bool;
    END_STRUCT;
    own : Struct
@@ATTR_BEGIN|CHILD@@
        @@CHILDPARAMETERALIAS@@ : Bool;       // @@CHILDPARAMETERALIAS@@
@@ATTR_END|CHILD@@
    END_STRUCT;
@@ATTR_BEGIN|SELECT@@
    selected_@@PARAMETER@@_@@SELECTION@@ : Struct
@@ATTR_BEGIN|SELVALUE@@
        @@SELECTIONVALUE@@ : Bool;
@@ATTR_END|SELVALUE@@
    END_STRUCT;
@@ATTR_END|SELECT@@
    subs : Struct
@@ATTR_BEGIN|STATE@@
        @@STATE@@ : Bool;       // @@STATEDESCRIPTION@@
@@ATTR_END|STATE@@
    END_STRUCT;
    subsHasSFC : Struct
@@ATTR_BEGIN|STATE@@
        @@STATE@@ : Bool := @@HASSFC@@;       // @@STATEDESCRIPTION@@
@@ATTR_END|STATE@@
    END_STRUCT;
END_VAR

VAR_TEMP
    sq_finished : Bool;
//    subsChanged : Bool;
//    stateRunning : Bool;
//    tmpTimeExpired : Bool;
@@ATTR_BEGIN|TIMER@@
    tTime : Time;
    dTime : DInt;
@@ATTR_END|TIMER@@
    returnValue : Int;
    dummy : Bool;
END_VAR

BEGIN
NETWORK
TITLE = Check if calling parameters are valid
    //------------------------------------------------------------------------//
    // CALLING PARAMETERS   CALLING PARAMETERS   CALLING PARAMETERS   CALLING //
    //                                                                        //
    // TODO: Check each calling parameter to make sure it is valid:           //
    //------------------------------------------------------------------------//
    A "alwaysLow";
    = #flags.badParameter;
    = #p.origin.bmc.BAD_PARAM;

@@ATTR_BEGIN|STATE@@
@@ATTR_BEGIN|CHILD_ACQUIRED@@
NETWORK
TITLE = Check if child @@CHILDPARAMETERALIAS@@ is not in AUTO mode
    //------------------------------------------------------------------------//
    // CHILD NOT AUTO   CHILD NOT AUTO   CHILD NOT AUTO   CHILD NOT AUTO   CH //
    //                                                                        //
    // Check the child device to see if it is not in Auto mode. Only need to  //
    // find the first one so bypass further checks if this child in Manual:   //
    //------------------------------------------------------------------------//
    A #p.origin.bmc.eventCmdStart;
    A #subs.@@STATE@@;
    AN #p.origin.cmc@@CHILDINDEX@@.modeAUTO;
    = #flags.childNotAuto;
    JC _completedChildAutoChecks;

@@ATTR_END|CHILD_ACQUIRED@@
@@ATTR_END|STATE@@

_completedChildAutoChecks:      NOP 0;

@@ATTR_BEGIN|STATE@@
@@ATTR_BEGIN|CHILD_ACQUIRED@@
NETWORK
TITLE = Check if child @@CHILDPARAMETERALIAS@@ is Interlocked
    //------------------------------------------------------------------------//
    // CHILD INTERLOCK   CHILD INTERLOCK   CHILD INTERLOCK   CHILD INTERLOCK  //
    //                                                                        //
    // Check the child device to see if it is in the INTERLOCK state. Only    //
    // need to find the first one so bypass further checks if this child is   //
    // interlocked:                                                           //
    //------------------------------------------------------------------------//
    A #p.origin.bmc.eventCmdStart;
    A #subs.@@STATE@@;
    A #p.origin.cmc@@CHILDINDEX@@.INTERLOCK;
    = #flags.childInterlocked;
    JC _completedChildInterlockChecks;

@@ATTR_END|CHILD_ACQUIRED@@
@@ATTR_END|STATE@@

_completedChildInterlockChecks:      NOP 0;

@@ATTR_BEGIN|STATE@@
@@ATTR_BEGIN|CHILD_ACQUIRED@@
NETWORK
TITLE = Check if Child @@CHILDPARAMETERALIAS@@ is not already Owned or not Available
    //------------------------------------------------------------------------//
    // CHILD UNAVAILABLE   CHILD UNAVAILABLE   CHILD UNAVAILABLE   CHILD UNAV //
    //                                                                        //
    // Check the child device to see if it is already owned by this parent    //
    // or else if it is Available. If Available it will be acquired if needed //
    // later to execute a command. Only need to find the first one so bypass  //
    // further checks if this child is unavailable:                           //
    //------------------------------------------------------------------------//
    A #p.origin.bmc.eventCmdStart;
    A #subs.@@STATE@@;
    AN #p.origin.cmco@@CHILDINDEX@@.isAvailable;
    AN(;
    L #p.origin.cmco@@CHILDINDEX@@.OWNER;
    L #p.origin.mc.ME;
    ==I;
    );
    = #flags.childUnavailable;
    JC _completedChildUnavailableChecks;

@@ATTR_END|CHILD_ACQUIRED@@
@@ATTR_END|STATE@@

_completedChildUnavailableChecks:      NOP 0;

NETWORK
TITLE = Check if any Child has Failed
    //------------------------------------------------------------------------//
    // CHILD FAILED   CHILD FAILED   CHILD FAILED   CHILD FAILED   CHILD FAIL //
    //                                                                        //
    // Check if any child cannot be controlled by this parent block in which  //
    // case this block will fail and so operation at this level should be     //
    // inhibited:                                                             //
    //------------------------------------------------------------------------//
    O #flags.childInterlocked;
    O #flags.childNotAuto;
    O #flags.childUnavailable;
    O #flags.childMismatch;
    = #flags.childFailed;
    = #p.origin.bmc.CHILD_FAIL;

NETWORK
TITLE = Call General Mode and Command handling block
    //------------------------------------------------------------------------//
    // COMMAND PROCESSOR   COMMAND PROCESSOR   COMMAND PROCESSOR   COMMAND    //
    //                                                                        //
    // Process the standard block functions for command, mode, interlock and  //
    // state:                                                                 //
    //------------------------------------------------------------------------//
    CALL "fcModeCmd"
    (   mcOrigin             := #p.origin.mc ,
        mcOwner              := #p.owner.mc
    );

NETWORK
TITLE = Set Start command permitted flag if all okay
    //------------------------------------------------------------------------//
    // PERMIT START   PERMIT START   PERMIT START   PERMIT START   PERMIT ST  //
    //                                                                        //
    // If no interlock and all calling parameters and child devices are okay  //
    // then a Start is permitted:                                             //
    //------------------------------------------------------------------------//
    AN #p.origin.mc.INTERLOCK;
    AN #flags.childFailed;
    AN #flags.badParameter;
    = #p.origin.bmc.permitStart;

NETWORK
TITLE = Call BLOCK Mode and Command handling block
    //------------------------------------------------------------------------//
    // Process the stackable block functions for mode and command change      //
    // events:                                                                //
    //------------------------------------------------------------------------//
    CALL "fcModeCmdBLK"
    (   mcOrigin             := #p.origin.mc ,
        mcOwner              := #p.owner.mc ,
        bmc                  := #p.origin.bmc
    );

NETWORK
TITLE = Flag SFC not running if a new running substate command issued
    //------------------------------------------------------------------------//
    // Flag SFC is not yet running if new start command:                      //
    //------------------------------------------------------------------------//
    A #p.origin.bmc.eventCmdStart;
    JCN _notStart;
    R flags.sfcRunning;
_notStart:    NOP 0;

//----------------------------------------------------------------------------//
// RUNNING SUBSTATE    RUNNING SUBSTATE    RUNNING SUBSTATE    RUNNING SUBSTA //
// RUNNING SUBSTATE    RUNNING SUBSTATE    RUNNING SUBSTATE    RUNNING SUBSTA //
// RUNNING SUBSTATE    RUNNING SUBSTATE    RUNNING SUBSTATE    RUNNING SUBSTA //
//                                                                            //
// Process block running substate command.                                    //
//----------------------------------------------------------------------------//
@@ATTR_BEGIN|STATE@@
NETWORK
TITLE = Running Substate flags
    //------------------------------------------------------------------------//
    // RUNNING SUBSTATE FLAG   RUNNING SUBSTATE FLAG   RUNNING SUBSTATE FLAG  //
    //                                                                        //
    // Convert running substate values into boolean flags for ease of use in  //
    // boolean logic if starting a new substate:                              //
    //------------------------------------------------------------------------//
    A #p.origin.bmc.eventCmdStart;
    A(;
    L #p.owner.mc.SUBS;
    L "dbCONST".BLK.@@CLASS@@.SUBS.@@STATE@@;
    ==I;
    );
    = #subs.@@STATE@@;

NETWORK
TITLE = Transfer the Running Substate to the Block mode and command
    A #subs.@@STATE@@;
    JCN _subs_@@STATE@@;
    L #p.owner.mc.SUBS;
    T #p.origin.bmc.SUBS;
_subs_@@STATE@@:   NOP 0;

@@ATTR_END|STATE@@

@@ATTR_BEGIN|SELECT@@
@@ATTR_BEGIN|SELVALUE@@
NETWORK
TITLE = Calling Parameter Selection flags
    //------------------------------------------------------------------------//
    // CALLING PARAMETER SELECTION FLAG   CALLING PARAMETER SELECTION FLAG    //
    //                                                                        //
    // Convert calling parameter selections into the boolean flags for ease   //
    // of use in boolean logic if starting a new substate:                    //
    //------------------------------------------------------------------------//
    A #p.origin.bmc.eventCmdStart;
    A(;
    L #p.owner.@@PARAMETER@@_@@SELECTION@@;
    L "dbCONST".SEL.@@SELECTION@@.@@SELECTIONVALUE@@;
    ==I;
    );
    = #selected_@@PARAMETER@@_@@SELECTION@@.@@SELECTIONVALUE@@;

@@ATTR_END|SELVALUE@@
@@ATTR_END|SELECT@@

@@ATTR_BEGIN|STATE@@
@@ATTR_BEGIN|CHILD_ACQUIRE_REQ@@
NETWORK
TITLE = Acquire child @@CHILDPARAMETERALIAS@@ for new command if required for the state
    //------------------------------------------------------------------------//
    // ACQUIRE CHILDREN   ACQUIRE CHILDREN   ACQUIRE CHILDREN   ACQUIRE CHILD //
    //                                                                        //
    // Aquire the available child devices.                                    //
    //                                                                        //
    // Flag to take ownership of the child now and release at the end if      //
    // the child is available as it would be a child unavailabile failure     //
    // already above if not available at this point:                          //
    //------------------------------------------------------------------------//
    A #p.origin.bmc.eventCmdStart;
    A #subs.@@STATE@@;
    @@CHILDACQUIRESTATEMENT@@
    A #p.origin.cmco@@CHILDINDEX@@.isAvailable;
    = #own.@@CHILDPARAMETERALIAS@@;

NETWORK
TITLE = Acquire child @@CHILDPARAMETERALIAS@@ for new command
    //------------------------------------------------------------------------//
    // If the child is available take ownership by this block by writing to   //
    // the child owner variable:                                              //
    //------------------------------------------------------------------------//
    A #own.@@CHILDPARAMETERALIAS@@;
    JCN _childAvail_@@COUNTERATTR|1@@_@@STATE@@;
    L #p.origin.mc.ME;
    T #p.origin.cmco@@CHILDINDEX@@.OWNER;

_childAvail_@@COUNTERATTR@@_@@STATE@@:   NOP 0;

@@ATTR_END|CHILD_ACQUIRE_REQ@@
@@ATTR_END|STATE@@

@@ATTR_BEGIN|STATE@@
@@ATTR_BEGIN|CHILD_ACQUIRED@@
NETWORK
TITLE = Cascade Batch Serial Number to all children
    //------------------------------------------------------------------------//
    // RECIPE AND BATCH ID    RECIPE AND BATCH ID    RECIPE AND BATCH ID      //
    //                                                                        //
    // Cascade this block's Batch Number and Recipe ID to all child devices:  //
    //------------------------------------------------------------------------//
    A #own.@@CHILDPARAMETERALIAS@@;
    A #p.origin.bmc.eventCmdStart;
    A #subs.@@STATE@@;
    JCN _childBatch_@@COUNTERATTR|1@@_@@STATE@@;
    L #p.owner.mc.SERIALNUM;
    T #p.origin.cmco@@CHILDINDEX@@.SERIALNUM;
    L #p.owner.mc.RECIPE;
    T #p.origin.cmco@@CHILDINDEX@@.RECIPE;

_childBatch_@@COUNTERATTR@@_@@STATE@@:   NOP 0;

@@ATTR_END|CHILD_ACQUIRED@@
@@ATTR_END|STATE@@

@@ATTR_BEGIN|STATE@@
@@ATTR_BEGIN|CHILD_ACQUIRED@@
@@ATTR_BEGIN|pChild@@
NETWORK
TITLE = Download calling parameter @@BLOCKPARAMETER@@ value to child device @@CHILDPARAMETERALIAS@@
    //------------------------------------------------------------------------//
    // CHILD PARAMETER   CHILD PARAMETER   CHILD PARAMETER   CHILD PARAMETER  //
    //                                                                        //
    // Set the initial input value for the child calling parameter:           //
    //------------------------------------------------------------------------//
    A #own.@@CHILDPARAMETERALIAS@@;
    A #p.origin.bmc.eventCmdStart;
    A #subs.@@STATE@@;
    JCN _childParmIN_@@COUNTERATTR|1@@_@@STATE@@;
    L #p.owner.@@CHILDPARAMETERATTRIBUTE@@;
    T #p.origin.cmco@@CHILDINDEX@@.@@CHILDPARAMETERATTRIBUTE@@;

_childParmIN_@@COUNTERATTR@@_@@STATE@@:   NOP 0;

@@ATTR_END|pChild@@
@@ATTR_END|CHILD_ACQUIRED@@
@@ATTR_END|STATE@@

@@ATTR_BEGIN|STATE@@
@@ATTR_BEGIN|CHILD_INIT_COMMAND_TRUE@@
NETWORK
TITLE = Command child device @@CHILDPARAMETERALIAS@@ for state @@STATE@@ to its initial TRUE condition command
    //------------------------------------------------------------------------//
    // CHILD INITIAL TRUE COMMAND   CHILD INITIAL TRUE COMMAND   CHILD INITIA //
    //                                                                        //
    // Set the initial command values for the child devices.                  //
    // Command the child device to its initial command if condition is true:  //
    //------------------------------------------------------------------------//
    A #p.origin.bmc.eventCmdStart;
    A #subs.@@STATE@@;
    A(;
    @@CONDITIONSTATEMENT@@
    );
    JCN _childInitTrue_@@COUNTERATTR|1@@_@@STATE@@;
    @@TRUESTATEMENT@@

_childInitTrue_@@COUNTERATTR@@_@@STATE@@:   NOP 0;

@@ATTR_END|CHILD_INIT_COMMAND_TRUE@@
@@ATTR_END|STATE@@

@@ATTR_BEGIN|STATE@@
@@ATTR_BEGIN|CHILD_INIT_COMMAND_FALSE@@
NETWORK
TITLE = Command child device @@CHILDPARAMETERALIAS@@ for state @@STATE@@ to its initial FALSE condition command
    //------------------------------------------------------------------------//
    // CHILD INITIAL FALSE COMMAND   CHILD INITIAL FALSE COMMAND   CHILD INIT //
    //                                                                        //
    // Set the initial command values for the child devices.                  //
    // Command the child device to its initial command:                       //
    //------------------------------------------------------------------------//
    A #p.origin.bmc.eventCmdStart;
    A #subs.@@STATE@@;
    AN(;
    @@CONDITIONSTATEMENT@@
    );
    JCN _childInitFalse_@@COUNTERATTR|1@@_@@STATE@@;
    @@FALSESTATEMENT@@

_childInitFalse_@@COUNTERATTR@@_@@STATE@@:   NOP 0;

@@ATTR_END|CHILD_INIT_COMMAND_FALSE@@
@@ATTR_END|STATE@@

@@ATTR_BEGIN|SFC@@
NETWORK
TITLE = Make sure all SFCs are stopped if stop command or new start command
    //------------------------------------------------------------------------//
    // SFC    SFC    SFC    SFC    SFC    SFC    SFC    SFC    SFC    SFC     //
    // SFC    SFC    SFC    SFC    SFC    SFC    SFC    SFC    SFC    SFC     //
    //                                                                        //
    // Stop the SFC if new stop or start command issued. Reset the SFC mode   //
    // and command variable to clear the object referece:                     //
    //------------------------------------------------------------------------//
    O #p.origin.bmc.eventCmdStop;
    O #p.origin.bmc.eventCmdStart;
    JCN _notRestartSFC_@@COUNTERATTR|1@@_@@STATE@@;
    A "alwaysHigh";
    = #@@SFC@@.RESET;

_notRestartSFC_@@COUNTERATTR@@_@@STATE@@:   NOP 0;

@@ATTR_END|SFC@@

@@ATTR_BEGIN|SFC@@
NETWORK
TITLE = Reset sequence mode and command structure
    //------------------------------------------------------------------------//
    // Reset the sequence mode and command structure:                         //
    //------------------------------------------------------------------------//
    A #p.origin.bmc.eventCmdStart;
    A #subs.@@STATE@@;
    JCN _notResetSFC_@@COUNTERATTR|1@@_@@STATE@@;
    A "alwaysLow";
    = #@@SFC@@.smc.ERR_FAULT;
    = #@@SFC@@.smc.MAN_JUMP;
    = #@@SFC@@.smc.NO_VERIFIC;
    = #@@SFC@@.smc.OFF_IDLE;
    = #@@SFC@@.smc.PAUSED;
    = #@@SFC@@.smc.RUNNING;
    = #@@SFC@@.smc.S_ACTIVE;
    = #@@SFC@@.smc.SQ_ACK;
    = #@@SFC@@.smc.SQ_ERROR;
    = #@@SFC@@.smc.SQ_FINISHED;
    = #@@SFC@@.smc.SQ_RESUME;
    = #@@SFC@@.smc.TRN_AND_JUMP;
    L 0;
    T #@@SFC@@.smc.CURSTEP;
    T #@@SFC@@.smc.MODE;
    T #@@SFC@@.smc.SQ_CMD;
    T #@@SFC@@.smc.SQ_STATE;
    T #@@SFC@@.smc.STEPNO_JUMP;
    T #@@SFC@@.smc.NXT_STEP;
_notResetSFC_@@COUNTERATTR|1@@_@@STATE@@: NOP 0;

@@ATTR_END|SFC@@

@@ATTR_BEGIN|SFC@@
@@ATTR_BEGIN|CHILD_INSTANCE_BIND@@
NETWORK
TITLE = Bind the selected child to the called child device
    //------------------------------------------------------------------------//
    // Copy the selected child to the called child device:                    //
    //------------------------------------------------------------------------//
    A #p.origin.bmc.eventCmdStart;
    A #subs.@@STATE@@;
    A(;
    @@CONDITIONSTATEMENT@@
    );
    JCN _childBind_@@COUNTERATTR|1@@_@@STATE@@;
    CALL MOVE
    {value_type := 'Variant'}
    (   IN                   := #p.origin.cmc@@CHILDINDEX@@ ,
        OUT                  := #p.origin.cmc@@CHILDBIND@@
    );
    CALL MOVE
    {value_type := 'Variant'}
    (   IN                   := #p.origin.cmco@@CHILDINDEX@@ ,
        OUT                  := #p.origin.cmco@@CHILDBIND@@
    );

_childBind_@@COUNTERATTR@@_@@STATE@@:   NOP 0;

@@ATTR_END|CHILD_INSTANCE_BIND@@
@@ATTR_END|SFC@@

@@ATTR_BEGIN|SFC@@
NETWORK
TITLE = If substate @@STATE@@ is running then set the SFC calling parameters
    //------------------------------------------------------------------------//
    // SFC PARAMETERS   SFC PARAMETERS   SFC PARAMETERS   SFC PARAMETERS   SF //
    //                                                                        //
    // Set the SFC calling parameters if this is the running substate:        //
    //------------------------------------------------------------------------//
    A #p.origin.bmc.eventCmdStart;
    A #subs.@@STATE@@;
    JCN _notSFC_@@COUNTERATTR|1@@_@@STATE@@;
    CALL #@@SFC@@
    (
@@ATTR_BEGIN|pSFC@@
        @@CHILDPARAMETER@@   := #p.owner.@@BLOCKPARAMETER@@ ,
@@ATTR_END|pSFC@@
@@ATTR_BEGIN|pSFCChildOrigin@@
        @@CHILDPARAMETER@@   := #p.origin.cmc@@CHILDINDEX@@.@@CHILDPARAMETERATTRIBUTE@@ ,
@@ATTR_END|pSFCChildOrigin@@
@@ATTR_BEGIN|pSFCChildOwner@@
        @@CHILDPARAMETER@@   := #p.origin.cmco@@CHILDINDEX@@.@@CHILDPARAMETERATTRIBUTE@@ ,
@@ATTR_END|pSFCChildOwner@@
        dummy                := #dummy
    );
_notSFC_@@COUNTERATTR@@_@@STATE@@:   NOP 0;

@@ATTR_END|SFC@@

@@ATTR_BEGIN|SFC@@
@@ATTR_BEGIN|CHILD_INSTANCE_BIND@@
NETWORK
TITLE = Return the bound child to the selected child device
    //------------------------------------------------------------------------//
    // Copy the selected child to the called child device:                    //
    //------------------------------------------------------------------------//
    A #subs.@@STATE@@;
    A(;
    @@CONDITIONSTATEMENT@@
    );
    JCN _childBound_@@COUNTERATTR|1@@_@@STATE@@;
    CALL MOVE
    {value_type := 'Variant'}
    (   IN                   := #p.origin.cmc@@CHILDBIND@@ ,
        OUT                  := #p.origin.cmc@@CHILDINDEX@@
    );
    CALL MOVE
    {value_type := 'Variant'}
    (   IN                   := #p.origin.cmco@@CHILDBIND@@ ,
        OUT                  := #p.origin.cmco@@CHILDINDEX@@
    );

_childBound_@@COUNTERATTR@@_@@STATE@@:   NOP 0;

@@ATTR_END|CHILD_INSTANCE_BIND@@
@@ATTR_END|SFC@@

@@ATTR_BEGIN|pEventPrompt@@
NETWORK
TITLE = Clear the operator prompt flag for event @@PARAMETERDESCRIPTION@@
    //------------------------------------------------------------------------//
    // CLEAR OPERATOR PROMPT   CLEAR OPERATOR PROMPT   CLEAR OPERATOR PROMPT  //
    //                                                                        //
    // Clear the SFC prompt and confirm bits and the global shared event bits //
    // for event @@PARAMETERDESCRIPTION@@
    //------------------------------------------------------------------------//
    A #p.origin.bmc.eventCmdStart;
    JCN _evPrompt_@@COUNTERATTR|1@@;
    R #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;
    R #p.origin.eventPrompt[@@IDXEVENT@@].trigger;
    R #p.origin.eventPrompt[@@IDXEVENT@@].confirmYes;
    R #p.origin.eventPrompt[@@IDXEVENT@@].confirmNo;
_evPrompt_@@COUNTERATTR@@:   NOP 0;

@@ATTR_END|pEventPrompt@@

@@ATTR_BEGIN|pEventConfirm@@
NETWORK
TITLE = Clear the operator confirm flag
    //------------------------------------------------------------------------//
    // CLEAR OPERATOR CONFIRM   CLEAR OPERATOR CONFIRM   CLEAR OPERATOR CONFI //
    //                                                                        //
    // Clear the SFC confirm bit and the global shared event DB bit:          //
    //------------------------------------------------------------------------//
    A #p.origin.bmc.eventCmdStart;
    JCN _evConfirm_@@COUNTERATTR|1@@;
    R #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;
_evConfirm_@@COUNTERATTR@@:   NOP 0;

@@ATTR_END|pEventConfirm@@

@@ATTR_BEGIN|pEventLogMsg@@
NETWORK
TITLE = Clear the log message flag
    //------------------------------------------------------------------------//
    // CLEAR LOG MESSAGE   CLEAR LOG MESSAGE   CLEAR LOG MESSAGE   CLEAR LOG  //
    //                                                                        //
    // Clear the SFC log message bit and the global shared event DB bit:      //
    //------------------------------------------------------------------------//
    A #p.origin.bmc.eventCmdStart;
    JCN _evLogMsg_@@COUNTERATTR|1@@;
    R #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;
    R #p.origin.eventLogMsg[@@IDXEVENT@@].trigger;
_evLogMsg_@@COUNTERATTR@@:   NOP 0;

@@ATTR_END|pEventLogMsg@@

@@ATTR_BEGIN|pEventLogReal@@
NETWORK
TITLE = Clear the log real data flag
    //------------------------------------------------------------------------//
    // CLEAR LOG REAL   CLEAR LOG REAL   CLEAR LOG REAL   CLEAR LOG REAL   CL //
    //                                                                        //
    // Clear the SFC log real bit and the global shared event DB bit and      //
    // zero the global data:                                                  //
    //------------------------------------------------------------------------//
    A #p.origin.bmc.eventCmdStart;
    JCN _evLogReal_@@COUNTERATTR|1@@;
    R #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;
    R #p.origin.eventLogReal[@@IDXEVENT@@].trigger;
    L 0;
    T #p.origin.eventLogReal[@@IDXEVENT@@].dataValue;
_evLogReal_@@COUNTERATTR@@:   NOP 0;

@@ATTR_END|pEventLogReal@@

@@ATTR_BEGIN|pEventLogTime@@
NETWORK
TITLE = Clear the log time data flag
    //------------------------------------------------------------------------//
    // CLEAR LOG TIME   CLEAR LOG TIME   CLEAR LOG TIME   CLEAR LOG TIME   CL //
    //                                                                        //
    // Clear the SFC log time bit and the global shared event DB bit and      //
    // zero the global data:                                                  //
    //------------------------------------------------------------------------//
    A #p.origin.bmc.eventCmdStart;
    JCN _evLogTime_@@COUNTERATTR|1@@;
    R #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;
    R #p.origin.eventLogTime[@@IDXEVENT@@].trigger;
    L 0;
    T #p.origin.eventLogTime[@@IDXEVENT@@].dataValue;
_evLogTime_@@COUNTERATTR@@:   NOP 0;

@@ATTR_END|pEventLogTime@@

@@ATTR_BEGIN|pEventDataReal@@
NETWORK
TITLE = Zero the real data value
    //------------------------------------------------------------------------//
    // ZERO DATA REAL   ZERO DATA REAL   ZERO DATA REAL   ZERO DATA REAL   ZE //
    //                                                                        //
    // Zero the SFC log real data parameter:                                  //
    //------------------------------------------------------------------------//
    A #p.origin.bmc.eventCmdStart;
    JCN _evDataReal_@@COUNTERATTR|1@@;
    L 0;
    T #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;
_evDataReal_@@COUNTERATTR@@:   NOP 0;

@@ATTR_END|pEventDataReal@@

@@ATTR_BEGIN|pEventDataTime@@
NETWORK
TITLE = Zero the log time data
    //------------------------------------------------------------------------//
    // ZERO DATA TIME   ZERO DATA TIME   ZERO DATA TIME   ZERO DATA TIME   ZE //
    //                                                                        //
    // Zero the SFC log time data and the global shared event DB data:        //
    //------------------------------------------------------------------------//
    A #p.origin.bmc.eventCmdStart;
    JCN _evDataTime_@@COUNTERATTR|1@@;
    L 0;
    T #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;
_evDataTime_@@COUNTERATTR@@:   NOP 0;

@@ATTR_END|pEventDataTime@@

@@ATTR_BEGIN|SFC@@
@@ATTR_BEGIN|pSFCChildIN@@
NETWORK
TITLE = Synchronise SFC @@SFC@@ child state for child @@CHILDPARAMETER@@
    //------------------------------------------------------------------------//
    // SYNC SFC CHILD STATE    SYNC SFC CHILD STATE    SYNC SFC CHILD STATE   //
    //                                                                        //
    // Update the SFC child states if the SFC is about to start or already    //
    // running:                                                               //
    //------------------------------------------------------------------------//
    A(;
    O #p.origin.bmc.eventCmdStart;
    O flags.sfcRunning;
    );
    A #subs.@@STATE@@;
    JCN _cState_@@COUNTERATTR|1@@_@@STATE@@;
    L #p.origin.cmc@@CHILDINDEX@@.@@CHILDPARAMETERATTRIBUTE@@;
    T #@@SFC@@.@@CHILDPARAMETER@@;

_cState_@@COUNTERATTR@@_@@STATE@@:   NOP 0;

@@ATTR_END|pSFCChildIN@@
@@ATTR_END|SFC@@

@@ATTR_BEGIN|SFC@@
@@ATTR_BEGIN|pSFCChildOUT@@
NETWORK
TITLE = Synchronise SFC @@SFC@@ child command for child @@CHILDPARAMETER@@
    //------------------------------------------------------------------------//
    // SYNC SFC CHILD COMMANDS    SYNC SFC CHILD COMMANDS    SYNC SFC CHILD   //
    //                                                                        //
    // Write the initial command to any SFC child commands to synchronise     //
    // them at the start of the SFC:                                          //
    //------------------------------------------------------------------------//
    A #p.origin.bmc.eventCmdStart;
    A #subs.@@STATE@@;
    JCN _cCmd_@@COUNTERATTR|1@@_@@STATE@@;
    L #p.origin.cmco@@CHILDINDEX@@.@@CHILDPARAMETERATTRIBUTE@@;
    T #@@SFC@@.@@CHILDPARAMETER@@;

_cCmd_@@COUNTERATTR@@_@@STATE@@:   NOP 0;

@@ATTR_END|pSFCChildOUT@@
@@ATTR_END|SFC@@

@@ATTR_BEGIN|SFC@@
NETWORK
TITLE = Start the SFC sequence @@SFC@@ for running substate @@STATE@@
    //------------------------------------------------------------------------//
    // START SFC   START SFC   START SFC   START SFC   START SFC   START SFC  //
    //                                                                        //
    // Start the running substate SFC.                                        //
    //                                                                        //
    // Bypass if not the current running substate:                            //
    //------------------------------------------------------------------------//
    A #p.origin.bmc.eventCmdStart;
    A #subs.@@STATE@@;
    JCN _notSFCStarting_2_@@STATE@@;

    //------------------------------------------------------------------------//
    // Start the SFC for the running substate:                                //
    //------------------------------------------------------------------------//
    L "dbCONST".SEQ.CMD.START;
    T #@@SFC@@.smc.SQ_CMD;
    S flags.sfcRunning;

_notSFCStarting_2_@@STATE@@:      NOP 0;
@@ATTR_END|SFC@@

@@ATTR_BEGIN|SFC@@
NETWORK
TITLE = Check if any new Child command if SFC @@SFC@@ is running
    //------------------------------------------------------------------------//
    // NEW CHILD COMMAND   NEW CHILD COMMAND   NEW CHILD COMMAND   NEW CHILD  //
    //                                                                        //
    // Check if the running SFC requests to change any child command. Check   //
    // this is the running SFC:                                               //
    //------------------------------------------------------------------------//
    A #subs.@@STATE@@;
    A flags.sfcRunning;
    AN #@@SFC@@.smc.PAUSED;
    AN #@@SFC@@.smc.ERR_FAULT;
    JCN _notSFCRunning_1_@@STATE@@;
    NOP 0;

@@ATTR_BEGIN|pSFCChildOUT@@
NETWORK
TITLE = Check if the SFC Child command has changed
    //------------------------------------------------------------------------//
    // Check if the running SFC requests to change this child command:        //
    //------------------------------------------------------------------------//
    A(;
    L #p.origin.cmco@@CHILDINDEX@@.@@CHILDPARAMETERATTRIBUTE@@;
    L #@@SFC@@.@@CHILDPARAMETER@@;
    <>I;
    );
    JCN _noCommandChange_@@COUNTERATTR|1@@_@@STATE@@;

NETWORK
TITLE = Send the updated SFC Child command to the child
    //------------------------------------------------------------------------//
    // Send the udpated SFC child command to the child:                       //
    //------------------------------------------------------------------------//
    L #@@SFC@@.@@CHILDPARAMETER@@;
    T #p.origin.cmco@@CHILDINDEX@@.@@CHILDPARAMETERATTRIBUTE@@;
    S #flags.childCommandChange;

_noCommandChange_@@COUNTERATTR@@_@@STATE@@:      NOP 0;

@@ATTR_END|pSFCChildOUT@@

_notSFCRunning_1_@@STATE@@:      NOP 0;

@@ATTR_END|SFC@@

NETWORK
TITLE = If child command changed, start timer to wait for child state
    //------------------------------------------------------------------------//
    // CHILD STATE TIMER   CHILD STATE TIMER   CHILD STATE TIMER   CHILD STAT //
    //                                                                        //
    // If any child command changed then start a timer to provide a grace     //
    // period to allow the child device state to match the command (e.g. to   //
    // allow a valve to move from closed to opened position).                 //
    // Start the child state check timer if a command changed:                //
    //------------------------------------------------------------------------//
    CALL #timeCheckChildState
    {time_type := 'Time'}
    (   IN                          := #flags.childCommandChange ,
        PT                          := T#10S ,
        Q                           := #timeCheckChildStateExpired ,
        ET                          := #timeCheckChildStateElapsed
    );
    NOP 0;

@@ATTR_BEGIN|STATE@@
@@ATTR_BEGIN|CHILD_ACQUIRED@@
NETWORK
TITLE = Check if any Child state does not match the command
    //------------------------------------------------------------------------//
    // CHILD STATE MISMATCH   CHILD STATE MISMATCH   CHILD STATE MISMATCH     //
    //                                                                        //
    // Check if any child device state does not match the command from this   //
    // parent block if the child state grace period timer has expired. Stop   //
    // checking if the first child state mismatch found:                      //
    //------------------------------------------------------------------------//
    A #timeCheckChildStateExpired;
    A(;
    L #p.origin.cmc@@CHILDINDEX@@.STATE;
    L #p.origin.cmco@@CHILDINDEX@@.CMD;
    <>I;
    );
    JCN _cNoMismatch_@@COUNTERATTR|1@@_@@STATE@@;
    S #flags.childMismatch;

_cNoMismatch_@@COUNTERATTR@@_@@STATE@@:   NOP 0;

@@ATTR_END|CHILD_ACQUIRED@@
@@ATTR_END|STATE@@

NETWORK
TITLE = Reset the new child command flag if a mismatch
    //------------------------------------------------------------------------//
    // Reset the child device command changed flag if a mismatch occurred:    //
    //------------------------------------------------------------------------//
    A #timeCheckChildStateExpired;
    JCN _ccstate;
    R #flags.childCommandChange;
_ccstate:   NOP 0;

@@ATTR_BEGIN|pEventPrompt@@
NETWORK
TITLE = Raise operator prompt if required for event @@PARAMETERDESCRIPTION@@
    //------------------------------------------------------------------------//
    // OPERATOR PROMPT   OPERATOR PROMPT   OPERATOR PROMPT   OPERATOR PROMPT  //
    //                                                                        //
    // Transfer the SFC prompt bit to the global event datablock for event    //
    // @@PARAMETERDESCRIPTION@@
    //------------------------------------------------------------------------//
    A #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;
    = #p.origin.eventPrompt[@@IDXEVENT@@].trigger;

@@ATTR_END|pEventPrompt@@

@@ATTR_BEGIN|pEventPrompt@@
NETWORK
TITLE = Return operator confirm bits if made for event @@PARAMETERDESCRIPTION@@
    //------------------------------------------------------------------------//
    // OPERATOR CONFIRM   OPERATOR CONFIRM   OPERATOR CONFIRM   OPERATOR CONF //
    //                                                                        //
    // Receive the SFC confirm bits from the global event datablock for event //
    // @@PARAMETERDESCRIPTION@@
    //------------------------------------------------------------------------//
    A #p.origin.eventPrompt[@@IDXEVENT@@].confirmYes;
    = #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@_confirm_yes;
@@ATTR_BEGIN|pEventConfirmNoExists@@
    A #p.origin.eventPrompt[@@IDXEVENT@@].confirmNo;
    = #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@_confirm_no;
@@ATTR_END|pEventConfirmNoExists@@

@@ATTR_END|pEventPrompt@@

@@ATTR_BEGIN|pEventLogMsg@@
NETWORK
TITLE = Log message if required
    //------------------------------------------------------------------------//
    // LOG MSG   LOG MSG   LOG MSG   LOG MSG   LOG MSG   LOG MSG   LOG MSG    //
    //                                                                        //
    // Transfer the SFC log data to the global event datablock:               //
    //------------------------------------------------------------------------//
    A #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;
    = #p.origin.eventLogMsg[@@IDXEVENT@@].trigger;

@@ATTR_END|pEventLogMsg@@

@@ATTR_BEGIN|pEventDataReal@@
NETWORK
TITLE = Real data
    //------------------------------------------------------------------------//
    // REAL DATA   REAL DATA   REAL DATA   REAL DATA   REAL DATA   REAL DATA  //
    //                                                                        //
    // Transfer the SFC log data to the global event datablock:               //
    //------------------------------------------------------------------------//
    L #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;
    T #p.origin.eventLogReal[@@IDXEVENT@@].dataValue;

@@ATTR_END|pEventDataReal@@

@@ATTR_BEGIN|pEventLogReal@@
NETWORK
TITLE = Log real data if required
    //------------------------------------------------------------------------//
    // LOG REAL   LOG REAL   LOG REAL   LOG REAL   LOG REAL   LOG REAL   LOG  //
    //                                                                        //
    // Transfer the SFC log data to the global event datablock:               //
    //------------------------------------------------------------------------//
    A #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;
    = #p.origin.eventLogReal[@@IDXEVENT@@].trigger;

@@ATTR_END|pEventLogReal@@

@@ATTR_BEGIN|pEventDataTime@@
NETWORK
TITLE = Time data
    //------------------------------------------------------------------------//
    // TIME DATA   TIME DATA   TIME DATA   TIME DATA   TIME DATA   TIME DATA  //
    //                                                                        //
    // Transfer the SFC log data to the global event datablock:               //
    //------------------------------------------------------------------------//
    L #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;
    T #p.origin.eventLogTime[@@IDXEVENT@@].dataValue;

@@ATTR_END|pEventDataTime@@

@@ATTR_BEGIN|pEventLogTime@@
NETWORK
TITLE = Log time data if required
    //------------------------------------------------------------------------//
    // LOG TIME   LOG TIME   LOG TIME   LOG TIME   LOG TIME   LOG TIME   LOG  //
    //                                                                        //
    // Transfer the SFC log data to the global event datablock:               //
    //------------------------------------------------------------------------//
    A #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;
    = #p.origin.eventLogTime[@@IDXEVENT@@].trigger;

@@ATTR_END|pEventLogTime@@

@@ATTR_BEGIN|SFC@@
NETWORK
TITLE = Any Interlock must pause the running SFC
    //------------------------------------------------------------------------//
    // Pause the running SFC sequence if any interlock or failure condition:  //
    //------------------------------------------------------------------------//
    AN #p.origin.bmc.permitStart;
    A flags.sfcRunning;
    A #subs.@@STATE@@;
    JCN _ilSFC_@@COUNTERATTR|1@@;
    L "dbCONST".SEQ.CMD.PAUSE;
    T #@@SFC@@.smc.SQ_CMD;
_ilSFC_@@COUNTERATTR@@:   NOP 0;

@@ATTR_END|SFC@@

NETWORK
TITLE = Stop the module if any problem
    //------------------------------------------------------------------------//
    // STOP ON INTERLOCK   STOP ON INTERLOCK   STOP ON INTERLOCK   STOP ON IN //
    //                                                                        //
    // Stop the block if any interlock condition or not permitted to strat:   //
    //------------------------------------------------------------------------//
    O #p.origin.mc.INTERLOCK;
    ON #p.origin.bmc.permitStart;
    JCN _stopBlock;
    L "dbCONST".BLK.CMD.STOP;
    T #p.owner.mc.CMD;
_stopBlock:   NOP 0;

@@ATTR_BEGIN|STATE@@
@@ATTR_BEGIN|CHILD_ACQUIRED@@
NETWORK
TITLE = Set child device @@CHILDPARAMETERALIAS@@ to safe state if any interlock or child failure
    //------------------------------------------------------------------------//
    // SAFE STATE   SAFE STATE   SAFE STATE   SAFE STATE  SAFE STATE  SAFE ST //
    //                                                                        //
    // Set the child device to the safe state on any interlock condition or   //
    // child failure:                                                         //
    //------------------------------------------------------------------------//
    O #p.origin.mc.INTERLOCK;
    ON #p.origin.bmc.permitStart;
    JCN _childSafe_@@COUNTERATTR|1@@_@@STATE@@;
    L "dbCONST".BLK.@@CHILDCLASS@@.SAFE.CMD;
    T #p.origin.cmco@@CHILDINDEX@@.CMD;

_childSafe_@@COUNTERATTR@@_@@STATE@@:   NOP 0;

@@ATTR_END|CHILD_ACQUIRED@@
@@ATTR_END|STATE@@

@@ATTR_BEGIN|SFC@@
NETWORK
TITLE = Set child devices to safe state if SFC @@SFC@@ Paused or Error
    //------------------------------------------------------------------------//
    // SAFE STATE ON SFC ERROR   SAFE STATE ON SFC ERROR   SAFE STATE ON SFC  //
    //                                                                        //
    // Bypass if the current SFC is running okay:                             //
    //------------------------------------------------------------------------//
    A #p.origin.bmc.permitStart;
    A #subs.@@STATE@@;
    A #flags.sfcRunning;
    A(;
    O #@@SFC@@.smc.PAUSED;
    O #@@SFC@@.smc.ERR_FAULT;
    );
@@COUNTERTEMPLATEINCR@@
    JCN _safeSFC_@@COUNTERTEMPLATE@@_@@SFC@@;

    //------------------------------------------------------------------------//
    // Set all child devices to safe state due to sequence problem:           //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|CHILD_ACQUIRED@@
    L "dbCONST".BLK.@@CHILDCLASS@@.SAFE.CMD;
    T #p.origin.cmco@@CHILDINDEX@@.CMD;
@@ATTR_END|CHILD_ACQUIRED@@

_safeSFC_@@COUNTERTEMPLATE@@_@@SFC@@:   NOP 0;


@@ATTR_END|SFC@@

@@ATTR_BEGIN|SFC@@
NETWORK
TITLE = Acknowlede Sequence Error Fault
    //------------------------------------------------------------------------//
    // SFC ERROR ACKNOWLDGE   SFC ERROR ACKNOWLDGE   SFC ERROR ACKNOWLDGE     //
    //                                                                        //
    // If the sequence error has been acknowledged, set the SFC command to    //
    // error acknowledged:                                                    //
    //------------------------------------------------------------------------//
    A #@@SFC@@.smc.SQ_ACK;
    A #@@SFC@@.smc.SQ_ERROR;
    A #subs.@@STATE@@;
    JCN _ackSFC_@@COUNTERATTR|1@@;
    L "dbCONST".SEQ.CMD.ACKNOWLEDGE_ERR;
    T #@@SFC@@.smc.SQ_CMD;
_ackSFC_@@COUNTERATTR@@:   NOP 0;

@@ATTR_END|SFC@@

@@ATTR_BEGIN|SFC@@
NETWORK
TITLE = SQ Acknowlede Error Fault and Resume
    //------------------------------------------------------------------------//
    // Reset the sequence error acknowledge flag:                             //
    //------------------------------------------------------------------------//
    A #@@SFC@@.smc.SQ_ACK;
    A #@@SFC@@.smc.SQ_ERROR;
    A #subs.@@STATE@@;
    JCN _rAckSFC_@@COUNTERATTR|1@@;
    R #@@SFC@@.smc.SQ_ACK;
_rAckSFC_@@COUNTERATTR@@:   NOP 0;

@@ATTR_END|SFC@@

@@ATTR_BEGIN|SFC@@
NETWORK
TITLE = SQ Acknowlede Error Fault and Resume
    //------------------------------------------------------------------------//
    // SFC RESUME   SFC RESUME   SFC RESUME   SFC RESUME   SFC RESUME   SFC R //
    //                                                                        //
    // Check if the sequence was paused or an error was acknowledged and the  //
    // SFC is to be resumed:                                                  //
    //------------------------------------------------------------------------//
    A #@@SFC@@.smc.SQ_RESUME;
    A #subs.@@STATE@@;
    A(;
    O(;
    L #@@SFC@@.smc.SQ_STATE;
    L "dbCONST".SEQ.CMD.PAUSE;
    ==I;
    );
    O(;
    L #@@SFC@@.smc.SQ_STATE;
    L "dbCONST".SEQ.CMD.ACKNOWLEDGE_ERR;
    ==I;
    );
    );
    JCN _res1SFC@@COUNTERATTR|1@@;
    L "dbCONST".SEQ.CMD.RESUME;
    T #@@SFC@@.smc.SQ_CMD;
    R #@@SFC@@.smc.SQ_RESUME;
_res1SFC@@COUNTERATTR@@:   NOP 0;

@@ATTR_END|SFC@@

@@ATTR_BEGIN|SFC@@
NETWORK
TITLE = All SQ are in Auto mode when EM in Auto
    //------------------------------------------------------------------------//
    // SFC AUTO   SFC AUTO   SFC AUTO   SFC AUTO   SFC AUTO   SFC AUTO   SFC  //
    //                                                                        //
    // Set all SFCs to AUTO mode if the block is in AUTO:                     //
    //------------------------------------------------------------------------//
    A #p.origin.bmc.eventModeAUTO;
    JCN _nomc@@COUNTERATTR|1@@;
    L #p.owner.mc.MODE;
    T #@@SFC@@.smc.MODE;
_nomc@@COUNTERATTR@@:   NOP 0;

@@ATTR_END|SFC@@

@@ATTR_BEGIN|SFC@@
NETWORK
TITLE = Flag SFC finished if completed execution
    //------------------------------------------------------------------------//
    // SFC COMPLETE   SFC COMPLETE   SFC COMPLETE   SFC COMPLETE   SFC COMPL  //
    //                                                                        //
    // Flag SFC completed if the sequence has finished executing:             //
    //------------------------------------------------------------------------//
    A #subs.@@STATE@@;
    A #@@SFC@@.smc.SQ_FINISHED;
    JCN _notFin@@COUNTERATTR|1@@;
    S #flags.sfcCompleted;
_notFin@@COUNTERATTR@@:   NOP 0;

@@ATTR_END|SFC@@

@@ATTR_BEGIN|STATE@@
@@ATTR_BEGIN|CHILD_ACQUIRED@@
NETWORK
TITLE = Release child @@CHILDPARAMETERALIAS@@ if acquired and command completed
    //------------------------------------------------------------------------//
    // COMPLETE    COMPLETE    COMPLETE    COMPLETE    COMPLETE    COMPLETE   //
    // COMPLETE    COMPLETE    COMPLETE    COMPLETE    COMPLETE    COMPLETE   //
    // COMPLETE    COMPLETE    COMPLETE    COMPLETE    COMPLETE    COMPLETE   //
    //                                                                        //
    // RELEASE CHILD   RELEASE CHILD   RELEASE CHILD   RELEASE CHILD   RELE   //
    //                                                                        //
    // Release the child device if acquired earlier to run the command:       //
    //------------------------------------------------------------------------//
    A #flags.sfcCompleted;
    A #own.@@CHILDPARAMETERALIAS@@;
    A #p.owner.CHILD_RELEASE;
    JCN _notOwn@@COUNTERATTR|1@@_@@STATE@@;
    L "dbCONST".BLK.ID.AVAILABLE;
    T #p.origin.cmco@@CHILDINDEX@@.OWNER;
    R #own.@@CHILDPARAMETERALIAS@@;
_notOwn@@COUNTERATTR@@_@@STATE@@:   NOP 0;

@@ATTR_END|CHILD_ACQUIRED@@
@@ATTR_END|STATE@@

@@ATTR_BEGIN|STATE@@
NETWORK
TITLE = Set block running substate completed if finished
    //------------------------------------------------------------------------//
    // BLOCK COMPLETE   BLOCK COMPLETE   BLOCK COMPLETE   BLOCK COMPLETE   BL //
    //                                                                        //
    // Set the block state to COMPLETED if no SFC or SFC completed:           //
    //------------------------------------------------------------------------//
    O(;
    A subsHasSFC.@@STATE@@;
    A #flags.sfcCompleted;
    );
    ON subsHasSFC.@@STATE@@;
    JCN _blkComplete@@COUNTERATTR|1@@;
    L "dbCONST".BLK.@@CLASS@@.STATE.COMPLETED;
    T #p.origin.mc.STATE;
    R #flags.sfcCompleted;
_blkComplete@@COUNTERATTR@@:   NOP 0;

@@ATTR_END|STATE@@

@@ATTR_BEGIN|SFC@@
NETWORK
TITLE = Clean up if SFC no longer running
    //------------------------------------------------------------------------//
    // SFC RESET   SFC RESET   SFC RESET   SFC RESET   SFC RESET   SFC RESET  //
    //                                                                        //
    // Clean up all flags if SFC is no longer running.                        //
    // Check if current SFC is aborted or completed successfully:             //
    //------------------------------------------------------------------------//
    A #subs.@@STATE@@;
    A(;
    O(;
    L #p.owner.mc.SUBS;
    L "dbCONST".BLK.@@CLASS@@.SAFE.CMD;
    ==I;
    );
    O(;
    L #@@SFC@@.smc.SQ_STATE;
    L "dbCONST".SEQ.STATE.ABORTED;
    ==I;
    );
    O(;
    L #@@SFC@@.smc.SQ_STATE;
    L "dbCONST".SEQ.STATE.COMPLETED;
    ==I;
    );
    );
    JCN sfcd@@COUNTERATTR|1@@;

    //------------------------------------------------------------------------//
    // SFC is no longer running:                                              //
    //------------------------------------------------------------------------//
    L "dbCONST".SEQ.SAFE.CMD;
    T #@@SFC@@.smc.SQ_STATE;

    L 0;
    T #@@SFC@@.smc.CURSTEP;
    T #@@SFC@@.smc.CURSTEP;
    T #@@SFC@@.smc.SQ_STATE;

    R #@@SFC@@.smc.SQ_ERROR;
    R #@@SFC@@.smc.ERR_FAULT;
    R #@@SFC@@.smc.PAUSED;

sfcd@@COUNTERATTR@@:      NOP 0;

@@ATTR_END|SFC@@

@@ATTR_BEGIN|STATE@@
@@ATTR_BEGIN|CHILD_ACQUIRED@@
NETWORK
TITLE = Cascade Auto or OOS Mode to child @@CHILDPARAMETERALIAS@@
    //------------------------------------------------------------------------//
    // MODE CASCADE   MODE CASCADE   MODE CASCADE   MODE CASCADE   MODE CASC  //
    //                                                                        //
    // Switch child mode to Auto or OOS when parent mode transitions:         //
    //------------------------------------------------------------------------//
    O #p.origin.bmc.eventModeAUTO;
    O #p.origin.bmc.eventModeOOS;
    JCN _cascMode@@COUNTERATTR|1@@_@@STATE@@;
    L #p.owner.mc.MODE;
    T #p.origin.cmco@@CHILDINDEX@@.MODE;
_cascMode@@COUNTERATTR|1@@_@@STATE@@:   NOP 0;

@@ATTR_END|CHILD_ACQUIRED@@
@@ATTR_END|STATE@@

@@ATTR_BEGIN|HYGIENE@@
NETWORK
TITLE = HYGIENE STATE CALCULATION
    //------------------------------------------------------------------------//
    // HYGIENE   HYGIENE   HYGIENE   HYGIENE   HYGIENE   HYGIENE   HYGIENE    //
    //                                                                        //
    // Calculate the hygiene status of the block:                             //
    //------------------------------------------------------------------------//
    CALL "fcHygiene"
    (   hs                   := #p.origin.hs
    );
@@ATTR_END|HYGIENE@@

@@ATTR_BEGIN|TIMER@@
NETWORK
TITLE = Hour Min & Sec to Time variable
    //------------------------------------------------------------------------//
    // TIMER   TIMER   TIMER   TIMER   TIMER   TIMER   TIMER   TIMER   TIMER  //
    //                                                                        //
    // Convert calling timer value to Time variable:                          //
    //------------------------------------------------------------------------//
    A #p.origin.bmc.permitStart;
    CALL "fcHMS2Time"
    (
        H                           := #p.owner.TIME_H ,
        M                           := #p.owner.TIME_M ,
        S                           := #p.owner.TIME_S ,
        TTIM_VAL                    := #tTime ,
        dTIM_VAL                    := #dTime
    );
    NOP 0;
@@ATTR_END|TIMER@@

@@TEMPLATE_END@@
END_FUNCTION_BLOCK
