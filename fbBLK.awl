@@TEMPLATE_BEGIN|createClass@@
//----------------------------------------------------------------------------//
//            Copyright 2018 Rieckermann Engineering Operations               //
//                Automatically Generated File - Do Not Edit                  //
//----------------------------------------------------------------------------//
// Title:       @@CLASS@@
// Description: @@CLASSDESCRIPTION@@
//                                                                            //
// This is the main function block for all higher level S88 blocks, including //
// EMs, Units and Process Cells. The block is generic and any heirarchical    //
// structure can be supported.                                                //
//----------------------------------------------------------------------------//
// Revision history:                                                          //
// Rev By               Date        CC        Note                            //
// 2.0 David Paspa      30-Jan-2018 NA        Reboot for S7-1500.             //
// 1.0 Gerald Kontriner 10-Oct-2009 CC-09/023 Added Alarm flag MON_MISMATCH.  //
// 0.9 Khairul Basar    04-Oct-2009 CC-09/023 SHARED_BY  changed to OWNER int.//
// 0.8 Khairul Basar    02-Oct-2009 CC-09/023 SQ_STATE, ERR flag reset if SQ  //
//                                            off.                            //
// 0.7 Khoon            01-Oct-2009 CC-09/016 Mode=2 init,'Substate change'   //
//                                            added to STOP input of Subs.    //
// 0.6 Khairul Basar    30-Sep-2009 CC-09/023 EM Mode var changed to IN_OUT.  //
// 0.5 Khairul Basar    25-Sep-2009 CC-09/016 Ref2.                           //
// 0.4 Khairul Basar    21-Sep-2009 CC-09/016 Ref1.                           //
// 0.3 Khairul Basar    17-Sep-2009 CC-09/016 Duplicate command/SP parameters //
//                                            deleted auto/manual both now    //
//                                            using same parameters.          //
// 0.2 Khairul Basar    27-Aug-2009 CC-09/023 Path_IL added, Phase updated.   //
// 0.1 Khairul Basar    03-Aug-2009           Initial design.                 //
// Ref2:                                                                      //
// SQ_ACK,SQ_RESUME,SQ_ERROR,CURSTEP,SQ_STATE variables are added as to       //
// control from HMI faceplate.                                                //
// Ref1:                                                                      //
// Phases are updated.Flush & Charge Syncronised for valve commands.SQ_stop   //
// command is passed when CALL flag is OFF(previously there was error).PULSE  //
// timer is created as multiple instance of a standard FB, no more hard coded //
// S5 timer. ERR_FLT is changed to TIMEOUT_VER, PATH_IL to FLOWPATH.Shared    //
// Equipment availability flag programmed,BatchCycle variable added.          //
//----------------------------------------------------------------------------//
FUNCTION_BLOCK "fb@@CLASS@@"
TITLE = @@CLASSDESCRIPTION@@
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : REO
NAME : fb@@CLASS@@
VERSION : 2.0

//----------------------------------------------------------------------------//
// Declare interface and variables:                                           //
//----------------------------------------------------------------------------//
VAR
    p : "udt@@CLASS@@";            // Block data interface
    RUNTMR : "fbRunTimer";
@@ATTR_BEGIN|SFC@@
    @@SFC@@ : "fb@@SFC@@";       // @@STATEDESCRIPTION@@
@@ATTR_END|SFC@@
    timeCheckChildState {ReadalPartName := 'IEC_TIMER'; LibVersion := '1.0'} : TON;
    timeCheckChildStateElapsed : Time;
    timeCheckChildStateExpired : Bool;
    cmdSTOPPED : Bool;
    stateBeforeError : Int;
@@ATTR_BEGIN|CHILD_COMMAND_EXISTS@@
    childReqCMD : Struct
@@ATTR_BEGIN|CHILD_COMMAND@@
    	@@CHILDPARAMETERALIAS@@ : Int;
@@ATTR_END|CHILD_COMMAND@@
    END_STRUCT;
@@ATTR_END|CHILD_COMMAND_EXISTS@@
    acquire : Struct
@@ATTR_BEGIN|CHILD@@
        @@CHILDPARAMETERALIAS@@ : Bool;       // @@CHILDPARAMETERALIAS@@
@@ATTR_END|CHILD@@
    END_STRUCT;
    alreadyOwned : Struct
@@ATTR_BEGIN|CHILD@@
        @@CHILDPARAMETERALIAS@@ : Bool;       // @@CHILDPARAMETERALIAS@@
@@ATTR_END|CHILD@@
    END_STRUCT;
@@ATTR_BEGIN|SELECT@@
    selected_@@PARAMETER@@_@@SELECTION@@ : Struct
@@ATTR_BEGIN|SELVALUE@@
        @@SELECTIONVALUE@@ : Bool;
@@ATTR_END|SELVALUE@@
    END_STRUCT;
@@ATTR_END|SELECT@@
    subsHasSFC : Struct
@@ATTR_BEGIN|STATE@@
        @@STATE@@ : Bool := @@HASSFC@@;       // @@STATEDESCRIPTION@@
@@ATTR_END|STATE@@
    END_STRUCT;
    subsRunning : Struct
@@ATTR_BEGIN|STATE@@
        @@STATE@@ : Bool;       // @@STATEDESCRIPTION@@
@@ATTR_END|STATE@@
    END_STRUCT;
    subsStart : Struct
@@ATTR_BEGIN|STATE@@
        @@STATE@@ : Bool;       // @@STATEDESCRIPTION@@
@@ATTR_END|STATE@@
    END_STRUCT;
END_VAR

VAR DB_SPECIFIC
    w { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;
    b { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} AT w : Array[0..15] of Bool;

@@ATTR_BEGIN|pEventConfirmNoExists@@
@@ATTR_BEGIN|pEventConfirmNoNumWords@@
    wEventConfirmNo { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..@@CWORDMAX@@] of Word;
@@ATTR_END|pEventConfirmNoNumWords@@
@@ATTR_BEGIN|pEventConfirmNoNum@@
    bEventConfirmNo { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} AT wEventConfirmNo : Array[0..@@IDXEVENTMAX@@] of Bool;
@@ATTR_END|pEventConfirmNoNum@@
@@ATTR_END|pEventConfirmNoExists@@

@@ATTR_BEGIN|pEventConfirmYesExists@@
@@ATTR_BEGIN|pEventConfirmYesNumWords@@
    wEventConfirmYes { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..@@CWORDMAX@@] of Word;
@@ATTR_END|pEventConfirmYesNumWords@@
@@ATTR_BEGIN|pEventConfirmYesNum@@
    bEventConfirmYes { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} AT wEventConfirmYes : Array[0..@@IDXEVENTMAX@@] of Bool;
@@ATTR_END|pEventConfirmYesNum@@
@@ATTR_END|pEventConfirmYesExists@@

@@ATTR_BEGIN|pEventLogMsgExists@@
@@ATTR_BEGIN|pEventLogMsgNumWords@@
    wEventLogMsg { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..@@CWORDMAX@@] of Word;
@@ATTR_END|pEventLogMsgNumWords@@
@@ATTR_BEGIN|pEventLogMsgNum@@
    bEventLogMsg { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} AT wEventLogMsg : Array[0..@@IDXEVENTMAX@@] of Bool;
@@ATTR_END|pEventLogMsgNum@@
@@ATTR_END|pEventLogMsgExists@@

@@ATTR_BEGIN|pEventLogRealExists@@
@@ATTR_BEGIN|pEventLogRealNumWords@@
    wEventLogReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..@@CWORDMAX@@] of Word;
@@ATTR_END|pEventLogRealNumWords@@
@@ATTR_BEGIN|pEventLogRealNum@@
    bEventLogReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} AT wEventLogReal : Array[0..@@IDXEVENTMAX@@] of Bool;
@@ATTR_END|pEventLogRealNum@@
@@ATTR_END|pEventLogRealExists@@

@@ATTR_BEGIN|pEventLogTimeExists@@
@@ATTR_BEGIN|pEventLogTimeNumWords@@
    wEventLogTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..@@CWORDMAX@@] of Word;
@@ATTR_END|pEventLogTimeNumWords@@
@@ATTR_BEGIN|pEventLogTimeNum@@
    bEventLogTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} AT wEventLogTime : Array[0..@@IDXEVENTMAX@@] of Bool;
@@ATTR_END|pEventLogTimeNum@@
@@ATTR_END|pEventLogTimeExists@@
END_VAR

VAR_TEMP
    sq_finished : Bool;
@@ATTR_BEGIN|TIMER@@
    tTime : Time;
    dTime : DInt;
@@ATTR_END|TIMER@@
    returnValue : Int;
    dummy : Bool;
END_VAR

BEGIN
NETWORK
TITLE = Shutdown if STOPPED command no matter what
    //------------------------------------------------------------------------//
    // Check for STOPPED comamnd:                                             //
    //------------------------------------------------------------------------//
    A(;
    L #p.write.mc.CMD;
    L "dbCONST".BLK.CMD.STOP;
    ==I;
    );
    = #cmdSTOPPED;

@@ATTR_BEGIN|CHILD_ACQUIRE_EXISTS@@
NETWORK
TITLE = Check if any shared Child is not Available or not owned
    //------------------------------------------------------------------------//
    // CHILD UNAVAILABLE   CHILD UNAVAILABLE   CHILD UNAVAILABLE   CHILD UNAV //
    //                                                                        //
    // Check any shared child devices are Available. If Available they will   //
    // be acquired by the batch if needed later to execute a command:         //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|CHILD_ACQUIRE@@
    O(;
    @@CHILDACQUIRESTATEMENT@@
    AN "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.read.mc.isAvailable;
    AN(;
    L #p.read.mc.ME;
    L "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.write.mc.OWNER;
    ==I;
    );
    );
@@ATTR_END|CHILD_ACQUIRE@@
    = #p.read.bmc.flags.childUnavailable;
@@ATTR_END|CHILD_ACQUIRE_EXISTS@@

NETWORK
TITLE = Call General Mode and Command handling block
    //------------------------------------------------------------------------//
    // COMMAND PROCESSOR   COMMAND PROCESSOR   COMMAND PROCESSOR   COMMAND    //
    //                                                                        //
    // Process the standard block functions for command, mode, interlock and  //
    // state:                                                                 //
    //------------------------------------------------------------------------//
    CALL "fcModeCmd"
    (   cmdSafe              := "dbCONST".BLK.SAFE.CMD ,
        mcRead               := #p.read.mc ,
        mcWrite              := #p.write.mc
    );

NETWORK
TITLE = Call BLOCK Mode and Command handling block
    //------------------------------------------------------------------------//
    // Process the stackable block functions for mode and command change      //
    // events:                                                                //
    //------------------------------------------------------------------------//
    CALL "fcModeCmdBLK"
    (   tmrChildExpired      := #timeCheckChildStateExpired ,
        mcRead               := #p.read.mc ,
        mcWrite              := #p.write.mc ,
        bmc                  := #p.read.bmc ,
        err                  := #p.read.err
    );

@@ATTR_BEGIN|CHILD_COMMAND_EXISTS@@
NETWORK
TITLE = Set child devices to safe state if stopped command or SFC fault
    //------------------------------------------------------------------------//
    // SAFE STATE   SAFE STATE   SAFE STATE   SAFE STATE  SAFE STATE  SAFE ST //
    //                                                                        //
    // Set the child device to the safe state on stop or fault:               //
    //------------------------------------------------------------------------//
    O #cmdSTOPPED;
@@ATTR_BEGIN|SFCExists@@
@@ATTR_BEGIN|SFC@@
    O(;
    A #subsRunning.@@STATE@@;
    A #@@SFC@@.smc.ERR_FAULT;
    );
@@ATTR_END|SFC@@
@@ATTR_END|SFCExists@@
    = #p.read.err.childSafeState;
    JCN _notChildSafe;

    //------------------------------------------------------------------------//
    // Set all child devices to safe state due to block stop or problem:      //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|CHILD_COMMAND@@
@@ATTR_BEGIN|CHILD_ACQUIRE_EXISTS_ALIAS@@
    A #acquire.@@CHILDPARAMETERALIAS@@;
@@ATTR_END|CHILD_ACQUIRE_EXISTS_ALIAS@@
    @@CHILDCOMMANDSTATEMENT@@
    A "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.read.mc.modeAUTO;
@@ATTR_BEGIN|PARENT_PEER@@
    A "idb@@PARENTPEERCLASS@@".f[#p.child.@@PARENTPEERALIAS@@].p.read.mc.modeAUTO;
@@ATTR_END|PARENT_PEER@@
    JCN _blkSafe_@@CHILDPARAMETERALIAS@@;
    L "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.read.mc.CMD_SAFE;
    T "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.write.mc.CMD;
    T #childReqCMD.@@CHILDPARAMETERALIAS@@;
_blkSafe_@@CHILDPARAMETERALIAS@@:   NOP 0;


@@ATTR_END|CHILD_COMMAND@@

_notChildSafe:   NOP 0;
@@ATTR_END|CHILD_COMMAND_EXISTS@@

@@ATTR_BEGIN|SFCExists@@
NETWORK
TITLE = All SQ are in Auto mode when EM in Auto
    //------------------------------------------------------------------------//
    // SFC AUTO   SFC AUTO   SFC AUTO   SFC AUTO   SFC AUTO   SFC AUTO   SFC  //
    //                                                                        //
    // Set all SFCs to AUTO mode if the block is in AUTO:                     //
    //------------------------------------------------------------------------//
    A #p.read.bmc.event.modeAUTO;
    JCN _nomcAuto;
    L #p.write.mc.MODE;
@@ATTR_BEGIN|SFC@@
    T #@@SFC@@.smc.MODE;
@@ATTR_END|SFC@@
_nomcAuto:   NOP 0;

@@ATTR_END|SFCExists@@

@@ATTR_BEGIN|CHILD_COMMAND_EXISTS@@
NETWORK
TITLE = Cascade Auto or OOS Mode to children
    //------------------------------------------------------------------------//
    // MODE CASCADE   MODE CASCADE   MODE CASCADE   MODE CASCADE   MODE CASC  //
    //                                                                        //
    // Switch child mode to Auto or OOS when parent mode transitions:         //
    //------------------------------------------------------------------------//
    A(;
    O #p.read.bmc.event.modeAUTO;
    O #p.read.bmc.event.modeOOS;
    );
    JCN _nomcAutoOOS;

    L #p.write.mc.MODE;
@@ATTR_BEGIN|CHILD_COMMAND_ALWAYS@@
    T "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.write.mc.MODE;
@@ATTR_END|CHILD_COMMAND_ALWAYS@@

@@ATTR_BEGIN|CHILD_COMMAND_SELECTED@@
    @@CHILDCOMMANDSTATEMENT@@
    JCN _cascMode@@COUNTERATTR|1@@;
    L #p.write.mc.MODE;
    T "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.write.mc.MODE;
_cascMode@@COUNTERATTR|1@@:   NOP 0;

@@ATTR_END|CHILD_COMMAND_SELECTED@@
_nomcAutoOOS:   NOP 0;
@@ATTR_END|CHILD_COMMAND_EXISTS@@

NETWORK
TITLE = Interlocked condition cleared
    //------------------------------------------------------------------------//
    // Set the state stopped if the interlock condition just cleared:         //
    //------------------------------------------------------------------------//
    AN #p.read.mc.INTERLOCK;
    A(;
    L #p.read.mc.STATE;
    L "dbCONST".BLK.STATE.INTERLOCKED;
    ==I;
    );
    JCN _ilCleared;
    L #p.write.mc.SUBS;
    T #p.read.mc.STATE;

_ilCleared:   NOP 0;

@@ATTR_BEGIN|CHILD_COMMAND_EXISTS@@
@@ATTR_BEGIN|pChildReadExists@@
NETWORK
TITLE = Upload child parameter values
    //------------------------------------------------------------------------//
    // CHILD PARAMETER   CHILD PARAMETER   CHILD PARAMETER   CHILD PARAMETER  //
    //                                                                        //
    // Get the initial input value for the child parameter:                   //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|CHILD_COMMAND@@
@@ATTR_BEGIN|pChildRead@@
    L "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.@@OPERATION@@.@@CHILDPARAMETERATTRIBUTE@@;
    T #p.@@OPERATION@@.@@CHILDPARAMETERALIAS@@_@@CHILDPARAMETERATTRIBUTE@@;
@@ATTR_END|pChildRead@@
@@ATTR_END|CHILD_COMMAND@@

@@ATTR_END|pChildReadExists@@
@@ATTR_END|CHILD_COMMAND_EXISTS@@

@@ATTR_BEGIN|CHILD_COMMAND_EXISTS@@
@@ATTR_BEGIN|pChildReadBoolExists@@
@@ATTR_BEGIN|CHILD_COMMAND@@
@@ATTR_BEGIN|pChildReadBool@@
    A "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.@@OPERATION@@.@@CHILDPARAMETERATTRIBUTE@@;
    = #p.@@OPERATION@@.@@CHILDPARAMETERALIAS@@_@@CHILDPARAMETERATTRIBUTE@@;
@@ATTR_END|pChildReadBool@@
@@ATTR_END|CHILD_COMMAND@@

@@ATTR_END|pChildReadBoolExists@@
@@ATTR_END|CHILD_COMMAND_EXISTS@@

NETWORK
TITLE = Set parent parameter values for child devices
    //------------------------------------------------------------------------//
    // PARENT PARAMETER   PARENT PARAMETER   PARENT PARAMETER   PARENT PARAM  //
    //                                                                        //
    // Set the initial input value for the child calling parameter:           //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|CHILD_COMMAND_EXISTS@@
@@ATTR_BEGIN|CHILD_COMMAND@@
@@ATTR_BEGIN|pParentWriteExists@@
    A "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.read.mc.modeAUTO;
    @@CHILDCOMMANDSTATEMENT@@
    JCN _parentWrite_@@CHILDPARAMETERALIAS@@;
@@ATTR_BEGIN|pParentWrite@@
    L #p.@@OPERATION@@.@@CHILDPARAMETERATTRIBUTE@@;
    T #p.command.@@CHILDPARAMETERALIAS@@_@@CHILDPARAMETERATTRIBUTE@@;
@@ATTR_END|pParentWrite@@
@@ATTR_BEGIN|pParentWriteBool@@
    A #p.@@OPERATION@@.@@CHILDPARAMETERATTRIBUTE@@;
    = #p.command.@@CHILDPARAMETERALIAS@@_@@CHILDPARAMETERATTRIBUTE@@;
@@ATTR_END|pParentWriteBool@@
_parentWrite_@@CHILDPARAMETERALIAS@@:   NOP 0;


@@ATTR_END|pParentWriteExists@@
@@ATTR_END|CHILD_COMMAND@@
@@ATTR_END|CHILD_COMMAND_EXISTS@@

@@ATTR_BEGIN|HYGIENE@@
NETWORK
TITLE = Hygiene Status Calculation
    //------------------------------------------------------------------------//
    // HYGIENE   HYGIENE   HYGIENE   HYGIENE   HYGIENE   HYGIENE   HYGIENE    //
    //                                                                        //
    // Calculate the hygiene status of the block:                             //
    //------------------------------------------------------------------------//
    CALL "fcHygiene"
    (   hygiene              := #p.write.mc.HYGIENE ,
        hs                   := #p.read.hs
    );
@@ATTR_END|HYGIENE@@

NETWORK
TITLE = SWITCH SWITCH SWITCH command and state
    //------------------------------------------------------------------------//
    // SWITCH   SWITCH   SWITCH   SWITCH   SWITCH   SWITCH   SWITCH   SWITCH  //
    //                                                                        //
    // Switch statement for block command and state. The order of the jumps   //
    // is important:                                                          //
    //------------------------------------------------------------------------//
_switch:   NOP 0;
    A #p.read.bmc.event.cmdStop;
    JC _state_STOPPING;

    A #cmdSTOPPED;
    JC _state_STOPPED;

    O #p.read.bmc.event.cmdStart;
    O #p.read.bmc.event.cmdRestart;
    JC _state_STARTING;

    A #p.read.bmc.flags.substateCompleted;
    JC _state_COMPLETED;

    A #p.read.bmc.state.running;
    JC _state_RUNNING;

    SET;
    JC _switch_end;

    //------------------------------------------------------------------------//
    // SWITCH   SWITCH   SWITCH   SWITCH   SWITCH   SWITCH   SWITCH   SWITCH  //
    // STOPPING   STOPPING   STOPPING   STOPPING   STOPPING   STOPPING   STOP //
    // STOPPING   STOPPING   STOPPING   STOPPING   STOPPING   STOPPING   STOP //
    //------------------------------------------------------------------------//
_state_STOPPING: NOP 0;

SET;
JC _switch_end;

    //------------------------------------------------------------------------//
    // SWITCH   SWITCH   SWITCH   SWITCH   SWITCH   SWITCH   SWITCH   SWITCH  //
    // STOPPED   STOPPED   STOPPED   STOPPED   STOPPED   STOPPED   STOPPED    //
    // STOPPED   STOPPED   STOPPED   STOPPED   STOPPED   STOPPED   STOPPED    //
    //------------------------------------------------------------------------//
_state_STOPPED:   NOP 0;

NETWORK
TITLE = STOPPED STOPPED STOPPED Set block state STOPPED
    //------------------------------------------------------------------------//
    // Reset the completed flag and the block state to stopped:               //
    //------------------------------------------------------------------------//
	L "dbCONST".BLK.@@CLASS@@.STATE.STOPPED;
    T #p.read.mc.STATE;

    //------------------------------------------------------------------------//
    // If commanded to Stop then tell the SFC to go to the last step:         //
    //------------------------------------------------------------------------//
    L "dbCONST".SEQ.CMD.STOP;
@@ATTR_BEGIN|SFC@@
    T #@@SFC@@.smc.SQ_CMD;
    T #@@SFC@@.sqSequencer.CMD.New;
@@ATTR_END|SFC@@

    //------------------------------------------------------------------------//
    // Reset flags:                                                           //
    //------------------------------------------------------------------------//
    SET;
    R #p.read.bmc.flags.sfcAborted;
    R #p.read.bmc.flags.sfcCompleted;
    R #p.read.bmc.flags.substateCompleted;
@@ATTR_BEGIN|STATE@@
    R #subsRunning.@@STATE@@;
@@ATTR_END|STATE@@

    //------------------------------------------------------------------------//
    // Reset the child commands:                                              //
    //------------------------------------------------------------------------//
    L 0;
@@ATTR_BEGIN|pSFCChildMCWriteDefine@@
    T #p.command.@@BLOCKPARAMETER@@;
@@ATTR_END|pSFCChildMCWriteDefine@@
@@ATTR_BEGIN|pSFCChildMCWriteDefineHygiene@@
    T #p.write.@@BLOCKPARAMETER@@;
@@ATTR_END|pSFCChildMCWriteDefineHygiene@@
@@ATTR_BEGIN|pSFCSelectMCWriteDefine@@
    T #p.select.@@BLOCKPARAMETER@@;
@@ATTR_END|pSFCSelectMCWriteDefine@@

@@ATTR_BEGIN|CHILD_COMMAND_EXISTS@@
    //------------------------------------------------------------------------//
    // Disarm the flowpath child devices when STOP command issued:            //
    //------------------------------------------------------------------------//
    SET;
@@ATTR_BEGIN|CHILD_COMMAND@@
@@ATTR_BEGIN|CHILD_ACQUIRE_EXISTS_ALIAS@@
    A #acquire.@@CHILDPARAMETERALIAS@@;
@@ATTR_END|CHILD_ACQUIRE_EXISTS_ALIAS@@
    R "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.write.mc.ARMED;
@@ATTR_END|CHILD_COMMAND@@
@@ATTR_END|CHILD_COMMAND_EXISTS@@

@@ATTR_BEGIN|SELECT_EXISTS@@
    //------------------------------------------------------------------------//
    // Clear calling parameter selections:                                    //
    //------------------------------------------------------------------------//
    SET;
@@ATTR_BEGIN|SELECT@@
@@ATTR_BEGIN|SELVALUE@@
    R #selected_@@PARAMETER@@_@@SELECTION@@.@@SELECTIONVALUE@@;
@@ATTR_END|SELVALUE@@
@@ATTR_END|SELECT@@
@@ATTR_END|SELECT_EXISTS@@

@@ATTR_BEGIN|pEventPromptExists@@
    //------------------------------------------------------------------------//
    // CLEAR OPERATOR PROMPT   CLEAR OPERATOR PROMPT   CLEAR OPERATOR PROMPT  //
    //                                                                        //
    // Clear the SFC prompt and confirm bits and the global shared event bits.//
    // Each HMI requires its own trigger and active flags;                    //
    //------------------------------------------------------------------------//
    SET;
@@ATTR_BEGIN|pEventPrompt@@
    R #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;
    R #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@_confirm_yes;
@@ATTR_BEGIN|pEventPromptConfirmNo@@
    R #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@_confirm_no;
@@ATTR_END|pEventPromptConfirmNo@@
@@ATTR_END|pEventPrompt@@
@@ATTR_BEGIN|pEventPrompt@@
    CALL fcClearEventPrompt (cancelEvent := TRUE, eventPrompt := "dbEVENT".eventPrompt.event[#p.link.eventPrompt_@@NUMEVENT@@]);
@@ATTR_END|pEventPrompt@@
@@ATTR_END|pEventPromptExists@@

@@ATTR_BEGIN|pEventConfirmNoExists@@
    //------------------------------------------------------------------------//
    // CLEAR PROMPT NO   CLEAR PROMPT NO   CLEAR PROMPT NO   CLEAR PROMPT NO  //
    //                                                                        //
    // Clear the SFC event prompt confirm No  bits and the class bits:        //
    //------------------------------------------------------------------------//
    L 0;
@@ATTR_BEGIN|pEventConfirmNoWordClass@@
    T #wEventConfirmNo[@@CWORD@@];
@@ATTR_END|pEventConfirmNoWordClass@@
@@ATTR_END|pEventConfirmNoExists@@

@@ATTR_BEGIN|pEventConfirmYesExists@@
    //------------------------------------------------------------------------//
    // CLEAR PROMPT YES   CLEAR PROMPT YES   CLEAR PROMPT YES   CLEAR PROMPT  //
    //                                                                        //
    // Clear the SFC event prompt confirm Yes  bits and the class bits:       //
    //------------------------------------------------------------------------//
    L 0;
@@ATTR_BEGIN|pEventConfirmYesWordClass@@
    T #wEventConfirmYes[@@CWORD@@];
@@ATTR_END|pEventConfirmYesWordClass@@
@@ATTR_END|pEventConfirmYesExists@@

@@ATTR_BEGIN|pEventLogMsgExists@@
    //------------------------------------------------------------------------//
    // CLEAR LOG MESSAGE   CLEAR LOG MESSAGE   CLEAR LOG MESSAGE   CLEAR LOG  //
    //                                                                        //
    // Clear the SFC log message bits and the class bits:                     //
    //------------------------------------------------------------------------//
    L 0;
@@ATTR_BEGIN|pEventLogMsgWordClass@@
    T #wEventLogMsg[@@CWORD@@];
@@ATTR_END|pEventLogMsgWordClass@@
    SET;
@@ATTR_BEGIN|pEventLogMsgClass@@
    R #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;
@@ATTR_END|pEventLogMsgClass@@
@@ATTR_END|pEventLogMsgExists@@

@@ATTR_BEGIN|pEventLogRealExists@@
    //------------------------------------------------------------------------//
    // CLEAR LOG REAL   CLEAR LOG REAL   CLEAR LOG REAL   CLEAR LOG REAL   CL //
    //                                                                        //
    // Clear the SFC log real data:                                           //
    //------------------------------------------------------------------------//
    L 0;
@@ATTR_BEGIN|pEventLogRealWordClass@@
    T #wEventLogReal[@@CWORD@@];
@@ATTR_END|pEventLogRealWordClass@@
    SET;
@@ATTR_BEGIN|pEventLogRealClass@@
    R #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;
@@ATTR_END|pEventLogRealClass@@
@@ATTR_END|pEventLogRealExists@@

@@ATTR_BEGIN|pEventLogTimeExists@@
    //------------------------------------------------------------------------//
    // CLEAR LOG TIME   CLEAR LOG TIME   CLEAR LOG TIME   CLEAR LOG TIME   CL //
    //                                                                        //
    // Clear the SFC log time data:                                           //
    //------------------------------------------------------------------------//
    L 0;
@@ATTR_BEGIN|pEventLogTimeWordClass@@
    T #wEventLogTime[@@CWORD@@];
@@ATTR_END|pEventLogTimeWordClass@@
    SET;
@@ATTR_BEGIN|pEventLogTimeClass@@
    R #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;
@@ATTR_END|pEventLogTimeClass@@
@@ATTR_END|pEventLogTimeExists@@

@@ATTR_BEGIN|pEventLogRealExists@@
    //------------------------------------------------------------------------//
    // ZERO DATA REAL   ZERO DATA REAL   ZERO DATA REAL   ZERO DATA REAL   ZE //
    //                                                                        //
    // Zero the SFC log real data parameter:                                  //
    //------------------------------------------------------------------------//
    L 0;
@@ATTR_BEGIN|pEventDataReal@@
    T #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;
@@ATTR_END|pEventDataReal@@
@@ATTR_END|pEventLogRealExists@@

@@ATTR_BEGIN|pEventLogTimeExists@@
    //------------------------------------------------------------------------//
    // ZERO DATA TIME   ZERO DATA TIME   ZERO DATA TIME   ZERO DATA TIME   ZE //
    //                                                                        //
    // Zero the SFC log time data and the global shared event DB data:        //
    //------------------------------------------------------------------------//
    L 0;
@@ATTR_BEGIN|pEventDataTime@@
    T #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;
@@ATTR_END|pEventDataTime@@
@@ATTR_END|pEventLogTimeExists@@

@@ATTR_BEGIN|CHILD_ACQUIRE@@
    //------------------------------------------------------------------------//
    // RELEASE CHILD   RELEASE CHILD   RELEASE CHILD   RELEASE CHILD   RELE   //
    //                                                                        //
    // Make the child device available if acquired to run the command:        //
    //------------------------------------------------------------------------//
    A #acquire.@@CHILDPARAMETERALIAS@@;
    JCN _alreadyAvail@@COUNTERATTR|1@@;
    L "dbCONST".BLK.ID.AVAILABLE;
    T "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.write.mc.OWNER;
_alreadyAvail@@COUNTERATTR|1@@:   NOP 0;

    //------------------------------------------------------------------------//
    // Release the child device if acquired earlier to run the command:       //
    //------------------------------------------------------------------------//
    A #acquire.@@CHILDPARAMETERALIAS@@;
    A "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.read.mc.isAvailable;
    JCN _notOwn@@COUNTERATTR|1@@;
    R #acquire.@@CHILDPARAMETERALIAS@@;
    R "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.master.write;
_notOwn@@COUNTERATTR@@:   NOP 0;

@@ATTR_END|CHILD_ACQUIRE@@

SET;
JC _switch_end;

    //------------------------------------------------------------------------//
    // SWITCH   SWITCH   SWITCH   SWITCH   SWITCH   SWITCH   SWITCH   SWITCH  //
    // STARTING   STARTING   STARTING   STARTING   STARTING   STARTING   STAR //
    // STARTING   STARTING   STARTING   STARTING   STARTING   STARTING   STAR //
    //------------------------------------------------------------------------//
_state_STARTING: NOP 0;

NETWORK
TITLE = STARTING STARTING STARTING Reset running substate and completion flags
    //------------------------------------------------------------------------//
    // Reset flags:                                                           //
    //------------------------------------------------------------------------//
    SET;
    R #p.read.bmc.flags.sfcAborted;
    R #p.read.bmc.flags.sfcCompleted;
    R #p.read.bmc.flags.substateCompleted;
@@ATTR_BEGIN|STATE@@
    R #subsRunning.@@STATE@@;
@@ATTR_END|STATE@@

@@ATTR_BEGIN|pEventPromptExists@@
    //------------------------------------------------------------------------//
    // Clear the SFC prompt cancel bits:                                      //
    //------------------------------------------------------------------------//
    SET;
@@ATTR_BEGIN|pEventPrompt@@
    CALL fcClearEventPrompt (cancelEvent := FALSE, eventPrompt := "dbEVENT".eventPrompt.event[#p.link.eventPrompt_@@NUMEVENT@@]);
@@ATTR_END|pEventPrompt@@
@@ATTR_END|pEventPromptExists@@

@@ATTR_BEGIN|STATE@@
    //------------------------------------------------------------------------//
    // RUNNING SUBSTATE FLAG   RUNNING SUBSTATE FLAG   RUNNING SUBSTATE FLAG  //
    //                                                                        //
    // Convert running substate values into boolean flags for ease of use in  //
    // boolean logic:                                                         //
    //------------------------------------------------------------------------//
    A(;
    L #p.write.mc.SUBS;
    L "dbCONST".BLK.@@CLASS@@.SUBS.@@STATE@@;
    ==I;
    );
    = #subsStart.@@STATE@@;
    JCN _noSubsRun_@@STATE@@;
    S #subsRunning.@@STATE@@;
_noSubsRun_@@STATE@@:   NOP 0;

@@ATTR_END|STATE@@

    //------------------------------------------------------------------------//
    // Set the state to the substate if running:                              //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|STATE@@
    O #subsRunning.@@STATE@@;
@@ATTR_END|STATE@@
    JCN _noSubsRun;
    L #p.write.mc.SUBS;
    T #p.read.mc.STATE;
_noSubsRun:   NOP 0;

@@ATTR_BEGIN|SELECT_EXISTS@@
    //------------------------------------------------------------------------//
    // CALLING PARAMETER SELECTION FLAG   CALLING PARAMETER SELECTION FLAG    //
    //                                                                        //
    // Convert calling parameter selections into the boolean flags for ease   //
    // of use in boolean logic if starting a new substate:                    //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|SELECT@@
@@ATTR_BEGIN|SELVALUE@@
    A(;
    L #p.write.@@PARAMETER@@_@@SELECTION@@;
    L "dbCONST".SEL.@@SELECTION@@.@@SELECTIONVALUE@@;
    ==I;
    );
    JCN _noSelect_@@PARAMETER@@_@@SELECTION@@_@@SELECTIONVALUE@@;
    S #selected_@@PARAMETER@@_@@SELECTION@@.@@SELECTIONVALUE@@;
    JC _select_@@PARAMETER@@_@@SELECTION@@_@@SELECTIONVALUE@@;

_noSelect_@@PARAMETER@@_@@SELECTION@@_@@SELECTIONVALUE@@:   NOP 0;
    R #selected_@@PARAMETER@@_@@SELECTION@@.@@SELECTIONVALUE@@;

_select_@@PARAMETER@@_@@SELECTION@@_@@SELECTIONVALUE@@:   NOP 0;

@@ATTR_END|SELVALUE@@
@@ATTR_END|SELECT@@
@@ATTR_END|SELECT_EXISTS@@

@@ATTR_BEGIN|CHILD_SELECT@@
    //------------------------------------------------------------------------//
    // CHILD SELECT   CHILD SELECT   CHILD SELECT   CHILD SELECT   CHILD SEL  //
    //                                                                        //
    // Set the index value for the selected child:                            //
    //------------------------------------------------------------------------//
    @@CHILDACQUIRESTATEMENT@@
    JCN _childSelect_@@COUNTERATTR|1@@;
    L #p.child.@@CHILDPARAMETERALIAS@@;
    T #p.select.@@CHILDLINKALIAS@@;
_childSelect_@@COUNTERATTR|1@@:   NOP 0;

@@ATTR_END|CHILD_SELECT@@

@@ATTR_BEGIN|CHILD_ACQUIRE@@
    //------------------------------------------------------------------------//
    // ACQUIRE CHILDREN   ACQUIRE CHILDREN   ACQUIRE CHILDREN   ACQUIRE CHILD //
    //                                                                        //
    // Flag to take ownership of the child now and release at the end if      //
    // the child is available as it would be a child unavailabile failure     //
    // above if not available at this point:                                  //
    //------------------------------------------------------------------------//
    @@CHILDACQUIRESTATEMENT@@
    A "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.read.mc.isAvailable;
@@ATTR_BEGIN|CHILD_ACQUIRE_STATE_EXISTS@@
    A(;
@@ATTR_BEGIN|CHILD_ACQUIRE_STATE@@
    O #subsRunning.@@STATE@@;
@@ATTR_END|CHILD_ACQUIRE_STATE@@
    );
@@ATTR_END|CHILD_ACQUIRE_STATE_EXISTS@@
    JCN _childAvail_@@CHILDPARAMETERALIAS@@;
    S #acquire.@@CHILDPARAMETERALIAS@@;
    S "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.master.write;
    L #p.read.mc.ME;
    T "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.write.mc.OWNER;

_childAvail_@@CHILDPARAMETERALIAS@@:   NOP 0;

@@ATTR_END|CHILD_ACQUIRE@@

    //------------------------------------------------------------------------//
    // BATCH ID    BATCH ID    BATCH ID    BATCH ID    BATCH ID    BATCH ID   //
    //                                                                        //
    // Cascade this block's Batch Number to all child devices:                //
    //------------------------------------------------------------------------//
    L #p.write.mc.SERIALNUM;
@@ATTR_BEGIN|CHILD_CASCADE_ALWAYS@@
    T "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.write.mc.SERIALNUM;
@@ATTR_END|CHILD_CASCADE_ALWAYS@@

@@ATTR_BEGIN|CHILD_CASCADE_SELECTED@@
    @@CHILDCOMMANDSTATEMENT@@
    JCN _childBatch_@@COUNTERATTR|1@@;
    L #p.write.mc.SERIALNUM;
    T "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.write.mc.SERIALNUM;
_childBatch_@@COUNTERATTR|1@@:   NOP 0;

@@ATTR_END|CHILD_CASCADE_SELECTED@@

@@ATTR_BEGIN|CHILD_CASCADE@@
@@ATTR_BEGIN|CHILD_INIT_CMD_TRUE_STATES@@
    //------------------------------------------------------------------------//
    // CHILD INITIAL TRUE COMMAND   CHILD INITIAL TRUE COMMAND   CHILD INITIA //
    //                                                                        //
    // Set the initial command values for the child devices.                  //
    // Command the child device to its initial command if condition is true:  //
    //------------------------------------------------------------------------//
	A "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.read.mc.modeAUTO;
    A(;
@@ATTR_BEGIN|CHILD_INIT_CMD_TRUE@@
    O(;
    A #subsStart.@@STATE@@;
    @@CHILDCOMMANDSTATEMENT@@
    @@CONDITIONSTATEMENT@@
    );
@@ATTR_END|CHILD_INIT_CMD_TRUE@@
    );
    JCN _childInitTrue_@@CHILDPARAMETERALIAS@@_@@TRUECOMMAND@@;
    @@TRUESTATEMENT@@
    T #childReqCMD.@@CHILDPARAMETERALIAS@@;

_childInitTrue_@@CHILDPARAMETERALIAS@@_@@TRUECOMMAND@@:   NOP 0;


@@ATTR_END|CHILD_INIT_CMD_TRUE_STATES@@
@@ATTR_END|CHILD_CASCADE@@

@@ATTR_BEGIN|CHILD_INIT_CMD_FALSE_EXISTS@@
@@ATTR_BEGIN|CHILD_CASCADE@@
@@ATTR_BEGIN|CHILD_INIT_CMD_FALSE_STATES@@
    //------------------------------------------------------------------------//
    // CHILD INITIAL FALSE COMMAND   CHILD INITIAL FALSE COMMAND   CHILD INIT //
    //                                                                        //
    // Set the initial command values for the child devices.                  //
    // Command the child device to its initial command:                       //
    //------------------------------------------------------------------------//
	A "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.read.mc.modeAUTO;
    A(;
@@ATTR_BEGIN|CHILD_INIT_CMD_FALSE@@
    O(;
    A #subsStart.@@STATE@@;
    @@CHILDCOMMANDSTATEMENT@@
    AN(;
    @@CONDITIONSTATEMENT@@
    );
    );
@@ATTR_END|CHILD_INIT_CMD_FALSE@@
    );
    JCN _childInitFalse_@@CHILDPARAMETERALIAS@@_@@FALSECOMMAND@@;
    @@FALSESTATEMENT@@
    T #childReqCMD.@@CHILDPARAMETERALIAS@@;

_childInitFalse_@@CHILDPARAMETERALIAS@@_@@FALSECOMMAND@@:   NOP 0;

@@ATTR_END|CHILD_INIT_CMD_FALSE_STATES@@
@@ATTR_END|CHILD_CASCADE@@
@@ATTR_END|CHILD_INIT_CMD_FALSE_EXISTS@@


@@ATTR_BEGIN|SFC@@
@@ATTR_BEGIN|pSFCParametersRecipeExist@@
    //------------------------------------------------------------------------//
    // Set recipe parameters:                                                 //
    //------------------------------------------------------------------------//
    A #subsStart.@@STATE@@;
    JCN _noStaticParms_@@STATE@@;
@@ATTR_BEGIN|pSFCParametersRecipe@@
    L #p.write.@@BLOCKPARAMETER@@;
    T #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;
@@ATTR_END|pSFCParametersRecipe@@

_noStaticParms_@@STATE@@:   NOP 0;

@@ATTR_END|pSFCParametersRecipeExist@@
@@ATTR_END|SFC@@

@@ATTR_BEGIN|SFC@@
    //------------------------------------------------------------------------//
    // START SFC   START SFC   START SFC   START SFC   START SFC   START SFC  //
    //                                                                        //
    // Start the running substate SFC.                                        //
    //                                                                        //
    // Set the running substate SFC to AUTO mode and start it:                //
    //------------------------------------------------------------------------//
    A #subsStart.@@STATE@@;
    JCN _notSFCStarting_@@STATE@@;
    L "dbCONST".SEQ.MODE.AUTO;
    T #@@SFC@@.smc.MODE;
    L "dbCONST".SEQ.CMD.START;
    T #@@SFC@@.smc.SQ_CMD;
    L 0;
    T #@@SFC@@.sqSequencer.CMD.Old;

_notSFCStarting_@@STATE@@:      NOP 0;
@@ATTR_END|SFC@@

@@ATTR_BEGIN|CHILD_COMMAND_EXISTS@@
    //------------------------------------------------------------------------//
    // Arm any flowpath child devices:                                        //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|CHILD_ARM_STARTED_ALWAYS@@
    S "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.write.mc.ARMED;
@@ATTR_END|CHILD_ARM_STARTED_ALWAYS@@

@@ATTR_BEGIN|CHILD_ARM_STARTED@@
    @@CHILDARMSTATEMENT@@
    JCN _noArm_@@CHILDPARAMETERALIAS@@;
    S "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.write.mc.ARMED;
_noArm_@@CHILDPARAMETERALIAS@@:   NOP 0;

@@ATTR_END|CHILD_ARM_STARTED@@
@@ATTR_END|CHILD_COMMAND_EXISTS@@

SET;
JC _switch_end;

    //------------------------------------------------------------------------//
    // SWITCH   SWITCH   SWITCH   SWITCH   SWITCH   SWITCH   SWITCH   SWITCH  //
    // RUNNING   RUNNING   RUNNING   RUNNING   RUNNING   RUNNING   RUNNING    //
    // RUNNING   RUNNING   RUNNING   RUNNING   RUNNING   RUNNING   RUNNING    //
    //------------------------------------------------------------------------//
_state_RUNNING: NOP 0;

NETWORK
TITLE = RUNNING RUNNING RUNNING Set child selection values
    //------------------------------------------------------------------------//
    // Set the child selection command:                                       //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|pSFCSelectMCWriteDefine@@
    L #p.select.@@BLOCKPARAMETER@@;
@@ATTR_BEGIN|CHILD_COMMAND_CLASS_ALIAS@@
    T #p.command.@@SELECTCHILDPARAMETERALIAS@@_@@CHILDPARAMETERATTRIBUTE@@;
@@ATTR_END|CHILD_COMMAND_CLASS_ALIAS@@
@@ATTR_END|pSFCSelectMCWriteDefine@@

NETWORK
TITLE = Interlock pauses the running SFC
    //------------------------------------------------------------------------//
    // Pause the running SFC sequence if any interlock or failure condition:  //
    //------------------------------------------------------------------------//
    AN #cmdSTOPPED;
	AN #p.read.bmc.permitStart;
    JCN _ilPause;

@@ATTR_BEGIN|SFC@@
    A #subsRunning.@@STATE@@;
    JCN _ilSFC_@@STATE@@;
    L "dbCONST".SEQ.CMD.PAUSE;
    T #@@SFC@@.smc.SQ_CMD;
_ilSFC_@@STATE@@:   NOP 0;

@@ATTR_END|SFC@@

_ilPause:   NOP 0;

@@ATTR_BEGIN|pEventPromptExists@@
NETWORK
TITLE = Raise operator prompt if required
    //------------------------------------------------------------------------//
    // OPERATOR PROMPT   OPERATOR PROMPT   OPERATOR PROMPT   OPERATOR PROMPT  //
    //                                                                        //
    // Transfer the SFC eventPrompt bit to the global event datablock:        //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|SFC@@
    O #subsRunning.@@STATE@@;
@@ATTR_END|SFC@@
    JCN _noRunPrompt;
@@ATTR_BEGIN|pEventPrompt@@

    A #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;
    A(;
    ON "hmi1Active";
    ON "dbEVENT".eventPrompt.event[#p.link.eventPrompt_@@NUMEVENT@@].cancel1;
    );
    A(;
    ON "hmi2Active";
    ON "dbEVENT".eventPrompt.event[#p.link.eventPrompt_@@NUMEVENT@@].cancel2;
    );
    A(;
    ON "hmi3Active";
    ON "dbEVENT".eventPrompt.event[#p.link.eventPrompt_@@NUMEVENT@@].cancel3;
    );
    A(;
    ON "hmi4Active";
    ON "dbEVENT".eventPrompt.event[#p.link.eventPrompt_@@NUMEVENT@@].cancel4;
    );
    A(;
    ON "hmi5Active";
    ON "dbEVENT".eventPrompt.event[#p.link.eventPrompt_@@NUMEVENT@@].cancel5;
    );
    JCN _not_eventPrompt_@@IDXEVENT@@;
    L #p.write.mc.SERIALNUM;
    T "dbEVENT".eventPrompt.event[#p.link.eventPrompt_@@NUMEVENT@@].numSerial;
    R #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;
    R #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@_confirm_yes;
@@ATTR_BEGIN|pEventPromptConfirmNo@@
    R #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@_confirm_no;
@@ATTR_END|pEventPromptConfirmNo@@
    R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_@@NUMEVENT@@].confirmYes;
@@ATTR_BEGIN|pEventPromptConfirmNo@@
    R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_@@NUMEVENT@@].confirmNo;
@@ATTR_END|pEventPromptConfirmNo@@
    S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_@@NUMEVENT@@].trigger1;
    S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_@@NUMEVENT@@].trigger2;
    S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_@@NUMEVENT@@].trigger3;
    S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_@@NUMEVENT@@].trigger4;
    S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_@@NUMEVENT@@].trigger5;
_not_eventPrompt_@@IDXEVENT@@:   NOP 0;

@@ATTR_END|pEventPrompt@@

_noRunPrompt:   NOP 0;

NETWORK
TITLE = Cancel the event messages if response received
    //------------------------------------------------------------------------//
    // Cancel all HMI event messages if a response received:                  //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|pEventPrompt@@
    O "dbEVENT".eventPrompt.event[#p.link.eventPrompt_@@NUMEVENT@@].confirmYes;
    O "dbEVENT".eventPrompt.event[#p.link.eventPrompt_@@NUMEVENT@@].confirmNo;
    JCN _no_Response_@@IDXEVENT@@;
    S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_@@NUMEVENT@@].cancel1;
    S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_@@NUMEVENT@@].cancel2;
    S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_@@NUMEVENT@@].cancel3;
    S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_@@NUMEVENT@@].cancel4;
    S "dbEVENT".eventPrompt.event[#p.link.eventPrompt_@@NUMEVENT@@].cancel5;
_no_Response_@@IDXEVENT@@:   NOP 0;

@@ATTR_END|pEventPrompt@@

NETWORK
TITLE = Return operator confirm bits if made
    //------------------------------------------------------------------------//
    // Receive the eventPrompt confirm bits from the global event datablock:  //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|pEventPrompt@@
    A "dbEVENT".eventPrompt.event[#p.link.eventPrompt_@@NUMEVENT@@].confirmYes;
    JCN _not_eventPrompt_@@IDXEVENT@@_confirmYes;
    S #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@_confirm_yes;
    R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_@@NUMEVENT@@].confirmYes;
_not_eventPrompt_@@IDXEVENT@@_confirmYes:   NOP 0;

@@ATTR_BEGIN|pEventPromptConfirmNo@@
    A "dbEVENT".eventPrompt.event[#p.link.eventPrompt_@@NUMEVENT@@].confirmNo;
    JCN _not_eventPrompt_@@IDXEVENT@@_confirmNo;
    S #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@_confirm_no;
    R "dbEVENT".eventPrompt.event[#p.link.eventPrompt_@@NUMEVENT@@].confirmNo;
_not_eventPrompt_@@IDXEVENT@@_confirmNo:   NOP 0;
@@ATTR_END|pEventPromptConfirmNo@@


@@ATTR_END|pEventPrompt@@
@@ATTR_END|pEventPromptExists@@

@@ATTR_BEGIN|pEventConfirmNoExists@@
NETWORK
TITLE = Log prompt confirm No if required
    //------------------------------------------------------------------------//
    // LOG PROMPT CONFIRM NO   LOG PROMPT CONFIRM NO   LOG PROMPT CONFIRM NO  //
    //                                                                        //
    // Set the eventPrompt confirm No message alarm bit if active:            //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|SFC@@
    O #subsRunning.@@STATE@@;
@@ATTR_END|SFC@@
    JCN _noRunConfirmNo;
@@ATTR_BEGIN|pEventConfirmNoClass@@
    A #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;
    = #bEventConfirmNo[@@COFFSET@@];
@@ATTR_END|pEventConfirmNoClass@@

_noRunConfirmNo:   NOP 0;

@@ATTR_END|pEventConfirmNoExists@@

@@ATTR_BEGIN|pEventConfirmYesExists@@
NETWORK
TITLE = Log prompt confirm Yes if required
    //------------------------------------------------------------------------//
    // LOG PROMPT CONFIRM YES   LOG PROMPT CONFIRM YES   LOG PROMPT CONFIRM   //
    //                                                                        //
    // Set the eventPrompt confirm Yes message alarm bit if active:           //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|SFC@@
    O #subsRunning.@@STATE@@;
@@ATTR_END|SFC@@
    JCN _noRunConfirmYes;
@@ATTR_BEGIN|pEventConfirmYesClass@@
    A #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;
    = #bEventConfirmYes[@@COFFSET@@];
@@ATTR_END|pEventConfirmYesClass@@

_noRunConfirmYes:   NOP 0;

@@ATTR_END|pEventConfirmYesExists@@

@@ATTR_BEGIN|pEventLogMsgExists@@
NETWORK
TITLE = Log message if required
    //------------------------------------------------------------------------//
    // LOG MSG   LOG MSG   LOG MSG   LOG MSG   LOG MSG   LOG MSG   LOG MSG    //
    //                                                                        //
    // Set the eventLogMsg message alarm bit if active:                       //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|SFC@@
    O #subsRunning.@@STATE@@;
@@ATTR_END|SFC@@
    JCN _noRunLogMsg;
@@ATTR_BEGIN|pEventLogMsgClass@@
    A #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;   // Bit @@CBIT@@
    = #bEventLogMsg[@@COFFSET@@];

@@ATTR_END|pEventLogMsgClass@@

_noRunLogMsg:   NOP 0;

@@ATTR_END|pEventLogMsgExists@@

@@ATTR_BEGIN|pEventLogRealExists@@
NETWORK
TITLE = Real data
    //------------------------------------------------------------------------//
    // REAL DATA   REAL DATA   REAL DATA   REAL DATA   REAL DATA   REAL DATA  //
    //                                                                        //
    // Transfer the SFC eventLogReal real data to the global event datablock: //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|SFC@@
    O #subsRunning.@@STATE@@;
@@ATTR_END|SFC@@
    JCN _noRunLogReal;

@@ATTR_BEGIN|pEventLogRealClass@@
    L #@@PARAMETERSOURCE@@.@@DATAPARAMETER@@;
    T "dbEVENT".eventDataReal[#p.link.eventDataReal_@@COFFSET@@];
    A #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;   // Bit @@CBIT@@
    = #bEventLogReal[@@COFFSET@@];

@@ATTR_END|pEventLogRealClass@@

_noRunLogReal:   NOP 0;
@@ATTR_END|pEventLogRealExists@@

@@ATTR_BEGIN|pEventLogTimeExists@@
NETWORK
TITLE = Time data
    //------------------------------------------------------------------------//
    // TIME DATA   TIME DATA   TIME DATA   TIME DATA   TIME DATA   TIME DATA  //
    //                                                                        //
    // Transfer the SFC eventLogTime data to the global event datablock:      //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|SFC@@
    O #subsRunning.@@STATE@@;
@@ATTR_END|SFC@@
    JCN _noRunLogTime;

@@ATTR_BEGIN|pEventLogTimeClass@@
    L #@@PARAMETERSOURCE@@.@@DATAPARAMETER@@;
    T "dbEVENT".eventDataTime[#p.link.eventDataTime_@@COFFSET@@];
    A #@@PARAMETERSOURCE@@.@@CHILDPARAMETER@@;   // Bit @@CBIT@@
    = #bEventLogTime[@@COFFSET@@];

@@ATTR_END|pEventLogTimeClass@@

_noRunLogTime:   NOP 0;
@@ATTR_END|pEventLogTimeExists@@

@@ATTR_BEGIN|SFCExists@@
NETWORK
TITLE = Flag SFC finished if successfully completed execution
    //------------------------------------------------------------------------//
    // SFC COMPLETE   SFC COMPLETE   SFC COMPLETE   SFC COMPLETE   SFC COMPL  //
    //                                                                        //
    // Flag SFC completed if the sequence has finished executing:             //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|SFC@@
    O(;
    A #subsRunning.@@STATE@@;
    A(;
    L #@@SFC@@.smc.SQ_STATE;
    L "dbCONST".SEQ.STATE.COMPLETED;
    ==I;
    );
    );
@@ATTR_END|SFC@@
    JCN _notFinishedSuccessful;
    S #p.read.bmc.flags.sfcCompleted;
    S #p.read.bmc.flags.substateCompleted;
_notFinishedSuccessful:   NOP 0;

@@ATTR_END|SFCExists@@

@@ATTR_BEGIN|SFCExists@@
NETWORK
TITLE = Flag SFC aborted if unsuccessfully completed execution
    //------------------------------------------------------------------------//
    // Flag SFC completed if the sequence has been aborted:                   //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|SFC@@
    O(;
    A #subsRunning.@@STATE@@;
    A(;
    L #@@SFC@@.smc.SQ_STATE;
    L "dbCONST".SEQ.STATE.ABORTED;
    ==I;
    );
    );
@@ATTR_END|SFC@@
    JCN _notFinishedUnsuccessful;
    S #p.read.bmc.flags.sfcAborted;
    S #p.read.bmc.flags.substateCompleted;
    L "dbCONST".BLK.@@CLASS@@.STATE.ABORTED;
    T #p.read.mc.STATE;
_notFinishedUnsuccessful:   NOP 0;

@@ATTR_END|SFCExists@@

@@ATTR_BEGIN|STATE_NO_SFCExists@@
NETWORK
TITLE = Check if non-SFC substate completed
    //------------------------------------------------------------------------//
    // Check if substate has been completed if no SFC:                        //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|STATE_NO_SFC@@
    O #subsRunning.@@STATE@@;
@@ATTR_END|STATE_NO_SFC@@
    JCN _noSFCSubstateComplete;
    S #p.read.bmc.flags.substateCompleted;
_noSFCSubstateComplete:   NOP 0;
@@ATTR_END|STATE_NO_SFCExists@@

SET;
JC _switch_end;

    //------------------------------------------------------------------------//
    // SWITCH   SWITCH   SWITCH   SWITCH   SWITCH   SWITCH   SWITCH   SWITCH  //
    // COMPLETED   COMPLETED   COMPLETED   COMPLETED   COMPLETED   COMPLETED  //
    // COMPLETED   COMPLETED   COMPLETED   COMPLETED   COMPLETED   COMPLETED  //
    //------------------------------------------------------------------------//
_state_COMPLETED: NOP 0;

NETWORK
TITLE = COMPLETED COMPLETED COMPLETED Running substate completed
    //------------------------------------------------------------------------//
    // BLOCK COMPLETE   BLOCK COMPLETE   BLOCK COMPLETE   BLOCK COMPLETE   BL //
    //                                                                        //
    // Set the block state to COMPLETED if no SFC or SFC completed:           //
    //------------------------------------------------------------------------//
    AN #p.read.bmc.flags.childMismatch;
    AN #p.read.bmc.flags.sfcAborted;
    JCN _blkComplete;
    L "dbCONST".BLK.@@CLASS@@.STATE.COMPLETED;
    T #p.read.mc.STATE;
    L #p.write.mc.SUBS;
    T #p.read.bmc.lastSUBS;

_blkComplete:   NOP 0;

@@ATTR_BEGIN|CHILD_COMMAND_EXISTS@@
NETWORK
TITLE = Arm completed flowpath devices
    //------------------------------------------------------------------------//
    // Arm any flowpath child devices:                                        //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|CHILD_ARM_COMPLETED@@
    @@CHILDARMSTATEMENT@@
    JCN _noArm_@@CHILDPARAMETERALIAS@@;
    S "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.write.mc.ARMED;
_noArm_@@CHILDPARAMETERALIAS@@:   NOP 0;

@@ATTR_END|CHILD_ARM_COMPLETED@@
@@ATTR_END|CHILD_COMMAND_EXISTS@@

    //------------------------------------------------------------------------//
    // SWITCH   SWITCH   SWITCH   SWITCH   SWITCH   SWITCH   SWITCH   SWITCH  //
    // END   END   END   END   END   END  END   END   END   END   END   END   //
    // END   END   END   END   END   END  END   END   END   END   END   END   //
    //------------------------------------------------------------------------//
_switch_end:   NOP 0;

NETWORK
TITLE = SWITCH END SWITCH END ERROR if child mismatch
    //------------------------------------------------------------------------//
    // BLOCK ERROR   BLOCK ERROR   BLOCK ERROR   BLOCK ERROR   BLOCK ERROR    //
    //                                                                        //
    // Set the block state to ERROR if child mismatch and not STOPPED:        //
    //------------------------------------------------------------------------//
    AN #cmdSTOPPED;
	AN #p.read.bmc.permitStart;
    A(;
    L "dbCONST".BLK.@@CLASS@@.STATE.ERROR;
    L #p.read.mc.STATE;
    <>I;
    );
    JCN _blkError;
    L #p.read.mc.STATE;
    T #stateBeforeError;
    L "dbCONST".BLK.@@CLASS@@.STATE.ERROR;
    T #p.read.mc.STATE;
_blkError:   NOP 0;

NETWORK
TITLE = RESUME if children now okay
    //------------------------------------------------------------------------//
    // BLOCK RESUME   BLOCK RESUME   BLOCK RESUME   BLOCK RESUME   BLOCK RES  //
    //                                                                        //
    // Resume the running SFC sequence if no interlock or failure condition:  //
    //------------------------------------------------------------------------//
    AN #cmdSTOPPED;
	A #p.read.bmc.permitStart;
    A(;
    L "dbCONST".BLK.@@CLASS@@.STATE.ERROR;
    L #p.read.mc.STATE;
    ==I;
    );
    JCN _noResume;
//    L #stateBeforeError;
    L #p.write.mc.SUBS;
    T #p.read.mc.STATE;

@@ATTR_BEGIN|SFC@@
    A #subsRunning.@@STATE@@;
    JCN _resumeSFC_@@COUNTERATTR|1@@;
    L "dbCONST".SEQ.CMD.RESUME;
    T #@@SFC@@.smc.SQ_CMD;
_resumeSFC_@@COUNTERATTR@@:   NOP 0;

@@ATTR_END|SFC@@

_noResume:   NOP 0;

NETWORK
TITLE = Upload child states
    //------------------------------------------------------------------------//
    // Upload the child state:                                                //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|CHILD_CASCADE@@
    L "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.read.mc.STATE;
    T #p.read.@@CHILDPARAMETERALIAS@@_STATE;
@@ATTR_END|CHILD_CASCADE@@

NETWORK
TITLE = Set child substate, command and parameters if no mismatch
    //------------------------------------------------------------------------//
    // Set the child data if no child mismatch:                               //
    //------------------------------------------------------------------------//
    AN #timeCheckChildStateExpired;
    A(;
    O #p.read.bmc.state.running;
    O(;
    L "dbCONST".BLK.@@CLASS@@.STATE.COMPLETED;
    L #p.read.mc.STATE;
    ==I;
    );
    );
    JCN _noCommandOnChildMismatch;

    //------------------------------------------------------------------------//
    // Set the block child substate and command if no child mismatch:         //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|CHILD_COMMAND_EXISTS@@
@@ATTR_BEGIN|CHILD_COMMAND_BLK@@
    A "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.read.mc.modeAUTO;
    @@CHILDCOMMANDSTATEMENT@@
    JCN _pSUBS_@@CHILDPARAMETERALIAS@@;
    L #p.command.@@CHILDPARAMETERALIAS@@_SUBS;
    T "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.write.mc.SUBS;
    L #p.command.@@CHILDPARAMETERALIAS@@_CMD;
    T "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.write.mc.CMD;
    T #childReqCMD.@@CHILDPARAMETERALIAS@@;
_pSUBS_@@CHILDPARAMETERALIAS@@:   NOP 0;

@@ATTR_END|CHILD_COMMAND_BLK@@
@@ATTR_END|CHILD_COMMAND_EXISTS@@

    //------------------------------------------------------------------------//
    // Set the non-block child command if no child mismatch:                  //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|CHILD_COMMAND_EXISTS@@
@@ATTR_BEGIN|CHILD_COMMAND_NOT_BLK@@
    A "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.read.mc.modeAUTO;
    @@CHILDCOMMANDSTATEMENT@@
    JCN _pCMD_@@CHILDPARAMETERALIAS@@;
    L #p.command.@@CHILDPARAMETERALIAS@@_CMD;
    T "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.write.mc.CMD;
    T #childReqCMD.@@CHILDPARAMETERALIAS@@;
_pCMD_@@CHILDPARAMETERALIAS@@:   NOP 0;

@@ATTR_END|CHILD_COMMAND_NOT_BLK@@
@@ATTR_END|CHILD_COMMAND_EXISTS@@

    //------------------------------------------------------------------------//
    // Write the child parameters if no child mismatch:                       //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|CHILD_COMMAND@@
    A "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.read.mc.modeAUTO;
    @@CHILDCOMMANDSTATEMENT@@
    JCN _pPARAMETER_@@CHILDPARAMETERALIAS@@;
@@ATTR_BEGIN|pSFCChildWriteDefineAlias@@
    L #p.command.@@BLOCKPARAMETER@@;
    T "idb@@CHILDPARAMETERCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.@@OPERATION@@.@@CHILDPARAMETERATTRIBUTE@@;
@@ATTR_END|pSFCChildWriteDefineAlias@@
@@ATTR_BEGIN|pSFCChildWriteBoolDefineAlias@@
    A #p.command.@@BLOCKPARAMETER@@;
    = "idb@@CHILDPARAMETERCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.@@OPERATION@@.@@CHILDPARAMETERATTRIBUTE@@;
@@ATTR_END|pSFCChildWriteBoolDefineAlias@@
_pPARAMETER_@@CHILDPARAMETERALIAS@@:   NOP 0;


@@ATTR_END|CHILD_COMMAND@@

_noCommandOnChildMismatch:   NOP 0;

@@ATTR_BEGIN|SFC@@
NETWORK
TITLE = CALL SFC @@SFC@@ if @@STATE@@ running
    //------------------------------------------------------------------------//
    // SFC CALL   SFC CALL   SFC CALL   SFC CALL   SFC CALL   SFC CALL   SFC  //
    //                                                                        //
    // Call the SFC function if this is the running substate. This has to be  //
    // called even if the block is not running so the SFC can process all     //
    // commmands:                                                             //
    //------------------------------------------------------------------------//
    A #subsRunning.@@STATE@@;
    JCN _notSFC_@@COUNTERATTR|1@@_@@STATE@@;
    CALL #@@SFC@@
    (
@@ATTR_BEGIN|pSFCParametersBlock@@
        @@CHILDPARAMETER@@   := #p.@@OPERATION@@.@@BLOCKPARAMETER@@ ,
@@ATTR_END|pSFCParametersBlock@@
@@ATTR_BEGIN|pSFCLink@@
        @@CHILDPARAMETER@@   := "idb@@CHILDPARAMETERCLASS@@".f[#p.link.@@CHILDPARAMETERALIAS@@].p.@@OPERATION@@.@@CHILDPARAMETERATTRIBUTE@@ ,
@@ATTR_END|pSFCLink@@
@@ATTR_BEGIN|pSFCChildMCRead@@
        @@CHILDPARAMETER@@   := "idb@@CHILDPARAMETERCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.@@OPERATION@@.mc.@@CHILDPARAMETERATTRIBUTE@@ ,
@@ATTR_END|pSFCChildMCRead@@
@@ATTR_BEGIN|pSFCChildMCWrite@@
        @@CHILDPARAMETER@@   := #p.command.@@BLOCKPARAMETER@@ ,
@@ATTR_END|pSFCChildMCWrite@@
@@ATTR_BEGIN|pSFCChildMCWriteHygiene@@
        @@CHILDPARAMETER@@   := "idb@@CHILDPARAMETERCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.@@OPERATION@@.mc.@@CHILDPARAMETERATTRIBUTE@@ ,
@@ATTR_END|pSFCChildMCWriteHygiene@@
@@ATTR_BEGIN|pSFCChildRead@@
        @@CHILDPARAMETER@@   := "idb@@CHILDPARAMETERCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.@@OPERATION@@.@@CHILDPARAMETERATTRIBUTE@@ ,
@@ATTR_END|pSFCChildRead@@
@@ATTR_BEGIN|pSFCChildWrite@@
        @@CHILDPARAMETER@@   := #p.command.@@BLOCKPARAMETER@@ ,
@@ATTR_END|pSFCChildWrite@@
@@ATTR_BEGIN|pSFCChildWriteBool@@
        @@CHILDPARAMETER@@   := #p.write.@@BLOCKPARAMETER@@ ,
@@ATTR_END|pSFCChildWriteBool@@
@@ATTR_BEGIN|pSFCSelectMCRead@@
        @@CHILDPARAMETER@@   := "idb@@CHILDPARAMETERCLASS@@".f[#p.select.@@CHILDPARAMETERALIAS@@].p.@@OPERATION@@.mc.@@CHILDPARAMETERATTRIBUTE@@ ,
@@ATTR_END|pSFCSelectMCRead@@
@@ATTR_BEGIN|pSFCSelectMCWrite@@
        @@CHILDPARAMETER@@   := #p.select.@@BLOCKPARAMETER@@ ,
@@ATTR_END|pSFCSelectMCWrite@@
@@ATTR_BEGIN|pSFCSelectMCWriteHygiene@@
        @@CHILDPARAMETER@@   := "idb@@CHILDPARAMETERCLASS@@".f[#p.select.@@CHILDPARAMETERALIAS@@].p.@@OPERATION@@.mc.@@CHILDPARAMETERATTRIBUTE@@ ,
@@ATTR_END|pSFCSelectMCWriteHygiene@@
@@ATTR_BEGIN|pParentSync@@
        @@CHILDPARAMETER@@   := "idb@@CHILDPARAMETERCLASS@@".f[#p.select.@@CHILDPARAMETERALIAS@@].p.@@OPERATION@@.@@CHILDPARAMETERATTRIBUTE@@ ,
@@ATTR_END|pParentSync@@
        dummy                := #dummy
    );
_notSFC_@@COUNTERATTR@@_@@STATE@@:   NOP 0;

@@ATTR_END|SFC@@

@@ATTR_BEGIN|CHILD_COMMAND_FLOWPATH_EXISTS@@
NETWORK
TITLE = Check if any Child state does not match the command
    //------------------------------------------------------------------------//
    // Check if any child flowpath device state does not match the command    //
    // from this parent block if the child state grace period timer has       //
    // expired. Stop checking if the first child state mismatch found:        //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|CHILD_COMMAND_FLOWPATH_ALL@@
    @@CHILDCOMMANDSTATEMENT@@
    A "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.write.mc.ARMED;
    A(;
    L "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.read.mc.STATE;
    L #childReqCMD.@@CHILDPARAMETERALIAS@@;
    <>I;
    );
@@ATTR_BEGIN|CHILD_COMMAND_BLK_EXISTS@@
    A(;
    L "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.read.mc.STATE;
    L "dbCONST".BLK.STATE.COMPLETED;
    <>I;
    );
    AN(;
    A(;
    L "dbCONST".BLK.CMD.START;
    L #childReqCMD.@@CHILDPARAMETERALIAS@@;
    ==I;
    );
    A(;
    L "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.read.mc.STATE;
    L "idb@@CHILDALIASCLASS@@".f[#p.child.@@CHILDPARAMETERALIAS@@].p.write.mc.SUBS;
    ==I;
    );
    );
@@ATTR_END|CHILD_COMMAND_BLK_EXISTS@@
    = #p.child.err@@CHILDPARAMETERALIAS@@;


@@ATTR_END|CHILD_COMMAND_FLOWPATH_ALL@@
@@ATTR_END|CHILD_COMMAND_FLOWPATH_EXISTS@@

NETWORK
TITLE = Flag child mismatch if any Child state does not match the command
    //------------------------------------------------------------------------//
    // CHILD FLOWPATH STATE MISMATCH   CHILD FLOWPATH STATE MISMATCH   CHILD  //
    //                                                                        //
    // Check if any child mismatch:                                           //
    //------------------------------------------------------------------------//
    CLR;
@@ATTR_BEGIN|CHILD_COMMAND_FLOWPATH_EXISTS@@
@@ATTR_BEGIN|CHILD_COMMAND_FLOWPATH_ALWAYS@@
    O #p.child.err@@CHILDPARAMETERALIAS@@;
@@ATTR_END|CHILD_COMMAND_FLOWPATH_ALWAYS@@
@@ATTR_BEGIN|CHILD_COMMAND_FLOWPATH@@
    O(;
    @@CHILDCOMMANDSTATEMENT@@
    A #p.child.err@@CHILDPARAMETERALIAS@@;
    );
@@ATTR_END|CHILD_COMMAND_FLOWPATH@@
@@ATTR_END|CHILD_COMMAND_FLOWPATH_EXISTS@@
    JCN _noMismatch;

    S #p.read.bmc.flags.childMismatch;
    JC _noResetMismatch;

_noMismatch:   NOP 0;
    R #p.read.bmc.flags.childMismatch;
    R #p.read.mc.INTIL;

_noResetMismatch:   NOP 0;

NETWORK
TITLE = If child command changed, start timer to wait for child state
    //------------------------------------------------------------------------//
    // CHILD STATE TIMER   CHILD STATE TIMER   CHILD STATE TIMER   CHILD STAT //
    //                                                                        //
    // If any child command changed then start a timer to provide a grace     //
    // period to allow the child device state to match the command (e.g. to   //
    // allow a valve to move from closed to opened position).                 //
    // Start the child state check timer if a command changed:                //
    //------------------------------------------------------------------------//
    CALL #timeCheckChildState
    {time_type := 'Time'}
    (   IN                          := #p.read.bmc.flags.childMismatch ,
        PT                          := #p.read.bmc.transTime ,
        Q                           := #timeCheckChildStateExpired ,
        ET                          := #timeCheckChildStateElapsed
    );
    NOP 0;

NETWORK
TITLE = Pack the general block alarm bits
    //------------------------------------------------------------------------//
    // Pack the alarm bits into an integer for the HMI to read:               //
    // Alarms are arranged in the following Little Endian order...            //
    // Word   1                                0                              //
    // Bit    0   1   2   3   4   5   6   7    8   9  10  11  12  13  14  15  //
    // Order  9  10  11  12  13  14  15  16    1   2   3   4   5   6   7   8  //
    //------------------------------------------------------------------------//
//    A #p.read.err.childInterlock;
//    = #b[8];
    A #p.read.err.childMismatch;
    = #b[9];
//    A #p.read.err.childSafeState;
//    = #b[10];
    A #p.read.err.childUnavailable;
    = #b[11];
    A #p.read.err.permitStart;
    = #b[12];
    L #w;
    T #p.read.mc.ALARM;

@@ATTR_BEGIN|pEventConfirmNoExists@@
NETWORK
TITLE = Pack the prompt event confirm No message event alarm bits
    //------------------------------------------------------------------------//
    // Pack the eventPrompt confirm No alarm bits into an integer for the     //
    // HMI to read:                                                           //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|pEventConfirmNoWordClass@@
    L #wEventConfirmNo[@@CWORD@@];
    T #p.read.eventConfirmNo_@@CWORD@@;
@@ATTR_END|pEventConfirmNoWordClass@@
@@ATTR_END|pEventConfirmNoExists@@

@@ATTR_BEGIN|pEventConfirmYesExists@@
NETWORK
TITLE = Pack the prompt event confirm Yes message event alarm bits
    //------------------------------------------------------------------------//
    // Pack the eventPrompt confirm Yes alarm bits into an integer for the    //
    // HMI to read:                                                           //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|pEventConfirmYesWordClass@@
    L #wEventConfirmYes[@@CWORD@@];
    T #p.read.eventConfirmYes_@@CWORD@@;
@@ATTR_END|pEventConfirmYesWordClass@@
@@ATTR_END|pEventConfirmYesExists@@

@@ATTR_BEGIN|pEventLogMsgExists@@
NETWORK
TITLE = Pack the log message event alarm bits
    //------------------------------------------------------------------------//
    // Pack the eventLogMsg alarm bits into an integer for the HMI to read:   //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|pEventLogMsgWordClass@@
    L #wEventLogMsg[@@CWORD@@];
    T #p.read.eventLogMsg_@@CWORD@@;
@@ATTR_END|pEventLogMsgWordClass@@
@@ATTR_END|pEventLogMsgExists@@

@@ATTR_BEGIN|pEventLogRealExists@@
NETWORK
TITLE = Pack the log real data event alarm bits
    //------------------------------------------------------------------------//
    // Pack the eventLogReal alarm bits into an integer for the HMI to read:  //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|pEventLogRealWordClass@@
    L #wEventLogReal[@@CWORD@@];
    T #p.read.eventLogReal_@@CWORD@@;
@@ATTR_END|pEventLogRealWordClass@@
@@ATTR_END|pEventLogRealExists@@

@@ATTR_BEGIN|pEventLogTimeExists@@
NETWORK
TITLE = Pack the log time data event alarm bits
    //------------------------------------------------------------------------//
    // Pack the eventLogTime alarm bits into an integer for the HMI to read:  //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|pEventLogTimeWordClass@@
    L #wEventLogTime[@@CWORD@@];
    T #p.read.eventLogTime_@@CWORD@@;
@@ATTR_END|pEventLogTimeWordClass@@
@@ATTR_END|pEventLogTimeExists@@

@@TEMPLATE_END@@
END_FUNCTION_BLOCK
