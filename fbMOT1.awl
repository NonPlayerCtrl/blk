//----------------------------------------------------------------------------//
//            Copyright 2018 Rieckermann Engineering Operations               //
//----------------------------------------------------------------------------//
// Class:       fbMOT1                                                        //
// Description:                                                               //
// Vacuum Pump control.                                                       //
//----------------------------------------------------------------------------//
// Revision history:                                                          //
// Rev By               Date        CC        Note                            //
// 2.0 David Paspa      30-Jan-2018 NA        Reboot for S7-1500.             //
// 1.0 Gerald Kontriner 09-Oct-2009 CC-09/016 MON_MISMATCH Logic.             //
// 0.9 Mr. Khoon        01-Oct-2009 CC-09/016 Mode=Initialized.               //
// 0.8 Steve Linehan    30-Sep-2009 CC-09/016 Out of Service Mode Added.      //
// 0.7 Steve Linehan    29-Sep-2009 CC-09/016 Bypass Input Mode Added.        //
// 0.6 Khairul Basar    22-Sep-2009 CC-09/016 Nw3,FAULT_S remove.             //
// 0.5 Khairul Basar    17-Sep-2009 CC-09/016 Instead of Auto/Man dual command//
//                                            only CMD used now.              //
// 0.4 Khairul Basar    11-Sep-2009 CC-09/016 FAULT_S reset after Out_Q is off//
// 0.3 Khairul Basar    11-Sep-2009 CC-09/016 INTERLOCK is now o/p instead of //
//                                            temporary flag.                 //
// 0.3 Khairul Basar    09-Sep-2009 CC-09/016 Ref2.                           //
// 0.2 Khairul Basar    31-Aug-2009 CC-09/016 Ref1.                           //
// 0.1 Khairul Basar    03-Aug-2009           Initial design.                 //
//                                                                            //
// Ref2:Instead of using one timer, another timer is created.One timer will   //
// start when there is Start command , another will start when Stop command.  //
// And there is FAULT_S which will be setting, so operator acknowledge signal //
// must reset that flag, to be able restart the MOT1 again.Start and Stop     //
// command divided into two networks, NW2 & 3.                                //
//                                                                            //
// Ref1.                                                                      //
// STOPPED & RUNNING states are changed to 1 & 2 respectively while previously//
// it was 2 & 1. Timer start signal is paralleled with start & Stop flag,     //
// every transition of run to stop or stop to run the timer should start.     //
// Previously it the start flag was duplicated twice. Now Fault state can be  //
// verified, Previously FAULT_S & FAULT_O was not assigned.                   //
// Name of parameter DELAY_TIME is changed to TMR.                            //
// Initial value in code is changed from 10S to 3S.                           //
// Now Alarm Tag names are corrected, Logic is assigned for them.             //
//----------------------------------------------------------------------------//
FUNCTION_BLOCK "fbMOT1"
TITLE = MOT1 : Vacuum Pump Control
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : REO
NAME : fbMOT1
VERSION : 2.0

//----------------------------------------------------------------------------//
// Declare interface and variables:                                           //
//----------------------------------------------------------------------------//
VAR
    p : "udtMOT1";           // Block data interface
END_VAR

VAR
    startTMR {ReadalPartName := 'TON'; LibVersion := '1.0'} : TON;   // Motor Start/Stop Transition timer
    stopTMR {ReadalPartName := 'TON'; LibVersion := '1.0'} : TON;
END_VAR

VAR DB_SPECIFIC
    b { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..15] of Bool;
    w { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} AT b : Word;
END_VAR

VAR_TEMP
    cmdStart : Bool;
    cmdStop : Bool;
    enableStartTimer : Bool;
    enableStopTimer : Bool;
    tDO : Bool;              // Flag indicating whether to drive output
    tFault: Bool;
    TMR : Time := T#3S;      // Motor Start/Stop transition time for checking status
    startTMRElapsed : Time;
    stopTMRElapsed : Time;
    startTMRExpired : Bool;
    stopTMRExpired : Bool;
END_VAR

BEGIN
NETWORK
TITLE = Call Mode and Command handling block
    //------------------------------------------------------------------------//
    // COMMAND PROCESSOR   COMMAND PROCESSOR   COMMAND PROCESSOR   COMMAND    //
    //                                                                        //
    // Process the standard block functions for command, mode, interlock and  //
    // state:                                                                 //
    //------------------------------------------------------------------------//
    CALL "fcModeCmd"
    (   mcRead             := #p.read.mc ,
        mcWrite              := #p.write.mc
    );

NETWORK
TITLE = Start command
    //------------------------------------------------------------------------//
    // COMMAND   COMMAND   COMMAND   COMMAND   COMMAND   COMMAND   COMMAND    //
    // COMMAND   COMMAND   COMMAND   COMMAND   COMMAND   COMMAND   COMMAND    //
    //                                                                        //
    // CMD is START:                                                          //
    //------------------------------------------------------------------------//
    A(;
    L #p.write.mc.CMD;
    L "dbCONST".BLK.MOT1.CMD.START;
    ==I;
    );
    =#cmdStart;

NETWORK
TITLE = Stop command
    //------------------------------------------------------------------------//
    // CMD is STOP:                                                           //
    //------------------------------------------------------------------------//
    A(;
    L #p.write.mc.CMD;
    L "dbCONST".BLK.MOT1.CMD.STOP;
    ==I;
    );
    = #cmdStop

NETWORK
TITLE = Motor faults and three phase relay alarm
    //------------------------------------------------------------------------//
    // INPUTS   INPUTS   INPUTS   INPUTS   INPUTS   INPUTS   INPUTS   INPUTS  //
    // INPUTS   INPUTS   INPUTS   INPUTS   INPUTS   INPUTS   INPUTS   INPUTS  //
    // MOTOR FAULTS                                                           //
    // Raise alarm if any motor control fault condition is active:            //
    //------------------------------------------------------------------------//
    A #p.read.PHR;
    = #p.read.ALM_PHR;

NETWORK
TITLE = Motor breaker fault
    A #p.read.BRK;
    = #p.read.ALM_BRK;
    = #p.read.mc.ERROR;

NETWORK
TITLE = Interlock if any field fault
    //------------------------------------------------------------------------//
    // Include motor field faults in the interlock calculation:
    //------------------------------------------------------------------------//
    O #p.read.mc.INTERLOCK;
    O #p.read.BRK;
    O #p.read.PHR;
    = #p.read.mc.INTERLOCK;

NETWORK
TITLE = Start comand allowable if no fault conditions or OOS
    //------------------------------------------------------------------------//
    // Allow start if no interlock or OOS mode:                               //
    //------------------------------------------------------------------------//
    A cmdStart;
    AN #p.read.mc.modeOOS;
    AN #p.read.mc.INTERLOCK;
    = cmdStart;

    //------------------------------------------------------------------------//
    // OUTPUTS   OUTPUTS   OUTPUTS   OUTPUTS   OUTPUTS   OUTPUTS   OUTPUTS    //
    // OUTPUTS   OUTPUTS   OUTPUTS   OUTPUTS   OUTPUTS   OUTPUTS   OUTPUTS    //
    //                                                                        //
    // Set the output on if start selected and allowable:                     //
    //------------------------------------------------------------------------//
    A cmdStart;
    = #p.read.OUT_Q;
    = #tDO;

NETWORK
TITLE = Start Timer to wait for running feedback
    //------------------------------------------------------------------------//
    // Start timer to allow time for running feedback to come on:             //
    //------------------------------------------------------------------------//
    A #cmdStart;
    = #enableStartTimer;

NETWORK
TITLE = Stop Timer to wait for running feedback to go off
    //------------------------------------------------------------------------//
    // Stop timer to allow time for running feedback to go off:               //
    //------------------------------------------------------------------------//
    AN #tDO;
    = #enableStopTimer;

NETWORK
TITLE = Start Transition Timer in the event of Start or Stop
    //------------------------------------------------------------------------//
    // Start the starting timer if START command issued:                      //
    //------------------------------------------------------------------------//
    CALL #startTMR
    {time_type := 'Time'}
    (   IN                   := #enableStartTimer ,
        PT                   := #TMR ,
        Q                    := #startTMRExpired ,
        ET                   := #startTMRElapsed
    );
    NOP 0;

NETWORK
TITLE = Stop Transition Timer in the event of Start or Stop
    //------------------------------------------------------------------------//
    // Start the stopping timer if START command issued not issued:           //
    //------------------------------------------------------------------------//
    CALL #stopTMR
    {time_type := 'Time'}
    (   IN                   := #enableStopTimer ,
        PT                   := #TMR ,
        Q                    := #stopTMRExpired ,
        ET                   := #stopTMRElapsed
    );
    NOP 0;

NETWORK
TITLE = Device State RUNNING if running feedback on or bypass
    //------------------------------------------------------------------------//
    // STATE   STATE   STATE   STATE   STATE   STATE   STATE   STATE   STATE  //
    // STATE   STATE   STATE   STATE   STATE   STATE   STATE   STATE   STATE  //
    //                                                                        //
    // STOPPED if output off and not running:                                 //
    //------------------------------------------------------------------------//
    AN #cmdStart;
    AN #tDO;
    AN #p.read.FB_RUN;
    JCN _a;
    L "dbCONST".BLK.MOT1.STATE.STOPPED;
    T #p.read.mc.STATE;
_a:   NOP 0;

    //------------------------------------------------------------------------//
    // RUNNING if output is on with running feedback or bypass:               //
    //------------------------------------------------------------------------//
    A #cmdStart;
    A #tDO;
    A #p.read.FB_RUN;
    AN #p.read.FAIL_START;
    JCN _b;
    L "dbCONST".BLK.MOT1.STATE.RUNNING;
    T #p.read.mc.STATE;
_b:   NOP 0;

NETWORK
TITLE = Device State transition if waiting for running or stopped
    //------------------------------------------------------------------------//
    // Transition state if output is on and waiting for running feedback to   //
    // come on or output is off and waiting for running feedback to go off:   //
    //------------------------------------------------------------------------//
    O(;
    A #tDO;
    AN #startTMR.Q;
    AN #p.read.FB_RUN;
    );
    O(;
    AN #tDO;
    AN #stopTMR.Q;
    A #p.read.FB_RUN;
    );
    JCN _c;
    L "dbCONST".BLK.MOT1.STATE.STARTING_STOPPING;
    T #p.read.mc.STATE;
_c:   NOP 0;

NETWORK
TITLE = Device State FAULT if timed out waiting for running
    //------------------------------------------------------------------------//
    // Fault if starting timer expired and not running:                       //
    //------------------------------------------------------------------------//
    A #tDO;
    A #startTMR.Q;
    AN #p.read.FB_RUN;
    = #p.read.FAIL_START;
    = #tFault;

NETWORK
TITLE = Device State FAULT also if timed out waiting for stopped
    //------------------------------------------------------------------------//
    // Fault if stopping timer expired and not stopped:                       //
    //------------------------------------------------------------------------//
    O #tFault;
    O(;
    AN #tDO;
    A #stopTMR.Q;
    A #p.read.FB_RUN;
    );
    = #tFault;
    = #p.read.mc.ERROR;

NETWORK
TITLE = Set State FAULT if any fault condition
    //------------------------------------------------------------------------//
    // Fault if starting timer expired and not running:                       //
    //------------------------------------------------------------------------//
    A #tFault;
    JCN _d;
    L "dbCONST".BLK.MOT1.STATE.FAULT;
    T #p.read.mc.STATE;
_d:   NOP 0;

NETWORK
TITLE = Pack the alarm bits
    //------------------------------------------------------------------------//
    // Pack the alarm bits into an integer for the HMI to read:               //
    //------------------------------------------------------------------------//
    A #p.read.ALM_BRK;
    = #b[0];
    A #p.read.ALM_PHR;
    = #b[1];
    A #p.read.FAIL_START;
    = #b[2];
    L #w;
    T #p.read.mc.ALARM;

END_FUNCTION_BLOCK
