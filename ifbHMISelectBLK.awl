//----------------------------------------------------------------------------//
//            Copyright 2018 Rieckermann Engineering Operations               //
//                Automatically Generated File - Do Not Edit                  //
//----------------------------------------------------------------------------//
// Description: Handles the HMI interface for operator control of each BLK.   //
//              The interface block is used for read only.                    //
//----------------------------------------------------------------------------//
// Revision history:                                                          //
// Rev By               Date        CC        Note                            //
// 2.0 David Paspa      03-Aug-2018 NA        Reboot for S7-1500.             //
// 0.1 Khairul Basar    05-Oct-2009 NA        Inital Design.                  //
//----------------------------------------------------------------------------//
FUNCTION_BLOCK "ifbHMISelectBLK"
TITLE = BLK Selection
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : REO
NAME : ifbHMISelectBLK
VERSION : 2.0

//----------------------------------------------------------------------------//
// Declare local variables:                                                   //
//----------------------------------------------------------------------------//
VAR
    CTR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Counter
END_VAR

VAR_TEMP
    blockSelected : Int;
    arrChildIndex : Array[0..50] of Int;
    retVal : Int;
END_VAR

BEGIN
NETWORK
TITLE = Increment the counter
    //------------------------------------------------------------------------//
    // Increment the HMI number counter:                                      //
    //------------------------------------------------------------------------//
    L #CTR;
    INC 1;
    T #CTR;

NETWORK
TITLE = Get the selected BLK for HMI 1
    //------------------------------------------------------------------------//
    // Get the BLK index number selected by the user when they clicked the    //
    // faceplate BLK target:                                                  //
    //------------------------------------------------------------------------//
    A(;
    L #CTR;
    L 1;
    ==I;
    );
    JCN _notHMI1;
    L "dbHMISelect".BLK.hmi1Select;
    T #blockSelected;
_notHMI1:   NOP 0;

NETWORK
TITLE = Get the selected BLK for HMI 2
    //------------------------------------------------------------------------//
    // Get the BLK index number selected by the user when they clicked the    //
    // faceplate BLK target:                                                  //
    //------------------------------------------------------------------------//
    A(;
    L #CTR;
    L 2;
    ==I;
    );
    JCN _notHMI2;
    L "dbHMISelect".BLK.hmi2Select;
    T #blockSelected;
_notHMI2:   NOP 0;

NETWORK
TITLE = Get the selected BLK for HMI 3
    //------------------------------------------------------------------------//
    // Get the BLK index number selected by the user when they clicked the    //
    // faceplate BLK target:                                                  //
    //------------------------------------------------------------------------//
    A(;
    L #CTR;
    L 3;
    ==I;
    );
    JCN _notHMI3;
    L "dbHMISelect".BLK.hmi3Select;
    T #blockSelected;
_notHMI3:   NOP 0;

NETWORK
TITLE = Get the selected BLK for HMI 4
    //------------------------------------------------------------------------//
    // Get the BLK index number selected by the user when they clicked the    //
    // faceplate BLK target:                                                  //
    //------------------------------------------------------------------------//
    A(;
    L #CTR;
    L 4;
    ==I;
    );
    JCN _notHMI4;
    L "dbHMISelect".BLK.hmi4Select;
    T #blockSelected;
_notHMI4:   NOP 0;

NETWORK
TITLE = Get the selected BLK for HMI 5
    //------------------------------------------------------------------------//
    // Get the BLK index number selected by the user when they clicked the    //
    // faceplate BLK target:                                                  //
    //------------------------------------------------------------------------//
    A(;
    L #CTR;
    L 5;
    ==I;
    );
    JCN _notHMI5;
    L "dbHMISelect".BLK.hmi5Select;
    T #blockSelected;
_notHMI5:   NOP 0;

@@TEMPLATE_BEGIN|INSTANCE_BLK@@
NETWORK
TITLE = @@INSTANCE@@ @@DESCRIPTION@@
    //------------------------------------------------------------------------//
    // Check if this BLK instance is selected:                                //
    //------------------------------------------------------------------------//
    A(;
    L #blockSelected;
    L 1@@ID@@;
    ==I;
    );
    JCN _not_@@INSTANCE@@;

    CALL "fcHMIInterfaceBLK"
    (   bmc                  := "idb@@CLASS@@".f[@@IDX@@].p.read.bmc ,
        err                  := "idb@@CLASS@@".f[@@IDX@@].p.read.err ,
        mcr                  := "idb@@CLASS@@".f[@@IDX@@].p.read.mc ,
        mcw                  := "idb@@CLASS@@".f[@@IDX@@].p.write.mc
    );

NETWORK
TITLE = Transfer the child state values and errors to the read only interface array
    //------------------------------------------------------------------------//
    // Transfer the child states and if they have any error condition:        //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|CHILD_INSTANCE@@
    L @@CHILDIDX@@;          // @@CHILDPARAMETERALIAS@@ @@CHILDCLASS@@
    T #arrChildIndex[@@COUNTERATTR|1@@];
@@ATTR_END|CHILD_INSTANCE@@
@@ATTR_BEGIN|CHILD_INSTANCE@@
    L "idb@@CHILDALIASCLASS@@".f[arrChildIndex[@@COUNTERATTR|1@@]].p.read.mc.STATE;
    T "dbHMIInterfaceBLK".buffer.block.arrChildState[@@COUNTERATTR@@];
    A "idb@@CHILDALIASCLASS@@".f[arrChildIndex[@@COUNTERATTR@@]].p.read.mc.ERROR;
    = "dbHMIInterfaceBLK".buffer.block.arrChildError[@@COUNTERATTR@@];
    A "idb@@CHILDALIASCLASS@@".f[arrChildIndex[@@COUNTERATTR@@]].p.read.mc.INTERLOCK;
    = "dbHMIInterfaceBLK".buffer.block.arrChildInterlock[@@COUNTERATTR@@];
@@ATTR_END|CHILD_INSTANCE@@

NETWORK
TITLE = Transfer the parameter values to the read only interface arrays
    //------------------------------------------------------------------------//
    // Transfer the parameter values:                                         //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|pInterfaceBool@@
    A "idb@@CLASS@@".f[@@IDX@@].p.@@OPERATION@@.@@BLOCKPARAMETER@@;
    = "dbHMIInterfaceBLK".buffer.block.arrBool[@@COUNTERATTR|1@@];
@@ATTR_END|pInterfaceBool@@
@@ATTR_BEGIN|pInterfaceInt@@
    L "idb@@CLASS@@".f[@@IDX@@].p.@@OPERATION@@.@@BLOCKPARAMETER@@;
    T "dbHMIInterfaceBLK".buffer.block.arrInt[@@COUNTERATTR|1@@];
@@ATTR_END|pInterfaceInt@@
@@ATTR_BEGIN|pInterfaceReal@@
    L "idb@@CLASS@@".f[@@IDX@@].p.@@OPERATION@@.@@BLOCKPARAMETER@@;
    T "dbHMIInterfaceBLK".buffer.block.arrReal[@@COUNTERATTR|1@@];
@@ATTR_END|pInterfaceReal@@
@@ATTR_BEGIN|pInterfaceTime@@
    L "idb@@CLASS@@".f[@@IDX@@].p.@@OPERATION@@.@@BLOCKPARAMETER@@;
    T "dbHMIInterfaceBLK".buffer.block.arrTime[@@COUNTERATTR|1@@];
@@ATTR_END|pInterfaceTime@@

_not_@@INSTANCE@@:   NOP 0;

@@TEMPLATE_END@@

NETWORK
TITLE = Copy the block structure back if HMI 1
    //------------------------------------------------------------------------//
    // Copy the block structure:                                              //
    //------------------------------------------------------------------------//
    A(;
    L #CTR;
    L 1;
    ==I;
    );
    JCN _notMoveHMI1;
    CALL MOVE
    {value_type := 'Variant'}
    (   IN                   := "dbHMIInterfaceBLK".buffer ,
        OUT                  := "dbHMIInterfaceBLK".hmi1
    );
_notMoveHMI1:   NOP 0;

NETWORK
TITLE = Copy the block structure back if HMI 2
    //------------------------------------------------------------------------//
    // Copy the block structure:                                              //
    //------------------------------------------------------------------------//
    A(;
    L #CTR;
    L 2;
    ==I;
    );
    JCN _notMoveHMI2;
    CALL MOVE
    {value_type := 'Variant'}
    (   IN                   := "dbHMIInterfaceBLK".buffer ,
        OUT                  := "dbHMIInterfaceBLK".hmi2
    );
_notMoveHMI2:   NOP 0;

NETWORK
TITLE = Copy the block structure back if HMI 3
    //------------------------------------------------------------------------//
    // Copy the block structure:                                              //
    //------------------------------------------------------------------------//
    A(;
    L #CTR;
    L 3;
    ==I;
    );
    JCN _notMoveHMI3;
    CALL MOVE
    {value_type := 'Variant'}
    (   IN                   := "dbHMIInterfaceBLK".buffer ,
        OUT                  := "dbHMIInterfaceBLK".hmi3
    );
_notMoveHMI3:   NOP 0;

NETWORK
TITLE = Copy the block structure back if HMI 4
    //------------------------------------------------------------------------//
    // Copy the block structure:                                              //
    //------------------------------------------------------------------------//
    A(;
    L #CTR;
    L 4;
    ==I;
    );
    JCN _notMoveHMI4;
    CALL MOVE
    {value_type := 'Variant'}
    (   IN                   := "dbHMIInterfaceBLK".buffer ,
        OUT                  := "dbHMIInterfaceBLK".hmi4
    );
_notMoveHMI4:   NOP 0;

NETWORK
TITLE = Copy the block structure back if HMI 5
    //------------------------------------------------------------------------//
    // Copy the block structure:                                              //
    //------------------------------------------------------------------------//
    A(;
    L #CTR;
    L 5;
    ==I;
    );
    JCN _notMoveHMI5;
    CALL MOVE
    {value_type := 'Variant'}
    (   IN                   := "dbHMIInterfaceBLK".buffer ,
        OUT                  := "dbHMIInterfaceBLK".hmi5
    );
_notMoveHMI5:   NOP 0;

NETWORK
TITLE = Reset the HMI counter if all done
    //------------------------------------------------------------------------//
    // Reset the counter:                                                     //
    //------------------------------------------------------------------------//
    A(;
    L #CTR;
    L 4;
    >I;
    );
    JCN _countComplete;
    L 0;
    T #CTR;
_countComplete:   NOP 0;

END_FUNCTION_BLOCK
