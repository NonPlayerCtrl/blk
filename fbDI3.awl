//----------------------------------------------------------------------------//
//            Copyright 2018 Rieckermann Engineering Operations               //
//----------------------------------------------------------------------------//
// Class:       fbDI3                                                         //
// Description:                                                               //
// General alarm single digital input.                                        //
//----------------------------------------------------------------------------//
// Revision history:                                                          //
// Rev By               Date        CC        Note                            //
// 1.0 David Paspa      17-Apr-2018 NA        Initial design from DI1.        //
//----------------------------------------------------------------------------//
FUNCTION_BLOCK "fbDI3"
TITLE = DI3 : General alarm with software input
{ S7_Optimized_Access := 'TRUE' }
NAME : fbDI3
AUTHOR : REO
VERSION : 1.0

//----------------------------------------------------------------------------//
// Declare variables:                                                         //
//----------------------------------------------------------------------------//
VAR
    p : "udtDI3";            // Block data interface
END_VAR

VAR DB_SPECIFIC
    b { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..15] of Bool;
    w { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} AT b : Word;
END_VAR

VAR_TEMP
    tPV : Bool;              // Temporary processed DI signal
END_VAR

BEGIN
NETWORK
TITLE = Call Mode and Command handling function
    //------------------------------------------------------------------------//
    // MODE AND COMMAND   MODE AND COMMAND   MODE AND COMMAND   MODE AND COMM //
    // MODE AND COMMAND   MODE AND COMMAND   MODE AND COMMAND   MODE AND COMM //
    //                                                                        //
    // Process the standard block functions for command, mode, interlock and  //
    // state:                                                                 //
    //------------------------------------------------------------------------//
    CALL "fcModeCmd"
    (   cmdSafe              := "dbCONST".BLK.DI3.SAFE.CMD ,
        mcRead               := #p.read.mc ,
        mcWrite              := #p.write.mc
    );

NETWORK
TITLE = Process user command
    //------------------------------------------------------------------------//
    // COMMAND   COMMAND   COMMAND   COMMAND   COMMAND   COMMAND   COMMAND    //
    // COMMAND   COMMAND   COMMAND   COMMAND   COMMAND   COMMAND   COMMAND    //
    //                                                                        //
    // Enable command:                                                        //
    //------------------------------------------------------------------------//
    AN #p.read.mc.modeOOS;
    A(;
    L #p.write.mc.CMD;
    L "dbCONST".BLK.DI3.CMD.ENABLE;
    ==I;
    );
    JCN _a;
    R #tPV;
    R #p.read.ALARM;
_a:   NOP 0;

    //------------------------------------------------------------------------//
    // Calculate the process value based on the user command:                 //
    //------------------------------------------------------------------------//
    AN #p.read.mc.modeOOS;
    A(;
    L #p.write.mc.CMD;
    L "dbCONST".BLK.DI3.CMD.PAUSE;
    ==I;
    );
    JCN _b;
    S #tPV;
    S #p.read.ALARM;
_b:   NOP 0;

NETWORK
TITLE = Set INTERLOCK Flag
    //------------------------------------------------------------------------//
    // INTERLOCK   INTERLOCK   INTERLOCK   INTERLOCK   INTERLOCK   INTERLOCK  //
    // INTERLOCK   INTERLOCK   INTERLOCK   INTERLOCK   INTERLOCK   INTERLOCK  //
    //                                                                        //
    // Set interlocks:                                                        //
    //------------------------------------------------------------------------//
    A #tPV;
    = #p.read.mc.INTIL;

NETWORK
TITLE = Set Device State to follow Command
    //------------------------------------------------------------------------//
    // STATE   STATE   STATE   STATE   STATE   STATE   STATE   STATE   STATE  //
    // STATE   STATE   STATE   STATE   STATE   STATE   STATE   STATE   STATE  //
    //                                                                        //
    // State just follows the command:                                        //
    //------------------------------------------------------------------------//
    L #p.write.mc.CMD;
    T #p.read.mc.STATE;

NETWORK
TITLE = Pack the alarm bit
    //------------------------------------------------------------------------//
    // Pack the alarm bit into an integer for the HMI to read:                //
    // Alarms are arranged in the following Little Endian order...            //
    // Word   1                                0                              //
    // Bit    0   1   2   3   4   5   6   7    8   9  10  11  12  13  14  15  //
    // Order  9  10  11  12  13  14  15  16    1   2   3   4   5   6   7   8  //
    //------------------------------------------------------------------------//
    A #p.read.ALARM;
    = #b[8];
    L #w;
    T #p.read.mc.ALARM;

END_FUNCTION_BLOCK
