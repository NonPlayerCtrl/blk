//----------------------------------------------------------------------------//
//            Copyright 2018 Rieckermann Engineering Operations               //
//----------------------------------------------------------------------------//
// Description:                                                               //
// This file contains globally addressable event flags and data. The function //
// traverses the event datablock UDT structures to see if any event bits have //
// been raised. This is called each scan from the main program block OB1      //
// which therefore takes care of the looping required.                        //
//----------------------------------------------------------------------------//
// Revision history:                                                          //
// Rev By               Date        CC        Note                            //
// 2.0 David Paspa      16-May-2018 NA        Reboot design for S7-1500 not   //
//                                            using ALARM_D etc.              //
// 1.0 David Paspa      11-Apr-2018 NA        Initial design.                 //
//----------------------------------------------------------------------------//
FUNCTION "fcEventPrompt" : Void
TITLE = Event indexing function for SFC operator prompts on the HMI
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : REO
NAME : fcEventPrompt
VERSION : 2.0

//----------------------------------------------------------------------------//
// Declare variables which must retain their values between block calls:      //
//----------------------------------------------------------------------------//
VAR_IN_OUT
    eventElement : "udtEventPrompt";
    elementTerminationBit : Bool;
    elementCount : Int;                // Number of elements in the data block
    elementSize : Int;                 // Size of the entire data block
    scanCount : Int;
    blockSize : DWORD;                 // Size of an individual UDT element
END_VAR

//----------------------------------------------------------------------------//
// Declare temporary variables. The order of the first two is important to    //
// be able to measure the size of the UDT:                                    //
//----------------------------------------------------------------------------//
VAR_OUTPUT
END_VAR

VAR_TEMP
    almError : Bool;
    almStatus : Word
    edgeStart : Bool;
    raiseEvent : Bool;
    scanEnabled : Bool;
    scanStart : Bool;
    scComplete : Bool;
    scState : Bool;
    sRetval : Int;
    scRetval : Int;
END_VAR

BEGIN
NETWORK
TITLE = Check if request to start
    //------------------------------------------------------------------------//
    // Open the Event global data block and save the block length locally:    //
    //------------------------------------------------------------------------//
    A "enableEvents";
    = #scanEnabled;

NETWORK
TITLE = Check if starting up
    //------------------------------------------------------------------------//
    // Open the Event global data block and save the block length locally:    //
    //------------------------------------------------------------------------//
    A #scanEnabled;
    FP #edgeStart;
    = #scanStart;

NETWORK
TITLE = Open globally shared event DB if starting
    //------------------------------------------------------------------------//
    // Open the Event global data block if starting to scan:                  //
    //------------------------------------------------------------------------//
    A #scanStart;
    JCN _a;
    OPN "dbEVENTPrompt";
_a:   NOP 0;

NETWORK
TITLE = Get shared event DB size
    //------------------------------------------------------------------------//
    // Get the overall size of the shared event data block if starting:       //
    //------------------------------------------------------------------------//
    A #scanStart;
    JCN _b;
    L DBLG;
    T #blockSize;
_b:   NOP 0;

NETWORK
TITLE = Get the size of a single DB UDT element
    //------------------------------------------------------------------------//
    // Calculate the size of a single UDT element based on the size of the    //
    // temporary variables defined in this function:                          //
    //------------------------------------------------------------------------//
    A #scanStart;
    JCN _c;
    L P##elementTerminationBit;        // Pointer to the first element after the measured one
    L P##eventElement;                 // Pointer to the temp element to mesure it
    -D;                                // Pointer subtraction to determine length
    SRD 3;                             // Shift pointer to only have length
    T #elementSize;
_c:   NOP 0;

NETWORK
TITLE = Calculate iteration loop dimensions based on block size
    //------------------------------------------------------------------------//
    // Calculate loop dimensions based on block size divided by block         //
    // element data structure size if starting:                               //
    //------------------------------------------------------------------------//
    A #scanStart;
    JCN _d;
    L #blockSize;
    L #elementSize;
    /D;
    T #elementCount;
_d:   NOP 0;

NETWORK
TITLE = Initialise the counter if starting
    //------------------------------------------------------------------------//
    // Start counting at 1 if starting up:                                    //
    //------------------------------------------------------------------------//
    A #scanStart;
    JCN _e;
    L 1;
    T #scanCount;
_e:   NOP 0;

NETWORK
TITLE = Start at the first block element if reached the end
    //------------------------------------------------------------------------//
    // Start scanning at the first element if reached the end of the block:   //
    //------------------------------------------------------------------------//
    L #scanCount;
    L #elementCount;
    >I;
    JCN _f;
    L 1;
    T #scanCount;
_f:   NOP 0;

NETWORK
TITLE = Initialise the starting address of the DB pointer if first element
    //------------------------------------------------------------------------//
    // Initialise DB pointer starting address to the first element at offset  //
    // of 0 if the counter is at the first element:                           //
    //------------------------------------------------------------------------//
    L #scanCount;
    L 1;
    ==I;
    JCN _g;
    L P#0.0;
    LAR1;
_g:   NOP 0;

NETWORK
TITLE = Bypass scanning if not currently enabled
    //------------------------------------------------------------------------//
    // Bypass the data scanning of the DB if not enabled:                     //
    //------------------------------------------------------------------------//
    A #scanEnabled;
    JCN _scanBypass;

NETWORK
TITLE = Read message event element DB data into local UDT variable
    //------------------------------------------------------------------------//
    // Read the current DB element data. Here the pointer value is relative   //
    // to the pointer offset:                                                 //
    //------------------------------------------------------------------------//
    L DBD[AR1,P#0.0];
    = #eventElement.trigger;
    L DBD[AR1,P#0.1];
    = #eventElement.confirmYes;
    L DBD[AR1,P#0.2];
    = #eventElement.confirmNo;
    L DBD[AR1,P#0.3];
    = #eventElement.ackPending;
    L DBD[AR1,P#0.4];
    = #eventElement.ackRequired;
    L DBD[AR1,P#2.0];
    T #eventElement.eventID;
    L DBD[AR1,P#6.0];
    T #eventElement.idxMessage;
    L DBD[AR1,P#8.0];
    = #eventElement.payLoad.isBatch;
    L DBD[AR1,P#10.0];
    T #eventElement.payLoad.numSerial;

NETWORK
TITLE = Check if message event needs to be raised
    //------------------------------------------------------------------------//
    // Check if real message event or test signal number requested:           //
    //------------------------------------------------------------------------//
    O #eventElement.trigger;
    O(;
    L "testEventPrompt";
    L #eventElement.idxMessage;
    ==I;
    );
    = #raiseEvent;

NETWORK
TITLE = Clear response flags if message event needs to be raised
    //------------------------------------------------------------------------//
    // Clear the alarm request and response flags if raising a new event:     //
    //------------------------------------------------------------------------//
    A #raiseEvent;
    JCN _h;
    R #eventElement.confirmNo;
    R #eventElement.confirmYes;
    R #eventElement.trigger;
    R #eventElement.ackPending;
    R #scComplete;
_h:   NOP 0;

    CALL  #Program_Alarm_1
    (   SIG       := #eventElement.trigger;
        TIMESTAMP :=
        SD_1      :=
        Error     := #almError;
        Status    := #almStatus;
    );

      CALL  #Get_Alarm_Instance
         OperateMode :=
         DataMode    :=
         DispClassNr :=
         Lcid        :=
         DataReady   :=
         Busy        :=
         Error       :=
         Init        :=
         Status      :=
         Data        :=

      CALL  Get_AlarmState
         Alarm      :=
         AlarmState :=
         Error      :=
         STATUS     :=

      CALL  Ack_Alarms
         MODE   :=
         ERROR  :=
         STATUS :=

      CALL  Gen_UsrMsg
         Mode        :=
         TextID      :=
         TextListID  :=
         Ret_Val     :=
         AssocValues :=

         CALL  Get_Alarm , "Get_Alarm_DB"
            OperateMode :=
            DataMode    :=
            DispClassNr :=
            Lcid        :=
            DataReady   :=
            Busy        :=
            Error       :=
            Init        :=
            Status      :=
            Data        :=



NETWORK
TITLE = Raise message event without acknowledgement if required
    //------------------------------------------------------------------------//
    // Raise the simple message event if requested. No acknowledge required:  //
    //------------------------------------------------------------------------//
    A #raiseEvent;
    AN #eventElement.ackRequired;
    JCN _i;
    CALL ALARM_D
    (   SIG                         := #eventElement.trigger ,
        ID                          := WORD#16#EEEE ,         // S7 Data Channel for alarms
        EV_ID                       := #eventElement.eventID ,     // Alarm number (cannot be 0)
        CMP_ID                      := 7 ,                    // The DB number with the message data
        SD                          := #eventElement.payLoad ,
        RET_VAL                     := #sRetval
    );
_i:   NOP 0;

NETWORK
TITLE = Flag acknowledgement will be pending
    //------------------------------------------------------------------------//
    // Flag that an acknowledge event has been raised. In that case the       //
    // acknowledgement response is pending. Raise the event next:             //
    //------------------------------------------------------------------------//
    A #raiseEvent;
    A #eventElement.ackRequired;
    JCN _j;
    S #eventElement.ackPending;
_j:   NOP 0;

NETWORK
TITLE = Raise event with acknowledgement if required
    //------------------------------------------------------------------------//
    // Raise the acknowledge event if requested:                              //
    //------------------------------------------------------------------------//
    A #raiseEvent;
    A #eventElement.ackRequired;
    JCN _k;
    CALL ALARM_DQ
    (   SIG                         := #eventElement.trigger ,
        ID                          := WORD#16#EEEE ,         // S7 Data Channel for alarms
        EV_ID                       := #eventElement.eventID ,     // Alarm number (cannot be 0)
        CMP_ID                      := 7 ,                    // The DB number with the message data
        SD                          := #eventElement.payLoad ,
        RET_VAL                     := #sRetval
    );
_k:   NOP 0;

NETWORK
TITLE = Get acknowledgement if pending
    //------------------------------------------------------------------------//
    // Get the acknowledgement response if it was still pending. Response is  //
    // asynchronous and it may take a long time for the operator to attend to //
    // the event message:                                                     //
    //------------------------------------------------------------------------//
    A #eventElement.ackPending;
    JCN _l;
    CALL ALARM_SC
    (   EV_ID                       := #eventElement.eventID ,
        RET_VAL                     := #scRetval ,
        STATE                       := #scState ,
        Q_STATE                     := #scComplete
    );
    NOP 0;
_l:   NOP 0;

NETWORK
TITLE = Flag acknowledge response received if so
    //------------------------------------------------------------------------//
    // Flag acknowledgement no longer pending if finally received:            //
    //------------------------------------------------------------------------//
    A #eventElement.ackPending;
    A #scComplete;
    JCN _m;
    R #eventElement.ackPending;
_m:   NOP 0;

NETWORK
TITLE = Only Acknowledge or Ack plus Cancel
    //------------------------------------------------------------------------//
    // Check if the operator did not cancel. If not then it must have been a  //
    // confirm yes event:                                                     //
    //------------------------------------------------------------------------//
    A #scComplete;
    AN #eventElement.confirmNo;
    = #eventElement.confirmYes;

NETWORK
TITLE = Save the current element data back into the global DB
    //------------------------------------------------------------------------//
    // Write the current element data back to the global shared DB:           //
    //------------------------------------------------------------------------//
    A #eventElement.trigger;
    JCN _n;
    T DBD[AR1,P#0.0];
_n:   NOP 0;

    A #eventElement.confirmYes;
    JCN _o;
    T DBD[AR1,P#0.1];
_o:   NOP 0;

    A #eventElement.confirmNo;
    JCN _p;
    T DBD[AR1,P#0.2];
_p:   NOP 0;

    A #eventElement.ackPending;
    JCN _q;
    T DBD[AR1,P#0.3];
_q:   NOP 0;

NETWORK
TITLE = Increment the DB point offset
    //------------------------------------------------------------------------//
    // Increase the DB pointer offset by the size of the UDT data structure:  //
    //------------------------------------------------------------------------//
    +AR1 P##elementSize;

NETWORK
TITLE = Increment the DB element counter
    //------------------------------------------------------------------------//
    // Incrementt he loop counter to keep track of the element number:        //
    //------------------------------------------------------------------------//
    L #scanCount;
    L 1;
    +I;
    T #scanCount;

_scanBypass:   NOP 0;

END_FUNCTION
