//----------------------------------------------------------------------------//
//            Copyright 2018 Rieckermann Engineering Operations               //
//                Automatically Generated File - Do Not Edit                  //
//----------------------------------------------------------------------------//
// Description:                                                               //
// This file contains globally addressable event flags and data.              //
//----------------------------------------------------------------------------//
// Revision history:                                                          //
// Rev By               Date        CC        Note                            //
// 1.0 David Paspa      03-Apr-2018 NA        Initial design for S7-1500.     //
//----------------------------------------------------------------------------//
DATA_BLOCK "dbEVENT"
FUNCTION "fcEventIndexing" : Void
TITLE = Event indexing function for interface to HMI
{ S7_Optimized_Access := 'FALSE' }
AUTHOR : REO
NAME : fcEventIndexing
VERSION : 1.0

   VAR_INPUT
      EV_ID : DWord;   // Event ID, systemID
      Signal : Bool;   // Message Triger bit
      TestSignal : Byte;
      Event : Bool;   // Select=1 if Permanently acknowledge, =0 if need to ack
      CipSipNo : DInt;
      BatchID : "udtID";
      TextLib : Byte;   // Select Library, 0=Batch, 1=CipSip
      MessageIndex : Byte;   // Message number to be triggured/sent to HMI
   END_VAR

   VAR_OUTPUT
      Q_State : Bool;
      AckedOnly : Bool;
      AckAnd2ndBit : Bool;
   END_VAR

   VAR_IN_OUT
      Hmi2ndBit : Bool;
      SD : "udtAlarmMessage";
   END_VAR

    VAR_TEMP
        raiseEvent : Bool;
      scRetval : Int;
      scState : Bool;
      sRetval : Int;
    END_VAR


BEGIN
NETWORK

LAR1  P#0.0

 L     11
 T     MW    54

 OPN   "myDB"

next: NOP   0

 A(
 L     DBW [AR1,P#0.0]
 L     3
 ==I  
 )
 O(
 L     DBW [AR1,P#0.0]
 L     8
 ==I
 )
 S     "M56.0"
 L     MW    54
 L     1
 -I
 T     MW    54

 L     P#2.0
 +AR1

 L     MW    54
 LOOP  next


NETWORK
TITLE = Index the global event DB
    OPN dbEVENT                  // Open your data block
    L P#DBX 0.0                  // Load first dataword in pointer format
    L 420                        // your start address
    SLD 3                        // The address is byte/bit format, so shifting right 3 moves the 420 outside the bit parts. // (not sure if L P#DBX420.0 will work OK)
    L 20                         // Loop of 20 words (459-420 = 40 bytes or 20 words
    +D                           // add double words, thats the address as a pointer
    LAR1                         // and store into the address register No.1
    T #Number                    // update loop counter
    A( L 32 L D [AR1, P#0.0]     // If 32<= DW [x] <=I )
    A(                           // And
    L 126 <=I                    // DW [x] <= 126 )
    JC INC                       // 32<=DW<=126 Jump over and INC loop pointer
    L 32                         // 20 HEX
    T D[AR1, P#0.0]              // into dataword INC:
    L P#2.0                      // Offset in bytes to next dataword
    +AR1                         // add it to address register using as indirect addressing
    L #Number Loop Next          // Loop will decrement the number in the accumulator
    LAR1 #BufferAR1              // Once the loop has completed all 40 words, reload AR1 with what it originally had

NETWORK
TITLE = Select Main text library and Triger the Message index
//#MessageIndex=0, Oth of Index of Main text library will be displayed.
//#MessageIndex=1, 1st of Index of Main text library will be displayed.So on.
//....
//UserSignal=255,No message
//
//#TextLib=0, Batch ID will be displayed
//#TextLib=1, CipSip cycle number will be displayed
      L #MessageIndex;
      T #SD.MainTextLib;

NETWORK
TITLE = Select Main text library and Triger the Message index
      L #TextLib;
      T #SD.TextLib;

NETWORK
TITLE = if Batch ID to be displayed
      L #TextLib;
      L 1;
      ==I;
      JCN noDisplayBatchID;

NETWORK
TITLE = if Batch ID to be displayed
      L #BatchID.ID[1];
      T #SD.BatchID[1];
      L #BatchID.ID[2];
      T #SD.BatchID[2];
      L #BatchID.ID[3];
      T #SD.BatchID[3];
      L #BatchID.ID[4];
      T #SD.BatchID[4];
      L #BatchID.ID[5];
      T #SD.BatchID[5];
      L #BatchID.ID[6];
      T #SD.BatchID[6];

noDisplayBatchID:      NOP 0;

NETWORK
TITLE = if CipSip Cycle number to be displayed
      L #TextLib;
      L 2;
      ==I;
      L #CipSipNo;
      T #SD.CipSipNo;

NETWORK
TITLE = Check if alarm or event needs to be raised
      A(;
      A #Signal;
      A(;
      L #TestSignal;
      L 0;
      ==I;
      );
      A(;
      L #TestSignal;
      L 255;
      <>I;
      );
      O(;
      L #TestSignal;
      L #MessageIndex;
      ==I;
      );
      );
      = #raiseEvent;

NETWORK
TITLE = If Event, without acknowledgement/Permanently acknowledge
      A #raiseEvent;
      A #Event;
      CALL ALARM_D
      (  SIG                         := #raiseEvent ,
         ID                          := WORD#16#EEEE ,
         EV_ID                       := #EV_ID ,
         CMP_ID                      := #EV_ID ,
         SD                          := "dbCONST_VAL".BlockMsgS1.SD ,
         RET_VAL                     := #sRetval
      );

NETWORK
TITLE = If Alarm, Need acknowledgement
      A #raiseEvent;
      AN #Event;
      CALL ALARM_DQ
      (  SIG                         := #raiseEvent ,
         ID                          := WORD#16#EEEE ,
         EV_ID                       := #EV_ID ,
         CMP_ID                      := #EV_ID ,
         SD                          := "dbCONST_VAL".BlockMsgS1.SD ,
         RET_VAL                     := #sRetval
      );

NETWORK
TITLE = Acknowledge
      CALL ALARM_SC
      (  EV_ID                       := #EV_ID ,
         RET_VAL                     := #scRetval ,
         STATE                       := #scState ,
         Q_STATE                     := #Q_State
      );
      NOP 0;
NETWORK
TITLE = Only Acknowledge or Ack plus Cancel
      A #Q_State;
      AN #Hmi2ndBit;
      AN #AckAnd2ndBit;
      S #AckedOnly;

      A #Q_State;
      A #Hmi2ndBit;
      S #AckAnd2ndBit;

      A #Q_State;
      A #Hmi2ndBit;
      A #AckAnd2ndBit;
      R #Hmi2ndBit;
NETWORK
TITLE = Reset Acked bit
      A #AckedOnly;
      AN #Q_State;
      R #AckedOnly;
NETWORK
TITLE = #AckAnd2ndBit
      A #AckAnd2ndBit;
      AN #Q_State;
      R #AckAnd2ndBit;
END_FUNCTION_BLOCK
