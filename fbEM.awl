//----------------------------------------------------------------------------//
//            Copyright 2018 Rieckermann Engineering Operations               //
//                Automatically Generated File - Do Not Edit                  //
//----------------------------------------------------------------------------//
// Title:       @@CLASS@@
// Description: @@CLASSDESCRIPTION@@
//                                                                            //
// Block functional pseudocode:                                               //
//                                                                            //
// If any Calling Parameter invalid                                           //
//     Set flagBadParameter                                                   //
//                                                                            //
// If any Child in MANUAL mode                                                //
//     Set flagChildManual                                                    //
//                                                                            //
// If any Child in INTERLOCKED state                                          //
//     Set flagChildInterlocked                                               //
//                                                                            //
// If any Child not Owned or not Available                                    //
//     Set flagChildUnavailable                                               //
//                                                                            //
// If flagChildManual OR flagChildInterlocked OR flagChildUnavailable         //
//     Set flagChildFailed                                                    //
//                                                                            //
// Call Mode and Command Handling Block                                       //
//     If no Owner                                                            //
//         Set flagAvailable                                                  //
//                                                                            //
//     If any Interlock condition or flagBadParameter or flagChildMismatch    //
//         Set block INTERLOCK flag                                           //
//         Set block state INTERLOCKED                                        //
//                                                                            //
//     If flagChildFailed and block STATE is STOPPED                          //
//         Set block state INTERLOCKED                                        //
//                                                                            //
//     If flagChildFailed and block STATE is RUNNING                          //
//         Set block state PAUSED                                             //
//                                                                            //
//     Auto/Manual/OOS Mode Change                                            //
//     Auto/Manual Command Change                                             //
//     Substate Change                                                        //
//                                                                            //
//     if new Substate                                                        //
//         Set eventCommandStart (one scan positive edge)                     //
//                                                                            //
// If eventCommandStart and not flagChildFailed                               //
//     If child block Available                                               //
//         Take Ownership and record for later Release                        //
//                                                                            //
//     Convert substates to flags                                             //
//     Convert calling parameter selections to flags                          //
//     Store child device initial commands to current commands                //
//     Store child device initial commands to previous commands               //
//     Command child devices to current commands                              //
//                                                                            //
// If eventCommandStart and not flagSubstateHasSFC and check time elapsed     //
//     Set eventComplete                                                      //
//     If any child state does not match command                              //
//         Set flagChildMismatch                                              //
//                                                                            //
// If eventCommandStart and flagSubstateHasSFC                                //
//     Write current child commands to SFC child commands                     //
//     Initiate SFC                                                           //
//     Set flagSFCRunning                                                     //
//                                                                            //
// If flagSFCRunning                                                          //
//     Write SFC child commands to current commands                           //
//     Write any changed current commands to child devices                    //
//     Write current commands to previous commands                            //
//                                                                            //
// If flagSFCRunning and any command changed and check time elapsed           //
//     If any child state does not match command                              //
//         Set flagChildMismatch                                              //
//                                                                            //
// If flagSFCRunning and SFC complete                                         //
//     Clear flagSFCRunning                                                   //
//     Set eventComplete                                                      //
//                                                                            //
// If eventComplete                                                           //
//     Set block state COMPLETED                                              //
//                                                                            //
// If eventComplete and CHILD_RELEASE                                         //
//     Release any child devices taken Ownership                              //
//----------------------------------------------------------------------------//
// Revision history:                                                          //
// Rev By               Date        CC        Note                            //
// 2.0 David Paspa      30-Jan-2018 NA        Reboot for S7-1500.             //
// 1.0 Gerald Kontriner 10-Oct-2009 CC-09/023 Added Alarm flag MON_MISMATCH.  //
// 0.9 Khairul Basar    04-Oct-2009 CC-09/023 SHARED_BY  changed to OWNER int.//
// 0.8 Khairul Basar    02-Oct-2009 CC-09/023 SQ_STATE, ERR flag reset if SQ  //
//                                            off.                            //
// 0.7 Khoon            01-Oct-2009 CC-09/016 Mode=2 init,'Substate change'   //
//                                            added to STOP input of Subs.    //
// 0.6 Khairul Basar    30-Sep-2009 CC-09/023 EM Mode var changed to IN_OUT.  //
// 0.5 Khairul Basar    25-Sep-2009 CC-09/016 Ref2.                           //
// 0.4 Khairul Basar    21-Sep-2009 CC-09/016 Ref1.                           //
// 0.3 Khairul Basar    17-Sep-2009 CC-09/016 Duplicate command/SP parameters //
//                                            deleted auto/manual both now    //
//                                            using same parameters.          //
// 0.2 Khairul Basar    27-Aug-2009 CC-09/023 Path_IL added, Phase updated.   //
// 0.1 Khairul Basar    03-Aug-2009           Initial design.                 //
// Ref2:                                                                      //
// SQ_ACK,SQ_RESUME,SQ_ERROR,CURSTEP,SQ_STATE variables are added as to       //
// control from HMI faceplate.                                                //
// Ref1:                                                                      //
// Phases are updated.Flush & Charge Syncronised for valve commands.SQ_stop   //
// command is passed when CALL flag is OFF(previously there was error).PULSE  //
// timer is created as multiple instance of a standard FB, no more hard coded //
// S5 timer. ERR_FLT is changed to TIMEOUT_VER, PATH_IL to FLOWPATH.Shared    //
// Equipment availability flag programmed,BatchCycle variable added.          //
//----------------------------------------------------------------------------//
FUNCTION_BLOCK "fb@@CLASS@@"
TITLE = @@CLASSDESCRIPTION@@
{ S7_Optimized_Access := 'FALSE' }
NAME : fb@@CLASS@@_CLASS
AUTHOR : Rieckermann Engineering Operations
VERSION : 2.0

//----------------------------------------------------------------------------//
// Declare variables:                                                         //
//----------------------------------------------------------------------------//
@@TEMPLATE_BEGIN@@
    VAR_INPUT
        COMMAND : Int := 1;              // Start/Stop command from HMI
        SEL_SUBS : Int := 1;             // Select running sibstate
        CR_IL : Bool;                    // critical Interlock that cannot be bypased.
        NCR_IL : Bool;                   // Interlock that can be manually bypassed.
        MAN_OVERRIDE : Bool;             // Manual override to bypass NCR_IL
        OWNER : Int := @@PARENTID@@;     // Value to be set or reset by Parent
        CHILD_RELEASE : Bool;            // Request to release children when complete
@@ATTR_BEGIN|TIMER@@
        IN_TIME_H : Int;
        IN_TIME_M : Int;
        IN_TIME_S : Int;
@@ATTR_END|TIMER@@
@@ATTR_BEGIN|CHILD@@
        @@CHILDALIAS@@_CMD_INIT : Int;     // @@CHILDALIASDESCRIPTION@@
@@ATTR_END|CHILD@@
@@ATTR_BEGIN|CHILD@@
        @@CHILDALIAS@@_STATE : Int;       // @@CHILDALIASDESCRIPTION@@
@@ATTR_END|CHILD@@
@@ATTR_BEGIN|PARAMETER_VAR_INPUT@@
        @@PARAMETER@@ : @@PARAMETERDATATYPE@@;    // @@PARAMETERDESCRIPTION@@
@@ATTR_END|PARAMETER_VAR_INPUT@@
    END_VAR

    VAR_OUTPUT
        DEV_STATE : Int;
        RUNNING : Bool;
        AVAILABLE : Bool;
        TIME_EXPIRED : Bool;
        ALARM_TIMEOUT : Bool;
        INTERLOCK : Bool;
        STATE_MISMATCH : Bool;
        BLK_PROCESSED : Bool;
        SQ_ERROR : Bool;
        CURSTEP : Int;
        SQ_STATE : Int;
        RUNNING_SUBS : Int;
        ARM_FLAG : Bool;
        MON_MISMATCH : Bool;
        CHILD_FAIL : Bool;
        BAD_PARAM : Bool;
@@ATTR_BEGIN|TIMER@@
        REM_TIME_H : Int;
        REM_TIME_M : Int;
        REM_TIME_S : Int;
@@ATTR_END|TIMER@@
@@ATTR_BEGIN|CHILD@@
        @@CHILDALIAS@@_CMD : Int;     // @@CHILDALIASDESCRIPTION@@
@@ATTR_END|CHILD@@
@@ATTR_BEGIN|PARAMETER_VAR_OUTPUT@@
        @@PARAMETER@@ : @@PARAMETERDATATYPE@@;    // @@PARAMETERDESCRIPTION@@
@@ATTR_END|PARAMETER_VAR_OUTPUT@@
    END_VAR

    VAR_IN_OUT
        MODE : Int := 2;   // Select mode manual or auto
        SQ_ACK : Bool;
        SQ_RESUME : Bool;
@@ATTR_BEGIN|PARAMETER_VAR_IN_OUT@@
        @@PARAMETER@@ : @@PARAMETERDATATYPE@@;    // @@PARAMETERDESCRIPTION@@
@@ATTR_END|PARAMETER_VAR_IN_OUT@@
@@ATTR_BEGIN|HYGIENE@@
        HYGIENE : Int;   // Hygiene state of the unit
@@ATTR_END|HYGIENE@@
    END_VAR

    VAR
        timeCheckChildState {OriginalPartName := 'TON'; LibVersion := '1.0'} : TON;
        BATCHCYCLE : "udtID";
        CMD_FUNC : "Mode_Cmd_Hist";
        RUNTMR : "fbRunTimer";
@@ATTR_BEGIN|HYGIENE@@
        HYGIENE_DATA : "udtHYGIENE_STATE";
@@ATTR_END|HYGIENE@@
@@ATTR_BEGIN|SELECT@@
@@ATTR_BEGIN|SELVALUE@@
        select_@@PARAMETER@@_@@SELECTION@@_@@SELECTIONVALUE@@ : Bool;
@@ATTR_END|SELVALUE@@
@@ATTR_END|SELECT@@
@@ATTR_BEGIN|STATE@@
        subs_@@STATE@@ : Bool;       // @@STATEDESCRIPTION@@
@@ATTR_END|STATE@@
@@ATTR_BEGIN|STATE@@
        hasSFC_@@STATE@@ : Bool := @@HASSFC@@;       // @@STATEDESCRIPTION@@
@@ATTR_END|STATE@@
@@ATTR_BEGIN|SFC@@
        sfc_@@SFC@@ : "fb@@CLASS@@_@@SFC@@";       // @@STATEDESCRIPTION@@
@@ATTR_END|SFC@@
@@ATTR_BEGIN|CHILD@@
        release_@@CHILDALIAS@@ : Bool;       // @@CHILDALIASDESCRIPTION@@
@@ATTR_END|CHILD@@
@@ATTR_BEGIN|CHILD@@
        @@CHILDALIAS@@_CMD_CURR : Int;     // @@CHILDALIASDESCRIPTION@@
@@ATTR_END|CHILD@@
@@ATTR_BEGIN|CHILD@@
        @@CHILDALIAS@@_CMD_PREV : Int;     // @@CHILDALIASDESCRIPTION@@
@@ATTR_END|CHILD@@
    END_VAR

    VAR_TEMP
        flagBadParameter: Bool;
        flagChildCommandChange : Bool;
        flagChildFailed : Bool;
        flagChildInterlocked : Bool;
        flagChildManual : Bool;
        flagChildMismatch : Bool;
        flagChildUnavailable : Bool;
        edgeCommandStart : Bool;
        edgeCommandStop : Bool;
        edgeModeAuto : Bool;
        edgeModeManual : Bool;
        edgeModeOOS : Bool;
        eventCommandStart : Bool;
        eventCommandStop : Bool;
        eventModeAuto: Bool;
        eventModeManual: Bool;
        eventModeOOS: Bool;
        flagSFCCompleted : Bool;
        flagSFCRunning : Bool;
        modeChanged : Bool;
        modeManual : Bool;
        modeAuto : Bool;
        modeOOS : Bool;
        sq_finished : Bool;
        subsChanged : Bool;
        stateRunning : Bool;
        tmpTimeExpired : Bool;
@@ATTR_BEGIN|TIMER@@
        tTime : Time;
        dTime : DInt;
@@ATTR_END|TIMER@@
    END_VAR

BEGIN
NETWORK
TITLE = Check if calling parameters are valid
    //------------------------------------------------------------------------//
    // CALLING PARAMETERS   CALLING PARAMETERS   CALLING PARAMETERS   CALLING //
    //                                                                        //
    // TODO: Check each calling parameter to make sure it is valid:           //
    //------------------------------------------------------------------------//
    A "AlwaysLow";
    = #flagBadParameter;
    = #BAD_PARAM;

@@ATTR_BEGIN|CHILD@@
NETWORK
TITLE = Check if child @@CHILDALIAS@@ is in MANUAL mode
    //------------------------------------------------------------------------//
    // CHILD MANUAL   CHILD MANUAL   CHILD MANUAL   CHILD MANUAL   CHILD MANU //
    //                                                                        //
    // Check the child device to see if it is in MANUAL mode. Only need to    //
    // find the first one so bypass further checks if this child in Manual:   //
    //------------------------------------------------------------------------//
    L "idb@@CHILDALIASCLASS@@".@@CHILDALIAS@@.MODE;
    L "dbCONST".BLK.MODE.MANUAL;
    ==I;
    = #flagChildManual;
    JC _completedChildManualChecks;

@@ATTR_END|CHILD@@

_completedChildManualChecks:      NOP 0;

@@ATTR_BEGIN|CHILD@@
NETWORK
TITLE = Check if child @@CHILDALIAS@@ is INTERLOCKed
    //------------------------------------------------------------------------//
    // CHILD INTERLOCK   CHILD INTERLOCK   CHILD INTERLOCK   CHILD INTERLOCK  //
    //                                                                        //
    // Check the child device to see if it is in the INTERLOCK state. Only    //
    // need to find the first one so bypass further checks if this child is   //
    // interlocked:                                                           //
    //------------------------------------------------------------------------//
    A @@CHILDALIAS@@.INTERLOCK;
    = #flagChildInterlocked;
    JC _completedChildInterlockChecks;

@@ATTR_END|CHILD@@

_completedChildInterlockChecks:      NOP 0;

@@ATTR_BEGIN|CHILD@@
NETWORK
TITLE = Check if Child @@CHILDALIAS@@ is not already Owned or not Available
    //------------------------------------------------------------------------//
    // CHILD OWNER   CHILD OWNER   CHILD OWNER   CHILD OWNER   CHILD OWNER    //
    //                                                                        //
    // Check the child device to see if it is already owned by this parent    //
    // or else if it is Available. If Available it will be acquired if needed //
    // later to execute a command. Only need to find the first one so bypass  //
    // further checks if this child is unavailable:                           //
    //------------------------------------------------------------------------//
    AN(;
    L @@CHILDALIAS@@.OWNER;
    L "dbCONST".BLK.OWNER.NONE;
    ==I;
    );
    AN(;
    L @@CHILDALIAS@@.OWNER;
    L #OWNER;
    ==I;
    );
    = #flagChildUnavailable;
    JC _completedChildAvailableChecks;

@@ATTR_END|CHILD@@

_completedChildAvailableChecks:      NOP 0;

NETWORK
TITLE = Check if any Child has Failed
    //------------------------------------------------------------------------//
    // CHILD FAILED   CHILD FAILED   CHILD FAILED   CHILD FAILED   CHILD FAIL //
    //                                                                        //
    // Check if any child cannot be controlled by this parent block in which  //
    // case this block will fail and so operation at this level should be     //
    // inhibited:                                                             //
    //------------------------------------------------------------------------//
    O #flagChildInterlocked;
    O #flagChildManual;
    O #flagChildUnavailable;
    = #flagChildFailed;
    = #CHILD_FAIL;

NETWORK
TITLE = Flag if a new block running substate command issued
    //------------------------------------------------------------------------//
    // START COMMAND   START COMMAND   START COMMAND   START COMMAND   START  //
    //                                                                        //
    // Check if the start command has just been issued if the bit positive    //
    // edge. The result will only last for one scan after the positive edge:  //
    //------------------------------------------------------------------------//
    AN #flagBadParameter;
    AN #flagChildFailed;
    A(;
    L #COMMAND;
    L "dbCONST".BLK.COMMAND.START;
    ==I;
    );
    FP #edgeCommandStart;
    = #eventCommandStart;

NETWORK
TITLE = Flag if a new block running substate command issued
    //------------------------------------------------------------------------//
    // Flag SFC is not yet running:                                           //
    //------------------------------------------------------------------------//
    A #eventCommandStart;
    R flagSFCRunning;

NETWORK
TITLE = Flag if block stop command issued
    //------------------------------------------------------------------------//
    // STOP COMMAND   STOP COMMAND   STOP COMMAND   STOP COMMAND   STOP COMM  //
    //                                                                        //
    // Check if the stop command has just been issued if the bit positive     //
    // edge. The result will only last for one scan after the positive edge:  //
    //------------------------------------------------------------------------//
    L #COMMAND;
    L "dbCONST".BLK.COMMAND.STOP;
    ==I;
    FP #edgeCommandStop;
    = #eventCommandStop;

@@ATTR_BEGIN|STATE@@
NETWORK
TITLE = Running Substate flags
    //------------------------------------------------------------------------//
    // RUNNING SUBSTATE FLAG   RUNNING SUBSTATE FLAG   RUNNING SUBSTATE FLAG  //
    //                                                                        //
    // Convert running substate values into boolean flags for ease of use in  //
    // boolean logic if starting a new substate:                              //
    //------------------------------------------------------------------------//
    A #eventCommandStart;
    A(;
    L #SEL_SUBS;
    L "dbCONST".BLK.@@CLASS@@.SUBS.@@STATE@@;
    ==I;
    );
    = #subs_@@STATE@@;
@@ATTR_END|STATE@@

@@ATTR_BEGIN|SELECT@@
NETWORK
TITLE = Calling Parameter Selection flags
    //------------------------------------------------------------------------//
    // CALLING PARAMETER SELECTION FLAG   CALLING PARAMETER SELECTION FLAG    //
    //                                                                        //
    // Convert calling parameter selections into the boolean flags for ease   //
    // of use in boolean logic if starting a new substate:                    //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|SELVALUE@@
    A #eventCommandStart;
    A(;
    L #@@PARAMETER@@;
    L "dbCONST".SEL.@@SELECTION@@.@@SELECTIONVALUE@@;
    ==I;
    );
    = #select_@@PARAMETER@@_@@SELECTION@@_@@SELECTIONVALUE@@;
@@ATTR_END|SELVALUE@@
@@ATTR_END|SELECT@@

@@ATTR_BEGIN|CHILD@@
NETWORK
TITLE = Acquire child @@CHILDALIAS@@ for new command
    //------------------------------------------------------------------------//
    // ACQUIRE CHILDREN   ACQUIRE CHILDREN   ACQUIRE CHILDREN   ACQUIRE CHILD //
    //                                                                        //
    // Aquire the available child devices.                                    //
    //                                                                        //
    // Flag the to take ownership of the child now and release at the end if  //
    // the child is available as it would be a child unavailabile failure     //
    // already above if not available at this point:                          //
    //------------------------------------------------------------------------//
    A #eventCommandStart;
    L @@CHILDALIAS@@.OWNER;
    L "dbCONST".BLK.OWNER.NONE;
    ==I;
    = #release_@@CHILDALIAS@@

NETWORK
TITLE = Acquire child @@CHILDALIAS@@ for new command
    //------------------------------------------------------------------------//
    // The child is available so take ownership by this block by writing to   //
    // the child owner variable. Flag that this child will need to be reset   //
    // at the end:                                                            //
    //------------------------------------------------------------------------//
    A #release_@@CHILDALIAS@@
    L #OWNER;
    T @@CHILDALIAS@@.OWNER;

@@ATTR_END|CHILD@@

NETWORK
TITLE = Command child devices to their initial commands
    //------------------------------------------------------------------------//
    // CHILD INITIAL COMMAND   CHILD INITIAL COMMAND   CHILD INITIAL COMMAND  //
    //                                                                        //
    // Set the initial command values for the child devices. Match the        //
    // previous command as well in order to initialise the variables:         //
    //                                                                        //
    // Bypass if not starting a new substate or if any child failure:         //
    //------------------------------------------------------------------------//
    A #eventCommandStart;
    JCN _no_start_4
@@ATTR_BEGIN|CHILD@@

    //------------------------------------------------------------------------//
    // Command the child device to its initial command and store the command: //
    //------------------------------------------------------------------------//
    L #@@CHILDALIAS@@_CMD_INIT;
    T #@@CHILDALIAS@@_CMD_CURR;
    T #@@CHILDALIAS@@_CMD_PREV;
    T #@@CHILDALIAS@@_CMD;
@@ATTR_END|CHILD@@

_no_start_4:      NOP 0;

@@ATTR_BEGIN|SFC@@
NETWORK
TITLE = If substate @@STATE@@ is running then set the SFC calling parameters
    //------------------------------------------------------------------------//
    // SFC PARAMETERS   SFC PARAMETERS   SFC PARAMETERS   SFC PARAMETERS   SF //
    //                                                                        //
    // Set the SFC calling parameters if this is the running substate:        //
    //------------------------------------------------------------------------//
    A #eventCommandStart;
    A #subs_@@STATE@@;
    CALL #sfc_@@SFC@@
    (
        MODE                        := #@@SFC@@.MODE ,
        SQ_CMD                      := #@@SFC@@.SQ_CMD ,
@@ATTR_BEGIN|PARAMETER_SFC_VAR_INPUT@@
        _@@PARAMETER@@              := #@@PARAMETERBLOCK@@ ,
@@ATTR_END|PARAMETER_SFC_VAR_INPUT@@
        SQ_STATE                    := #@@SFC@@.SQ_STATE ,
        CURSTEP                     := #@@SFC@@.CURSTEP ,
        NXT_STEP                    := #@@SFC@@.NXT_STEP ,
        S_ACTIVE                    := #@@SFC@@.S_ACTIVE ,
        ERR_FAULT                   := #@@SFC@@.ERR_FAULT ,
        PAUSED                      := #@@SFC@@.PAUSED ,
        OFF_IDLE                    := #@@SFC@@.OFF_IDLE ,
        SQ_FINISHED                 := #@@SFC@@.SQ_FINISHED ,
@@ATTR_BEGIN|PARAMETER_SFC_VAR_OUTPUT@@
        _@@PARAMETER@@              := #@@PARAMETERBLOCK@@ ,
@@ATTR_END|PARAMETER_SFC_VAR_OUTPUT@@
        STEPNO_JUMP                 := #@@SFC@@.STEPNO_JUMP ,
        MAN_JUMP                    := #@@SFC@@.MAN_JUMP ,
        NO_VERIFIC                  := #@@SFC@@.NO_VERIFIC ,
        TRN_AND_JUMP                := #@@SFC@@.TRN_AND_JUMP ,
@@ATTR_BEGIN|PARAMETER_SFC_VAR_IN_OUT@@
        _@@PARAMETER@@              := #@@PARAMETERBLOCK@@ ,
@@ATTR_END|PARAMETER_SFC_VAR_IN_OUT@@
    );

@@ATTR_END|SFC@@

@@ATTR_BEGIN|SFC@@
NETWORK
TITLE = Make sure any non-active SFCs are stopped
    //------------------------------------------------------------------------//
    // Stop any SFC if not the current running substate or if the stop        //
    // command has been issued:                                               //
    //------------------------------------------------------------------------//
    O #eventCommandStop;
    O(;
    A #eventCommandStart;
    AN #subs_@@STATE@@;
    );
    L "dbCONST".BLKSFC.CMD.STOP;
    T #@@SFC@@.SQ_CMD;

@@ATTR_END|SFC@@

@@ATTR_BEGIN|SFC@@
NETWORK
TITLE = Synchronise SFC @@SFC@@ child commands
    //------------------------------------------------------------------------//
    // SYNC SFC CHILD COMMANDS    SYNC SFC CHILD COMMANDS    SYNC SFC CHILD   //
    //                                                                        //
    // Write the initial command to any SFC child commands to synchronise     //
    // them at the start of the SFC.                                          //
    //                                                                        //
    // Bypass if not the current running substate:                            //
    //------------------------------------------------------------------------//
    A #eventCommandStart;
    A #subs_@@STATE@@;
    JCN _notSFCStarting1_@@COUNTER@@;

    //------------------------------------------------------------------------//
    // Set the SFC child commands to the initial commands to ensure they are  //
    // synchronised:                                                          //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|CHILD@@
    L #@@CHILDALIAS@@_CMD_INIT;
    T #@@SFC@@.@@CHILDSFCALIAS@@_CMD;

@@ATTR_END|CHILD@@
_notSFCStarting1_@@COUNTER@@:      NOP 0;
@@ATTR_END|SFC@@

@@ATTR_BEGIN|SFC@@
NETWORK
TITLE = Start the SFC sequence @@SFC@@ for running substate @@STATE@@
    //------------------------------------------------------------------------//
    // START SFC   START SFC   START SFC   START SFC   START SFC   START SFC  //
    //                                                                        //
    // Start the substate SFC.                                                //
    //                                                                        //
    // Bypass if not the current running substate:                            //
    //------------------------------------------------------------------------//
    A #eventCommandStart;
    A #subs_@@STATE@@;
    JCN _notSFCStarting2_@@COUNTER@@;

    //------------------------------------------------------------------------//
    // Start the SFC for the running substate:                                //
    //------------------------------------------------------------------------//
    L "dbCONST".BLKSFC.CMD.START;
    T #@@SFC@@.SQ_CMD;
    S flagSFCRunning;

_notSFCStarting2_@@COUNTER@@:      NOP 0;
@@ATTR_END|SFC@@

@@ATTR_BEGIN|SFC@@
NETWORK
TITLE = Check if any new Child command from any running SFC
    //------------------------------------------------------------------------//
    // NEW CHILD COMMAND   NEW CHILD COMMAND   NEW CHILD COMMAND   NEW CHILD  //
    //                                                                        //
    // Check if the running SFC requests to change any child command:         //
    //------------------------------------------------------------------------//
    R #flagChildCommandChange;
    A #subs_@@STATE@@;
    A flagSFCRunning;
    AN #@@SFC@@.PAUSED;
    AN #@@SFC@@.ERR_FAULT;
    JCN _notSFCRunning1_@@COUNTER@@;

@@ATTR_BEGIN|CHILD@@
    //------------------------------------------------------------------------//
    // Check if the running SFC requests to change this child command:        //
    //------------------------------------------------------------------------//
    L #@@SFC@@.@@CHILDSFCALIAS@@_CMD;
    L #@@CHILDALIAS@@_CMD;
    ==I;
    = #cmdChange;

    //------------------------------------------------------------------------//
    // If SFC child command changed then command the child field device:      //
    //------------------------------------------------------------------------//
    A #cmdChange;
    S #flagChildCommandChange;
    L #@@SFC@@.@@CHILDSFCALIAS@@_CMD;
    T #@@CHILDALIAS@@_CMD;
@@ATTR_END|CHILD@@

_notSFCRunning1_@@COUNTER@@:      NOP 0;
@@ATTR_END|SFC@@

NETWORK
TITLE = If child command changed, start timer to wait for child state
    //------------------------------------------------------------------------//
    // CHILD STATE TIMER   CHILD STATE TIMER   CHILD STATE TIMER   CHILD STAT //
    //                                                                        //
    // If any child command changed then start a timer to provide a grace     //
    // period to allow the child device state to match the command (e.g. to   //
    // allow a valve to move from closed to opened position).                 //
    // Start the child state check timer if a command changed:                //
    //------------------------------------------------------------------------//
    A #flagChildCommandChange;
    CALL #timeCheckChildState
    {time_type := 'Time'}
    (   IN                          := #flagChildCommandChange ,
        PT                          := T#10S ,
        Q                           := #timeCheckChildState.Q ,
        ET                          := #timeCheckChildState.ET
    );
    NOP 0;

@@ATTR_BEGIN|CHILD@@
NETWORK
TITLE = Check if any Child state does not match the command
    //------------------------------------------------------------------------//
    // CHILD STATE MISMATCH   CHILD STATE MISMATCH   CHILD STATE MISMATCH     //
    //                                                                        //
    // Check if any child device state does not match the command from this   //
    // parent block if the child state grace period timer has expired. Stop   //
    // checking if the first child state mismatch found:                      //
    //------------------------------------------------------------------------//
    A #timeCheckState.Q;
    L #@@CHILDALIAS@@_STATE;
    L #@@CHILDALIAS@@_CMD;
    <>I;
    = #flagChildMismatch;
    JC _childMismatch;

@@ATTR_END|CHILD@@

_childMismatch:      NOP 0;

NETWORK
TITLE = An Interlock will stop the Module itself
    //------------------------------------------------------------------------//
    // BLOCK INTERLOCK   BLOCK INTERLOCK   BLOCK INTERLOCK   BLOCK INTERLOCK  //
    //                                                                        //
    // Interlock the block if any child problem. Block interlock must stop    //
    // the module and any running SFC:                                        //
    //------------------------------------------------------------------------//
    O #flagChildMismatch;
    O #flagChildFailed;
    = #INTERLOCK;

    //------------------------------------------------------------------------//
    // Interlock the block if any interlock condition:                        //
    //------------------------------------------------------------------------//
    A #INTERLOCK;
    L "dbCONST".BLK.DEV_STATE.INTERLOCKED;
    T #DEV_STATE;

    //------------------------------------------------------------------------//
    // Stop the block if any interlock:                                       //
    //------------------------------------------------------------------------//
    A #INTERLOCK;
    L "dbCONST".BLK.CMD.STOP;
    T #COMMAND;

    //------------------------------------------------------------------------//
    // Set the substate safe if any interlock:                                //
    //------------------------------------------------------------------------//
    A #INTERLOCK;
    L "dbCONST".BLK.SUBS.SAFE;
    T #SEL_SUBS;

@@ATTR_BEGIN|SFC@@
    //------------------------------------------------------------------------//
    // Pause the running SFC sequence:                                        //
    //------------------------------------------------------------------------//
    A #INTERLOCK;
    A #subs_@@STATE@@;
    L "dbCONST".BLKSFC.CMD.PAUSE;
    T #@@SFC@@.SQ_CMD;

@@ATTR_END|SFC@@

NETWORK
TITLE = Set child devices to safe state if any interlock
    //------------------------------------------------------------------------//
    // SAFE STATE   SAFE STATE   SAFE STATE   SAFE STATE  SAFE STATE  SAFE ST //
    //                                                                        //
    // Set the child devices to the safe state on any interlock condition:    //
    //------------------------------------------------------------------------//
    A #INTERLOCK;

    // TODO TODO


NETWORK
TITLE = SQ Acknowlede Error Fault and Resume
    //------------------------------------------------------------------------//
    // SFC RESUME   SFC RESUME   SFC RESUME   SFC RESUME   SFC RESUME   SFC R //
    //                                                                        //
    // Check if any child device state does not match the command from this   //
    // parent block:                                                          //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|SFC@@

    //------------------------------------------------------------------------//
    // Bypass if SFC error not acknowledged:                                  //
    //------------------------------------------------------------------------//
    A #SQ_ACK;
    A #SQ_ERROR;
    A #subs_@@STATE@@;
    JNB ack@@COUNTER|1@@;

    //------------------------------------------------------------------------//
    // Set the SFC error to acknowledged:                                     //
    //------------------------------------------------------------------------//
    L "dbCONST".BLKSFC.CMD.ACKNOWLEDGE_ERR;
    T #@@SFC@@.SQ_CMD;
    R #SQ_ACK;

ack@@COUNTER@@:      NOP 0;

    //------------------------------------------------------------------------//
    // Check if the sequence was paused or an error was acknowledged and the  //
    // SFC is to be resumed:                                                  //
    //------------------------------------------------------------------------//
    A #SQ_RESUME;
    A #subs_@@STATE@@;
    A(;
    O(;
    L #SQ_STATE;
    L "dbCONST".BLKSFC.CMD.PAUSE;
    ==I;
    );
    O(;
    L #SQ_STATE;
    L "dbCONST".BLKSFC.CMD.ACKNOWLEDGE_ERR;
    ==I;
    );
    );
    JNB res@@COUNTER|1@@;

    //------------------------------------------------------------------------//
    // Resume the SFC operation:                                              //
    //------------------------------------------------------------------------//
    L "dbCONST".BLKSFC.CMD.RESUME;
    T #@@SFC@@.SQ_CMD;
    R #SQ_RESUME;

res@@COUNTER@@:      NOP 0;
@@ATTR_END|SFC@@

NETWORK
TITLE = All SQ are in Auto mode when EM in Auto
    //------------------------------------------------------------------------//
    // SFC AUTO   SFC AUTO   SFC AUTO   SFC AUTO   SFC AUTO   SFC AUTO   SFC  //
    //                                                                        //
    // Set all SFCs to AUTO mode if the block is in AUTO:                     //
    //------------------------------------------------------------------------//
    A modeChanged;
    A modeAuto;
    JNB nomc;
    L #MODE;
@@ATTR_BEGIN|SFC@@
    T #@@SFC@@.MODE;
@@ATTR_END|SFC@@

nomc:      NOP 0;

NETWORK
TITLE = Flag SFC finished if completed execution
    //------------------------------------------------------------------------//
    // SFC COMPLETE   SFC COMPLETE   SFC COMPLETE   SFC COMPLETE   SFC COMPL  //
    //                                                                        //
    // Flag SFC completed if the sequence has finished executing:             //
    //------------------------------------------------------------------------//

@@ATTR_BEGIN|SFC@@
    //------------------------------------------------------------------------//
    // Flag the SFC finished if it has:                                       //
    //------------------------------------------------------------------------//
    A #subs_@@STATE@@;
    A #@@SFC@@.SQ_FINISHED;
    = #flagSFCCompleted;
@@ATTR_END|SFC@@

NETWORK
TITLE = Move SFC Current Step to Output
    //------------------------------------------------------------------------//
    // SFC UPDATE STEP   SFC UPDATE STEP   SFC UPDATE STEP   SFC UPDATE STEP  //
    //                                                                        //
    // Flag SFC completed if the sequence has finished executing:             //
    //------------------------------------------------------------------------//

@@ATTR_BEGIN|SFC@@
    //------------------------------------------------------------------------//
    // Check if this is the current SFC:                                      //
    //------------------------------------------------------------------------//
    A #subs_@@STATE@@;
    JNB mov@@COUNTER|1@@;

    //------------------------------------------------------------------------//
    // Update the block step details from the SFC:                            //
    //------------------------------------------------------------------------//
    L #@@SFC@@.CURSTEP;
    T #CURSTEP;
    L #@@SFC@@.SQ_STATE;
    T #SQ_STATE;
    A #@@SFC@@.ERR_FAULT;
    = #SQ_ERROR;

mov@@COUNTER|1@@:      NOP 0;
@@ATTR_END|SFC@@

NETWORK
TITLE = Set child devices to safe state if SFC Paused or Error
    //------------------------------------------------------------------------//
    // SAFE STATE ON ERROR   SAFE STATE ON ERROR   SAFE STATE ON ERROR   SAFE //
    //                                                                        //
    // Flag SFC completed if the sequence has finished executing:             //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|SFC@@

    //------------------------------------------------------------------------//
    // Bypass if the current SFC is running okay:                             //
    //------------------------------------------------------------------------//
    A #subs_@@STATE@@;
    A #flagSFCRunning;
    A(;
    O #@@SFC@@.PAUSED;
    O #@@SFC@@.ERR_FAULT;
    );
    JNB saf@@COUNTER|1@@;

    //------------------------------------------------------------------------//
    // TODO: Set all child devices to safe state if any sequence problem:     //
    //------------------------------------------------------------------------//

    // TODO TODO

    L "dbCONST".CM.CMD_VALVE.CLOSE;
@@ATTR_BEGIN|CHILD@@
    T #@@CHILDALIAS@@_CMD_CURR;
@@ATTR_END|CHILD@@

saf@@COUNTER@@:      NOP 0;
@@ATTR_END|SFC@@

NETWORK
TITLE = Command child devices to updated SFC commands
    //------------------------------------------------------------------------//
    // CHILD SFC COMMAND   CHILD SFC COMMAND   CHILD SFC COMMAND   CHILD SFC  //
    //                                                                        //
    // Command each child device to its SFC command if an SFC is still        //
    // running and the device command has changed.                            //
    // Bypass if no SFC currently running:                                    //
    //------------------------------------------------------------------------//
    A #flagSFCRunning;
    JCN sfcnr1;
@@ATTR_BEGIN|CHILD@@
@@ATTR_BEGIN|SFC@@

    //------------------------------------------------------------------------//
    // If the substate is active then transfer the SFC command:               //
    //------------------------------------------------------------------------//
    A #subs_@@STATE@@;
    AN #@@SFC@@.PAUSED;
    AN #@@SFC@@.ERR_FAULT;
    JCN subs@@COUNTER|1@@;

    L #@@SFC@@.@@CHILDSFCALIAS@@;
    T #@@CHILDALIAS@@_CMD_CURR;
subs@@COUNTER@@:      NOP 0;
@@ATTR_END|SFC@@

    //------------------------------------------------------------------------//
    // Bypass if there has been no change in command:                         //
    //------------------------------------------------------------------------//
    A(;
    L #@@CHILDALIAS@@_CMD_CURR;
    L #@@CHILDALIAS@@_CMD_PREV;
    ==I;
    );
    JC cmd@@COUNTER|1@@;

    //------------------------------------------------------------------------//
    // Command the child device to the current command and save the current   //
    // command as the previous command to check for changes next scan:        //
    //------------------------------------------------------------------------//
    L #@@CHILDALIAS@@_CMD_CURR;
    T #@@CHILDALIAS@@_@@COMMANDALIASTYPE@@;
    T #@@CHILDALIAS@@_CMD_PREV;
cmd@@COUNTER@@:      NOP 0;
@@ATTR_END|CHILD@@

sfcnr1:      NOP 0;

NETWORK
TITLE = Release children acquired for completed command
    //------------------------------------------------------------------------//
    // RELEASE CHILDREN   RELEASE CHILDREN   RELEASE CHILDREN   RELEASE CHILD //
    //                                                                        //
    // Release any child devices acquired to run the command and clean up.    //
    //                                                                        //
    // Bypass if SFC is still running and not yet complete:                   //
    //------------------------------------------------------------------------//
    A #flagSFCCompleted;
    JCN sfcnr2
@@ATTR_BEGIN|CHILD@@

    //------------------------------------------------------------------------//
    // Release the child device if it was acquired earlier:                   //
    //------------------------------------------------------------------------//
    A #release_@@CHILDALIAS@@
    JCN rls@@COUNTER|1@@;
    L "dbCONST".BLK.OWNER.NONE;
    T @@CHILDALIAS@@.OWNER;
    R #release_@@CHILDALIAS@@
rls@@COUNTER@@:      NOP 0;
@@ATTR_END|CHILD@@

    //------------------------------------------------------------------------//
    // Set the block state to COMPLETED:                                      //
    //------------------------------------------------------------------------//
    L "dbCONST".BLK.DEV_STATE.COMPLETED;
    T #DEV_STATE;
    R #flagSFCCompleted;

sfcnr2:      NOP 0;

NETWORK
TITLE = Clean up if SFC no longer running
    //------------------------------------------------------------------------//
    // SFC RESET   SFC RESET   SFC RESET   SFC RESET   SFC RESET   SFC RESET  //
    //                                                                        //
    // Clean up all flags if SFC is no longer running.                        //
    //------------------------------------------------------------------------//
@@ATTR_BEGIN|SFC@@

    //------------------------------------------------------------------------//
    // Check if current SFC is aborted or completed successfully:             //
    //------------------------------------------------------------------------//
    A #subs_@@STATE@@;
    A(;
    O(;
    L #SEL_SUBS;
    L "dbCONST".BLK.SUBS.SAFE;
    ==I;
    );
    O(;
    L #SQ_STATE;
    L "dbCONST".BLKSFC.STATE.ABORTED;
    ==I;
    );
    O(;
    L #SQ_STATE;
    L "dbCONST".BLKSFC.STATE.COMPLETED;
    ==I;
    );
    );
    JCN sfcd@@COUNTER|1@@;

    //------------------------------------------------------------------------//
    // SFC is no longer running:                                              //
    //------------------------------------------------------------------------//
    L "dbCONST".BLK.SUBS.SAFE;
    T #SQ_STATE;

    L 0;
    T #CURSTEP;
    T #@@SFC@@.CURSTEP;
    T #@@SFC@@.SQ_STATE;

    R #SQ_ERROR;
    R #@@SFC@@.ERR_FAULT;
    R #@@SFC@@.PAUSED;

sfcd@@COUNTER@@:      NOP 0;
@@ATTR_END|SFC@@

NETWORK
TITLE = Flag if block Mode just changed to Auto
    //------------------------------------------------------------------------//
    // AUTO MODE   AUTO MODE   AUTO MODE   AUTO MODE   AUTO MODE   AUTO MODE  //
    //                                                                        //
    // Check if the mode has just been changed to Auto if the bit positive    //
    // edge. The result will only last for one scan after the positive edge:  //
    //------------------------------------------------------------------------//
    L #MODE;
    L "dbCONST".BLK.MODE.AUTO;
    ==I;
    FP #edgeModeAuto;
    = #eventModeAuto;

NETWORK
TITLE = Cascade Auto Mode to all children
    //------------------------------------------------------------------------//
    // AUTO MODE CASCADE   AUTO MODE CASCADE   AUTO MODE CASCADE   AUTO MODE  //
    //                                                                        //
    // Bypass mode change if this block did not just change to Auto:          //
    //------------------------------------------------------------------------//
    A #eventModeAuto;
    JCN _noAutoModeEvent;

    //------------------------------------------------------------------------//
    // Switch each child mode to Auto when parent transitions to Auto:        //
    //------------------------------------------------------------------------//
    L "dbCONST".BLK.MODE.AUTO;
@@ATTR_BEGIN|CHILD@@
    T #@@CHILDALIAS@@_MODE;
@@ATTR_END|CHILD@@

_noAutoModeEvent:      NOP 0;

NETWORK
TITLE = Flag if block Mode just changed to Manual
    //------------------------------------------------------------------------//
    // MANUAL MODE   MANUAL MODE   MANUAL MODE   MANUAL MODE   MANUAL MODE    //
    //                                                                        //
    // Check if the mode has just been changed to Manual if the bit positive  //
    // edge. The result will only last for one scan after the positive edge:  //
    //------------------------------------------------------------------------//
    L #MODE;
    L "dbCONST".BLK.MODE.MANUAL;
    ==I;
    FP #edgeModeManual;
    = #eventModeManual;

NETWORK
TITLE = Flag if block Mode just changed to Out Of Service
    //------------------------------------------------------------------------//
    // OOS MODE   OOS MODE   OOS MODE   OOS MODE   OOS MODE   OOS MODE   OOS  //
    //                                                                        //
    // Check if the mode has just been changed to Out of Service if the bit   //
    // positive edge. The result will only last for one scan after the        //
    // positive edge:                                                         //
    //------------------------------------------------------------------------//
    L #MODE;
    L "dbCONST".BLK.MODE.OOS;
    ==I;
    FP #edgeModeOOS;
    = #eventModeOOS;

NETWORK
TITLE = Cascade OOS Mode to all children
    //------------------------------------------------------------------------//
    // OOS MODE CASCADE   OOS MODE CASCADE   OOS MODE CASCADE   OOS MODE CAS  //
    //                                                                        //
    // Bypass mode change if this block did not just change to OOS:           //
    //------------------------------------------------------------------------//
    A #eventModeOOS;
    JCN _noOOSModeEvent;

    //------------------------------------------------------------------------//
    // Switch each child mode to OOS when parent transitions to OOS:          //
    //------------------------------------------------------------------------//
    L "dbCONST".BLK.MODE.OOS;
@@ATTR_BEGIN|CHILD@@
    T #@@CHILDALIAS@@_MODE;
@@ATTR_END|CHILD@@

_noOOSModeEvent:      NOP 0;

NETWORK
TITLE = Interlock Flag
    //------------------------------------------------------------------------//
    // Set boolean interlock flag if any interlock condition exists in the    //
    // field:                                                                 //
    //------------------------------------------------------------------------//
    O #CR_IL;
    O #flagBadParameter;
    O(;
    A #NCR_IL;
    AN #MAN_OVERRIDE;
    );
    = #INTERLOCK;

NETWORK
TITLE = Interlock State
    //------------------------------------------------------------------------//
    // Block should be interlocked state if STOPPED and interlock active or   //
    // child failed:                                                          //
    //------------------------------------------------------------------------//
    A(;
    L #DEV_STATE;
    L "dbCONST".BLK.DEV_STATE.STOPPED;
    ==I;
    );
    A(;
    O #INTERLOCK;
    O #flagChildFailed;
    );
    L "dbCONST".BLK.DEV_STATE.INTERLOCKED;
    T #DEV_STATE;

NETWORK
TITLE = Paused State
    //------------------------------------------------------------------------//
    // Block should be paused state if RUNNING and any child failure:         //
    //------------------------------------------------------------------------//
    A #flagChildFailed;
    A(;
    L #SEL_SUBS;
    L "dbCONST".BLK.SUBS.SAFE;
    <>I;
    );
    L "dbCONST".BLK.DEV_STATE.PAUSED;
    T #DEV_STATE;

@@TEMPLATE_END@@
END_FUNCTION_BLOCK

NETWORK
TITLE = Call Mode and Command handling block
    //------------------------------------------------------------------------//
    // COMMAND PROCESSOR   COMMAND PROCESSOR   COMMAND PROCESSOR   COMMAND    //
    //                                                                        //
    // Process the standard block functions for command, mode, interlock and  //
    // state:                                                                 //
    //------------------------------------------------------------------------//
    AN #flagBadParameter;
    AN #flagChildFailed;
    CALL "ModeAndCommand"
    (
        OWNER                       := #OWNER ,
        COMMAND                     := #COMMAND ,
        MODE                        := #MODE ,
        SUBS                        := #SEL_SUBS ,
        START_CMD                   := "dbCONST".BLK.CMD.START ,
        STOP_CMD                    := "dbCONST".BLK.CMD.STOP ,
        MODE_MAN                    := "dbCONST".BLK.MODE.MANUAL ,
        MODE_AUTO                   := "dbCONST".BLK.MODE.AUTO ,
        MODE_OOS                    := "dbCONST".BLK.MODE.OUT_OF_SERVICE ,
        CR_IL                       := #CR_IL ,
        NCR_IL                      := #NCR_IL ,
        MAN_OVERRIDE                := #MAN_OVERRIDE ,
        CHILD_FAIL                  := #flagChildFailed ,
        BAD_PARAM                   := #flagBadParameter ,
        AVAILABLE                   := #AVAILABLE ,
        RUNNING                     := #stateRunning ,
        INITIATE                    := #cmdInitiate ,
        STOP                        := #eventCommandStop ,
        MAN                         := #modeManual ,
        AUTO                        := #modeAuto ,
        OOS                         := #modeOOS ,
        DEV_STATE                   := #DEV_STATE ,
        MON_MISMATCH                := #MON_MISMATCH ,
        MODE_CHNG                   := #modeChanged ,
        SUBS_CHNG                   := #subsChanged ,
        INTERLOCK                   := #INTERLOCK ,
        CMD_M_H                     := #CMD_FUNC.Cmd_Man_hist ,
        CMD_A_H                     := #CMD_FUNC.Cmd_Auto_hist ,
        MODE_H                      := #CMD_FUNC.Mode_hist ,
        SUBS_H                      := #CMD_FUNC.Subs_hist
    );
    NOP 0;

@@ATTR_BEGIN|HYGIENE@@
NETWORK
TITLE = HYGIENE STATE CALCULATION
    //------------------------------------------------------------------------//
    // HYGIENE   HYGIENE   HYGIENE   HYGIENE   HYGIENE   HYGIENE   HYGIENE    //
    //                                                                        //
    // Calculate the hygiene status of the block:                             //
    //------------------------------------------------------------------------//
    AN #flagBadParameter;
    AN #flagChildFailed;
    CALL "fcHygieneStatus"
    (
        CLEAN_TIME                  := #HYGIENE_DATA.CLEAN_TIME ,
        STERILE_TIME                := #HYGIENE_DATA.STERILE_TIME ,
        CLEAN_TOUT                  := #HYGIENE_DATA.CLEAN_TOUT ,
        STERILE_TOUT                := #HYGIENE_DATA.STERILE_TOUT ,
        HYGIENE_STATE               := #HYGIENE ,
        CLEAN_ELAPSED_TIME          := #HYGIENE_DATA.CLEAN_ELAPSED_TIME ,
        STERILE_ELAPSED_TIME        := #HYGIENE_DATA.STERILE_ELAPSED_TIME
    );
    NOP 0;
@@ATTR_END|HYGIENE@@

@@ATTR_BEGIN|TIMER@@
NETWORK
TITLE = Hour Min & Sec to Time variable
    //------------------------------------------------------------------------//
    // TIMER   TIMER   TIMER   TIMER   TIMER   TIMER   TIMER   TIMER   TIMER  //
    //                                                                        //
    // Convert calling timer value to Time variable:                          //
    //------------------------------------------------------------------------//
    AN #flagBadParameter;
    AN #flagChildFailed;
    CALL "hms_time"
    (
        H                           := #TIME_RUN_H ,
        M                           := #TIME_RUN_M ,
        S                           := #TIME_RUN_S ,
        TTIM_VAL                    := #tTime ,
        dTIM_VAL                    := #dTime
    );
    NOP 0;
@@ATTR_END|TIMER@@

NETWORK
TITLE = Batch ID if CRP1
      A(;
      L #MFL1.SY;
      L "dbCONST_VAL".UNIT.OWNER.S1;
      ==I;
      );
      JNB _001;
      CALL BLKMOV
      {blk_type := 'Any'}
      (  SRCBLK                      := "idbCRP".CRP1.BATCHCYCLE ,
         RET_VAL                     := #RetVal ,
         DSTBLK                      := "idbMFL".MFL1.BATCHCYCLE
      );
_001:      NOP 0;



COPY MASTER RECIPE TO CONTROL Recipe
