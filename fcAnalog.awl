//----------------------------------------------------------------------------//
//            Copyright 2018 Rieckermann Engineering Operations               //
//----------------------------------------------------------------------------//
// Class:       fcAnalog                                                      //
// Description:                                                               //
// Reads a raw analog value in counts and scaled to engineering units. Also   //
// checks for underrange or overrange value error or open wire fault. Sets a  //
// Data Quality flag if the reading is healthy.                               //
//----------------------------------------------------------------------------//
// Revision history:                                                          //
// Rev By               Date        CC        Note                            //
// 1.0 David Paspa      18-Apr-2018 NA        Reboot for S7-1500 extracted    //
//                                            from existing analog FBs, such  //
//                                            as MI1, PI1, TI1, etc.          //
//----------------------------------------------------------------------------//
FUNCTION "fcAnalog" : Void
TITLE = Analog input scaling and error checking
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : REO
NAME : fcAnalog
VERSION : 1.0

//----------------------------------------------------------------------------//
// Declare variables:                                                         //
//----------------------------------------------------------------------------//
VAR_IN_OUT
    ai : "udtAnalog";        // Analog input structure
END_VAR

VAR_TEMP
    retVal : Word;           // Returns a value of W#16#0000 if the instruction executes without error.
    tPV : Real;
    tRAW : Int;
END_VAR

BEGIN
NETWORK
TITLE = Raw field input scaling in Auto mode
    //------------------------------------------------------------------------//
    // INPUTS   INPUTS   INPUTS   INPUTS   INPUTS   INPUTS   INPUTS   INPUTS  //
    // INPUTS   INPUTS   INPUTS   INPUTS   INPUTS   INPUTS   INPUTS   INPUTS  //
    //                                                                        //
    // Get the raw field input reading in Auto mode:                          //
    //------------------------------------------------------------------------//
    A #ai.modeAUTO;
    JCN _a;
    L #ai.RAW_INPUT;
    T #tRAW;
_a:   NOP 0;

NETWORK
TITLE = User input sets process value in Manual mode
    //------------------------------------------------------------------------//
    // Set the user input value as the PV in Manual mode:                     //
    //------------------------------------------------------------------------//
    A #ai.modeMANUAL;
    JCN _b;
    L #ai.USER_INPUT;
    T #tPV;
_b:   NOP 0;

NETWORK
TITLE = Scale the input if not in Manual mode
    //------------------------------------------------------------------------//
    // Scale the raw input reading:                                           //
    //------------------------------------------------------------------------//
    AN #ai.modeMANUAL;
    JCN _c;
    CALL SCALE
    (   IN                             := #tRAW ,
        HI_LIM                         := #ai.RANGE_UPPER ,
        LO_LIM                         := #ai.RANGE_LOWER ,
        BIPOLAR                        := #ai.POLARITY ,
        RET_VAL                        := #retVal ,
        OUT                            := #tPV
    );
_c:   NOP 0;

NETWORK
TITLE = Check for out of range error
    //------------------------------------------------------------------------//
    // Check if the raw input value is underrange or overrange:               //
    //------------------------------------------------------------------------//
    A(;
    O(;
    L #tRAW;
    L 27648;
    >I;
    );
    O(;
    L #tRAW;
    L 0;
    <I;
    );
    );
    AN #ai.modeOOS;
    = #ai.RANGE_ERROR;

NETWORK
TITLE = Check for broken wire
    //------------------------------------------------------------------------//
    // Check if the raw input indicates open loop:                            //
    //------------------------------------------------------------------------//
    A(;
    O(;
    L #tRAW;
    L 32767;
    ==I;
    );
    O(;
    L #tRAW;
    L -32768;
    ==I;
    );
    );
    AN #ai.modeOOS;
    = #ai.BROKEN_WIRE;

NETWORK
TITLE = Set Data Quality
    //------------------------------------------------------------------------//
    // If no error set Data Quality DQ=1 (GOOD), else DQ=0 (BAD):             //
    //------------------------------------------------------------------------//
    AN #ai.RANGE_ERROR;
    AN #ai.BROKEN_WIRE;
    AN #ai.modeOOS;
    O #ai.modeMANUAL;
    = #ai.DQ;

NETWORK
TITLE = HighHigh ALARM
    //------------------------------------------------------------------------//
    // Set HighHigh Alarm if limit reached:                                   //
    //------------------------------------------------------------------------//
    AN #ai.modeOOS;
    A #ai.ENABLE_HH;
    A(;
    L #tPV;
    L #ai.LIMIT_HH;
    >=R;
    );
    = #ai.ALARM_HH;

NETWORK
TITLE = High ALARM
    //------------------------------------------------------------------------//
    // Set High Alarm if limit reached:                                       //
    //------------------------------------------------------------------------//
    AN #ai.modeOOS;
    A #ai.ENABLE_H;
    A(;
    L #tPV;
    L #ai.LIMIT_H;
    >=R;
    );
    = #ai.ALARM_H;

NETWORK
TITLE = Low ALARM
    //------------------------------------------------------------------------//
    // Set Low Alarm if limit reached:                                        //
    //------------------------------------------------------------------------//
    AN #ai.modeOOS;
    A #ai.ENABLE_L;
    A(;
    L #tPV;
    L #ai.LIMIT_L;
    <=R;
    );
    = #ai.ALARM_L;

NETWORK
TITLE = LowLow ALARM
    //------------------------------------------------------------------------//
    // Set LowLow Alarm if limit reached:                                     //
    //------------------------------------------------------------------------//
    AN #ai.modeOOS;
    A #ai.ENABLE_LL;
    A(;
    L #tPV;
    L #ai.LIMIT_LL;
    <=R;
    );
    = #ai.ALARM_LL;

NETWORK
TITLE = INTERLOCK if bad data quality or high high limit
    //------------------------------------------------------------------------//
    // Set interlock flag if data quality is bad (Range error OR Broken Wire) //
    // or if High High limit reached:                                         //
    //------------------------------------------------------------------------//
    O #ai.INTERLOCK;
    O #ai.ALARM_HH;
    ON #ai.DQ;
    = #ai.INTERLOCK;

NETWORK
TITLE = Set scaled analog process value
    //------------------------------------------------------------------------//
    // OUTPUTS   OUTPUTS   OUTPUTS   OUTPUTS   OUTPUTS   OUTPUTS   OUTPUTS    //
    // OUTPUTS   OUTPUTS   OUTPUTS   OUTPUTS   OUTPUTS   OUTPUTS   OUTPUTS    //
    //                                                                        //
    // Set the process value regardless of any error:                         //
    //------------------------------------------------------------------------//
    L #tPV;
    T #ai.PV;

NETWORK
TITLE = Set Device State to Enabled if healthy
    //------------------------------------------------------------------------//
    // STATE   STATE   STATE   STATE   STATE   STATE   STATE   STATE   STATE  //
    // STATE   STATE   STATE   STATE   STATE   STATE   STATE   STATE   STATE  //
    //                                                                        //
    // ENABLED if input signal is healthy:                                    //
    //------------------------------------------------------------------------//
    A #ai.DQ;
    JCN _d;
    L #ai.STATE_ENABLED;
    T #ai.STATE;
_d:   NOP 0;

NETWORK
TITLE = Set Device State to Fault if any field signal error
    //------------------------------------------------------------------------//
    // FAULT if any input error:                                              //
    //------------------------------------------------------------------------//
    AN #ai.DQ;
    JCN _e;
    L #ai.STATE_FAULT;
    T #ai.STATE;
_e:   NOP 0;
END_FUNCTION
